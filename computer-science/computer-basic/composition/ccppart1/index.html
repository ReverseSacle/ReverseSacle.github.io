<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content=#222><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=icon type=image/ico sizes=48x48 href=/images/favicon.ico><link rel=alternate type=application/rss+xml title=逆转天平 href=https://www.reversesacle.com/rss.xml><link rel=alternate type=application/atom+xml title=逆转天平 href=https://www.reversesacle.com/atom.xml><link rel=alternate type=application/json title=逆转天平 href=https://www.reversesacle.com/feed.json><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel=stylesheet href=/css/app.css><meta name=description content=计算机基础><link rel=canonical href=https://www.reversesacle.com/computer-science/computer-basic/composition/ccppart1/ ><title>计算机组成原理-CSAPP-第一部分 - 计算机组成原理 - 计算机基础 - 计算机科学 | ReverseSacle-Blog</title><meta name=generator content="Hexo 6.3.0"></head><body itemscope itemtype=http://schema.org/WebPage><div id=loading><div class=dotloader><div class=dot></div><div class=dot></div><div class=dot></div><div class=dot></div><div class=dot></div></div></div><div id=container><header id=header itemscope itemtype=http://schema.org/WPHeader><div class=inner><div id=brand><div class=pjax><h1 itemprop="name headline">计算机组成原理-CSAPP-第一部分</h1><div class=meta><span class=item title="创建时间：2023-10-08 18:43:12"><span class=icon><i class="ic i-calendar"></i></span> <span class=text>发表于</span> <time itemprop="dateCreated datePublished" datetime=2023-10-08T18:43:12+08:00>2023-10-08</time></span><span class=item title=本文字数><span class=icon><i class="ic i-pen"></i></span> <span class=text>本文字数</span> <span>40k</span> <span class=text>字</span></span><span class=item title=阅读时长><span class=icon><i class="ic i-clock"></i></span> <span class=text>阅读时长</span> <span>46 分钟</span></span></div></div></div><nav id=nav><div class=inner><div class=toggle><div class=lines role=navigation aria-label=切换导航栏><span class=line></span><span class=line></span><span class=line></span></div></div><ul class=menu><li class="item title"><a href=/ rel=start>ReverseSacle-Blog</a></li></ul><ul class=right><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id=imgs class=pjax><ul><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg9.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg8.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg11.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg12.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg19.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg15.webp></li></ul></div></header><div id=waves><svg class=waves xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink viewBox="0 24 150 28" preserveAspectRatio=none shape-rendering=auto><defs><path id=gentle-wave d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352z"/></defs><g class=parallax><use xlink:href=#gentle-wave x=48 y=0 /><use xlink:href=#gentle-wave x=48 y=3 /><use xlink:href=#gentle-wave x=48 y=5 /><use xlink:href=#gentle-wave x=48 y=7 /></g></svg></div><main><div class=inner><div id=main class=pjax><div class="article wrap"><div class=breadcrumb itemscope itemtype=https://schema.org/BreadcrumbList><i class="ic i-home"></i> <span><a href=/ >首页</a></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/ itemprop=item rel=index title="分类于 计算机科学"><span itemprop=name>计算机科学</span></a><meta itemprop=position content=1></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/computer-basic/ itemprop=item rel=index title="分类于 计算机基础"><span itemprop=name>计算机基础</span></a><meta itemprop=position content=2></span><i class="ic i-angle-right"></i> <span class=current itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/computer-basic/computer-composition-principles/ itemprop=item rel=index title="分类于 计算机组成原理"><span itemprop=name>计算机组成原理</span></a><meta itemprop=position content=3></span></div><article itemscope itemtype=http://schema.org/Article class="post block" lang=zh-CN><link itemprop=mainEntityOfPage href=https://www.reversesacle.com/computer-science/computer-basic/composition/ccppart1/ ><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content=/images/avatar.webp><meta itemprop=name content=ReverseSacle><meta itemprop=description content="所见即所得，所思即所行, 知识书库 & 学习点滴"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content=逆转天平></span><div class="body md" itemprop=articleBody><h2 id=计算机系统漫游a-tour-of-computer-system><a class=anchor href=#计算机系统漫游a-tour-of-computer-system>#</a> 计算机系统漫游(A Tour of Computer System)</h2><p>通过介绍<code>hello world</code>这个程序的生命周期来对计算机系统的主要概念做一个概述。</p><h3 id=编译原理概述><a class=anchor href=#编译原理概述>#</a> 编译原理概述</h3><p>Linux系统下可通过GCC命令<code>gcc -o hello hell.c</code>来完成编译(<code>hello.c</code>源文件经过编译系统gcc之后就可以生成可执行程序hello)，对于这个命令的过程大致可分为四个阶段。</p><p><font size=3><ins><strong>第一阶段-预处理</strong></ins></font></p><p><strong>预处理器</strong>(Preprocessor-cpp)会根据以<code>#</code>开头的代码来修改原始程序(读取头文件的内容，将内容插入到源程序中，最后得到另外一个C程序)，经过预处理器后得到的文件通常以<code>.i</code>结尾，<code>.i</code>文件仍是一个文本文件。</p><p><font size=3><ins><strong>第二阶段-编译</strong></ins></font></p><p><strong>编译器</strong>(Compiler-ccl)将<code>.i</code>文件翻译成<code>.s</code>文件，这个过程为编译。该阶段包括词法分析，语法分析、语义分析、中间代码生成以及优化等一系列的中间操作。</p><p><font size=3><ins><strong>第三阶段-汇编</strong></ins></font></p><p><strong>汇编器</strong>(Assembler-as)根据指令集将汇编程序<code>.s</code>文件翻译成机器指令并将机器指令按照固定的规则进行打包，最后得到<code>.o</code>结尾的可重定位目标二进制文件。</p><p><font size=3><ins><strong>第四阶段-链接</strong></ins></font></p><p>假如调用printf函数，会将代码翻译成计算机可理解的指令，这个printf函数在名为<code>printf.o</code>的文件中。</p><p><code>printf.o</code>是一个提前编译好的目标文件。<strong>连接器</strong>(Linker-ld)负责把<code>hello.o</code>和<code>printf.o</code>文件按照一定规则进行合并，最终可得到可执行目标文件 - <code>hello</code>，这个可执行目标文件可以被加载到内存中执行。这个过程中链接器要对<code>.o</code>文件进行调整，所以<code>.o</code>文件才被称为可重定位目标二进制文件。</p><p>Linux系统下可通过在shell程序中输入可执行程序的文件名来运行可执行程序。shell是一个命令解释程序，它输出一个提示符<code>&gt;</code>来等待一个命令行的输入，然后执行这个命令，如果该命令行的第一个单词不是内置的shell命令，那么shell就会假设这是一个可执行文件的名字，接着对这个文件进行加载并运行。</p><h3 id=中央处理单元处理器概述central-processing-unit-cpu><a class=anchor href=#中央处理单元处理器概述central-processing-unit-cpu>#</a> 中央处理单元(处理器)概述(Central Processing Unit - CPU)</h3><p><font size=3><ins><strong>PC(Program Count)</strong></ins></font></p><p>实质为一个大小为一个字节的存储区域(32位系统一个字是4个字节，64位是8个字节)，里面存放的是某一条指令的地址。从系统通电的那一瞬间，直到系统断电，处理器就在不断地执行PC指向的指令，然后更新指令，使其指向下一条要执行的指令。(这个下一条指令与刚刚执行的指令不一定是相邻的)</p><p><font size=3><ins><strong>寄存器文件(Register file)</strong></ins></font></p><p>CPU内部的一个存储设备，由一些单字长的寄存器构成，每个寄存器都有自己唯一的名字。</p><p>可以简单地将寄存器理解为一个临时存放数据的空间，例如计算两个变量<code>a+b</code>的和，处理器从内存中读取变量a的值并暂存在寄存器<code>X</code>中，读取变量b的值并暂存在寄存器<code>Y</code>中，这个操作会覆盖寄存器中原来的数值，当处理器完成加载的操作后，<code>ALU(Arithmatic/logic Unit)</code>会复制寄存器X和Y中保存的数值，然后再进行算术运算并将得到的结果保存到寄存器X或寄存器Y中，此时用于保存结果的寄存器中原来的数值会被新的数值覆盖。</p><p><font size=3><ins><strong>主存/内存(Main memory)</strong></ins></font></p><p>处理器在执行程序时，内存主要存放程序指令以及数据。从物理上来看，内存是由随机动态存储器芯片组成；从逻辑上来看，内存可以看成一个从零开始的大数组，每个字节都有相应的地址。内存和处理器之间通过总线来进行数据传递。总线贯穿了整个计算机系统，负责将信息从一个部件传递到另外一个部件，通常总线被设计成传送固定长度的字节块，即<strong>字</strong>(word)，对于这个字到底是多少个字节，各个系统中是不一样的。</p><p>除以上外，计算机系统还包括了各种输入输出设备，例如键盘、鼠标、显示器以及磁盘等，每一个输入输出设备都通过一个控制器或适配器与IO总线相连。</p><p>控制器与适配器主要区别是它们的封装方式，无论是控制器还是适配器，它们的功能都是在IO设备与IO总线之间传递数据。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part1/1.webp alt=""></p><h3 id=可执行程序执行时发生了什么><a class=anchor href=#可执行程序执行时发生了什么>#</a> 可执行程序执行时发生了什么</h3><p>假如有可执行程序hello，首先在shell中输入<code>./hello</code>字符，shell程序会将输入的字符逐一读入寄存器，处理器会把这个字符串放入内存中，当完成输入并按下回车时，shell程序即可知已完成命令的输入。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part1/2.webp alt=""></p><p>之后shell程序会执行一系列的指令来加载可执行文件hello，这些指令将hello中的数据和代码从磁盘复制到内存，数据就是要显示输出的<code>hello,world\n</code>，这个复制过程将利用<code>DMA(Direct Memory Access)</code>技术，数据可以不经过处理器就可从磁盘直接到达内存，当可执行文件hello中的代码和数据被加载到内存中时，处理器就开始执行main函数中的代码。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part1/3.webp alt=""></p><p>这里的hello代码中的main函数里只有一个打印功能。CPU会将<code>hello,world\n</code>这个字符串从内存复制到寄存器文件，然后再从寄存器文件复制到显示设备，最终<code>hello,world</code>显示在屏幕上。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part1/4.webp alt=""></p><h3 id=计算机内存层次结构memory-hierarchy><a class=anchor href=#计算机内存层次结构memory-hierarchy>#</a> 计算机内存层次结构(Memory Hierarchy)</h3><p>系统即使执行非常简单的程序，数据信息仍然需要在磁盘，内存，处理器以及IO设备之间进行搬运，数据从一个地方搬运到另外一个地方需要花费时间。</p><p>通常情况下，大容量的存储设备的存取速度要比小容量的慢，运行速度更快的设备的价格相对于低速设备要更贵。例如，在一个系统上磁盘的容量一般为TB级，内存的容量一般为GB级，磁盘的容量大概是内存的1000倍。对于处理器而言，从磁盘上读取一个字所花费的时间开销要比从内存中读取的开销要多1000万倍。寄存器文件中只能存储几百个字节的信息，而内存中可以存放几十亿的字节信息(GB级)，处理器从寄存器文件读取数据比从内存读取大概要快100倍。</p><p>针对处理器和内存之间的差异，系统设计人员在寄存器文件和内存之间引入了<strong>高速缓存</strong>(cache)。较新的、处理功能比较强的处理器，一般有三级高速缓存，分别为<code>L1 cache</code>，<code>L2 cache</code>，<code>L3 cache</code>。<code>L1 cache</code>的访问速度与访问寄存器文件几乎一样快，容量大小为数万字节(KB级别)；<code>L1 cache</code>的访问速度是<code>L2 cache</code>的5倍，容量大小为数十万到百万字节之间；<code>L3 cache</code>的容量更大，访问速度与<code>L2 cache</code>相比更慢。</p><p>因此，整个计算机系统的信息存储可以用一个层次结构来表示，对于这个层次结构，从上到下，设备的访问速度越来越慢，容量越来越大，每个字节的造价也越来越便宜。这个层次结构的主要思想是：上一层存储设备是下一层存储设备的高速缓存，例如寄存器文件就是L1的高速缓存，L1是L2的高速缓存，内存是磁盘的高速缓存等。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part1/5.webp alt=""></p><hr><p>hello程序运行的细节中，无论是shell程序还是hello程序都没有直接访问键盘、显示器、磁盘这些硬件设备，真正操控硬件的是操作系统。可以简单地将操作系统看成是应用程序和硬件之间的中间层，所有应用程序对硬件的操作必须通过操作系统来完成，这样设计的目的主要有两个，一是防止硬件被失控的应用程序滥用，另外一个目的就是：操作系统提供统一的机制来控制这些复杂的底层硬件。为了实现上述的目的，操作系统引入了几个抽象的概念，例如，<strong>文件</strong>是对IO设备的抽象；<strong>虚拟内存</strong>是对内存和磁盘IO的抽象；<strong>进程</strong>是对处理器，内存以及IO设备的抽象；<strong>虚拟机</strong>是对整个计算机系统的抽象(包括操作系统，处理器以及程序)。</p><h3 id=进程概述><a class=anchor href=#进程概述>#</a> 进程概述</h3><p>假设只有两个并发的进程，shell进程和hello进程。</p><p>最开始的时候，只有shell进程在运行，即shell在等待命令行的输入。当通过shell进程加载hello进程时，shell进程通过系统调用来执行请求，系统调用会将控制权从shell进程传递给操作系统，操作系统保存shell进程的上下文，然后创建一个新的hello进程以及上下文，然后将控制权转交给新的hello进程，hello进程执行完之后，操作系统就会恢复shell进程的上下文，并将控制权交给shell进程，之后shell进程继续等待下一个命令的输入。解释下这里提到的<strong>上下文</strong>(context)，操作系统会跟踪进程运行中所需要的所有状态信息，这种状态称为上下文。例如当前PC和寄存器的值，以及内存中的内容等。</p><p>现代操作系统中，一个进程实际上由多个线程组成，每个线程都运行在进程的上下文中，共享代码和数据。</p><h3 id=虚拟内存概述><a class=anchor href=#虚拟内存概述>#</a> 虚拟内存概述</h3><p>它为每个进程提供了一个假象，即每个进程都在独自占用整个内存空间，每个进程看到的内存都是一样的，这被称为虚拟地址空间。</p><p>Linux系统中进程的虚拟地址空间，从下往上，地址是增大的，最下面是0地址。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part1/6.webp alt=""></p><hr><p>这里<strong>自下而上</strong>来介绍下Linux系统的虚拟地址空间的分布。</p><p><font size=3><ins><strong>只读数据区域(Read-only code and data)</strong></ins></font></p><p>该区域用于存放程序的代码和数据，该区域的内容是从可执行目标文件中加载而来的。例如hello程序，对于所有进程而言，代码都是从固定的地址开始的。</p><p><font size=3><ins><strong>读写数据区域(Read/Write data)</strong></ins></font></p><p>在C语言中，全局变量就存放在这个区域。</p><p><font size=3><ins><strong>堆(Run-time heap)</strong></ins></font></p><p>程序中malloc所申请的内存空间就在这个堆中，程序的代码和数据区在程序一开始的时候就被指定了大小，但是堆可以在运行时动态的扩展和收缩。</p><p><font size=3><ins><strong>共享库存放区域(Memory-mapped region for shared libraries)</strong></ins></font></p><p>主要存放像C语言的标准库和数学库这种共享库的代码和数据。</p><p><font size=3><ins><strong>用户栈(User Stack)</strong></ins></font></p><p>函数调用的本质就是压栈，即每一次程序进行函数调用时，栈就会增长，函数执行完毕并返回后，栈就会收缩，栈的增长方向是从高地址到低地址。</p><p><font size=3><ins><strong>内核区域(Kernel Memory)</strong></ins></font></p><p>应用程序代码不能读写该区域的数据，也不能直接调用内核中定义的函数，即这个区域对应用程序是不可见的。</p><hr><p>Linux系统的思想是：一切皆文件。所有的IO设备，包括键盘，磁盘，显示器，甚至网络等这些都可以看成文件，系统中所有的输入和输出都可以通过读写文件来完成。例如，当需要处理磁盘上的文件时，不需要了解具体的磁盘技术，同一个程序，可以在不同磁盘技术上的不同系统上运行。</p><h3 id=通过网络在远程主机上运行程序><a class=anchor href=#通过网络在远程主机上运行程序>#</a> 通过网络在远程主机上运行程序</h3><p>从一个系统的角度来看，网络也可以视为一个IO设备。</p><p>当在ssh的客户端中输入hello字符串并回车后，客户端的软件会通过网络将字符串发送到ssh服务端，ssh服务端从网络端接收到这个字符串后，会将该字符串传递给远程主机上的shell程序，然后shell负责hello程序的加载，运行结果返回给ssh的服务端，最后ssh的服务端通过网络将程序的运行结果发送给ssh的客户端，ssh客户端在屏幕上显示运行结果。</p><hr><p>阿姆达尔定律的主要思想是，当对系统的某一部分进行加速时，被加速部分的重要性和加速程度是影响整体系统性能的关键因素。如果需要将系统的性能提高2倍或更多，只有通过优化大部分的组件才能获得。</p><p>想获得更高的计算能力，有三种途径</p><ul><li>线程级并发(Thread-Level Concurrency)</li><li>指令级并行(Instruction-Level Parallelism)</li><li>单指令，多数据并行(Single-Instruction Multiple-Data Parallelism)</li></ul><p>假如处理器芯片具有四个CPU核心，每个CPU核心都有自己的<code>L1 cache</code>和<code>L2 cache</code>，四个CPU核心共享<code>L3 cache</code>，这4个CPU核心集成在一颗芯片上。对于许多高性能的服务器芯片，单颗芯片集成的CPU数量高达几十个，甚至上百个，通过增加CPU的核心数，可以提高系统的性能。除此方法外，还有一个技术 - 超线程(hyperthreading)，也称<strong>同时多线程</strong>，如果每个CPU核心可以执行两个线程，那么四个核心就可以并行的执行8个线程。</p><p>关于单个CPU核心实现超线程，在CPU内部，像程序计数器和寄存器这样的硬件部件有多个备份，像浮点运算部件这样的硬件只有一份，常规单线程处理器在做线程切换时，大概需要20000个时钟周期，而超线程处理器可以在单周期的基础上决定执行哪一个线程，这样一来，CPU可以更好地利用它的处理资源。当一个线程因为读取数据而进入等待状态时，CPU可以去执行另外一个线程，其中线程之间的切换只需要极少的时间代价。</p><p>现代处理器可以同时执行多条指令的属性称为<strong>指令级并行</strong>，每条指令从开始到结束大概需要20个时钟周期或更多，但是处理器采用了非常多的技巧，可以同时处理多达100条指令，因此，最新的处理器可以保持每个周期2~4条指令的执行速率。</p><p>现代处理器有特殊的硬件部件，允许一条指令产生多个并行的操作，这种方式称为<strong>单指令多数据</strong>(Single Instruction Multiple Data - SIMD)，SIMD的指令多是为了提高处理视频/声音这类数据的执行速度，比较新的Intel以及AMD的处理器都支持SIMD指令加速。</p><h2 id=信息的表示和处理representing-and-manipulating-information><a class=anchor href=#信息的表示和处理representing-and-manipulating-information>#</a> 信息的表示和处理(Representing and Manipulating Information)</h2><h3 id=信息存储information-storage><a class=anchor href=#信息存储information-storage>#</a> 信息存储(Information Storage)</h3><p>通常情况下，程序将内存视为一个非常大的数组，数组的元素是由一个个的字节组成，每个字节都由一个唯一的数字来表示，该数字被称为<strong>地址</strong>(address)，所有的这些地址的集合就称为<strong>虚拟地址空间</strong>(virtual address space)。</p><p><strong>字节</strong>(byte)是信息存储的基本单元，一个字节由8个<strong>位</strong>(bit)组成。在二进制表示法中，每一个位的值可能有两种状态 - 0和1。当8个位全为0时，表示一个字节的最小值；当8个位全为1时，表示最大值。如果用十进制表示，那一个字节的取值范围区间为[0,255]，这种按照一位一位表示数据的方式称为<strong>位模式</strong>。使用二进制表示法比较冗长，而十进制表示法与位模式之间的转换又比较麻烦，故引入十六进制数来表示位模式。</p><p><strong>十进制数</strong>(Decimal Notation)是由数字0~9组成，而<strong>十六进制数</strong>(Hexadecimal Notation)是由数字<code>0~9</code>和字母<code>A~F</code>来表示16个可能的数值，其字母部分即可以全部是大写，也可以全部是小写，还可以是大小写混合。在C语言中，十六进制数是以<code>0x</code>开头，这个<code>x</code>可以是小写也可以是大写。</p><hr><p><font size=3><ins><strong>二进制与十六进制的转换</strong></ins></font></p><p>记住1010(A)，1100(C)，1111(F)所对应的十六进制数，B和D的数值可以由A和C加一得到，E的数值可以由F减一得到。</p><p><font size=3><ins><strong>十六进制与二进制的转换</strong></ins></font></p><p>通过展开每个十六进制数字，然后将它转换成对应的二进制格式即可。反过来，<strong>从二进制数转换为十六进制数</strong>，首先从右向左，每四位为一组来转换成相应的十六进制数，如果总位数不是4的倍数，其最左边的一组会出现小于4位的情况，这需要在前面补零，然后将每4位为一组的二进制数进行一一转换，即可得到对应的十六进制数。</p><p><font size=3><ins><strong>2的N次方的数快速转为二进制</strong></ins></font></p><p>n次方就是1后面跟n个零，十六进制的一个0可以代表4个二进制0，可以将n分解成<code>i</code>加<code>4j</code>，(<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>n</mi><mo>=</mo><mi>i</mi><mo>+</mo><mn>4</mn><mi>j</mi></mstyle></mrow><annotation encoding=application/x-tex>\small n=i+4j</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.387504em;vertical-align:0></span><span class="mord mathnormal sizing reset-size6 size5">n</span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.668565em;vertical-align:-.07499700000000001em></span><span class="mord mathnormal sizing reset-size6 size5">i</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.768564em;vertical-align:-.174996em></span><span class="mord sizing reset-size6 size5">4</span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.05724em>j</span></span></span></span>)这个方程式可以理解为将n除以4，<code>j</code>是商，而<code>i</code>就是余数，因此i可能的取值为0,1,2,3，那么与之对应的十六进制数就是[<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><msup><mn>2</mn><mn>0</mn></msup><mo>=</mo><mn>1</mn></mstyle></mrow><annotation encoding=application/x-tex>\small 2^0=1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.713364em;vertical-align:0></span><span class="mord sizing reset-size6 size5"><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.7926266666666666em><span style=top:-2.963em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">1</span></span></span></span>]，[<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><msup><mn>2</mn><mn>1</mn></msup><mo>=</mo><mn>2</mn></mstyle></mrow><annotation encoding=application/x-tex>\small 2^1=2</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.713364em;vertical-align:0></span><span class="mord sizing reset-size6 size5"><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.7926266666666666em><span style=top:-2.963em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">2</span></span></span></span>]，[<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><msup><mn>2</mn><mn>2</mn></msup><mo>=</mo><mn>4</mn></mstyle></mrow><annotation encoding=application/x-tex>\small 2^2=4</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.713364em;vertical-align:0></span><span class="mord sizing reset-size6 size5"><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.7926266666666666em><span style=top:-2.963em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">4</span></span></span></span>]，[<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>8</mn></mstyle></mrow><annotation encoding=application/x-tex>\small 2^3=8</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.713364em;vertical-align:0></span><span class="mord sizing reset-size6 size5"><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.7926266666666666em><span style=top:-2.963em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">8</span></span></span></span>]。例如，<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mn>2048</mn><mo>=</mo><msup><mn>2</mn><mn>11</mn></msup></mstyle></mrow><annotation encoding=application/x-tex>\small 2048=2^{11}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">2</span><span class="mord sizing reset-size6 size5">0</span><span class="mord sizing reset-size6 size5">4</span><span class="mord sizing reset-size6 size5">8</span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.713364em;vertical-align:0></span><span class="mord sizing reset-size6 size5"><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.7926266666666666em><span style=top:-2.963em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，因此<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>n</mi><mo>=</mo><mn>3</mn><mo>+</mo><mn>4</mn><mo>∗</mo><mn>2</mn></mstyle></mrow><annotation encoding=application/x-tex>\small n=3+4*2</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.387504em;vertical-align:0></span><span class="mord mathnormal sizing reset-size6 size5">n</span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.654993em;vertical-align:-.07499700000000001em></span><span class="mord sizing reset-size6 size5">3</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">4</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">∗</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">2</span></span></span></span>，故可以快速得到十六进制表示为0x800。</p><p><font size=3><ins><strong>十进制与十六进制之间的转换</strong></ins></font></p><p>采用除法或乘法来处理，通过辗转相除法将一个十进制数转为十六进制数。例如十进制数314156，<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mn>314156</mn><mo>÷</mo><mn>16</mn><mo>=</mo><mn>19634</mn><mtext> 余12</mtext></mstyle></mrow><annotation encoding=application/x-tex>\small 314156 \div 16=19634 ~ \text{余12}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.654993em;vertical-align:-.07499700000000001em></span><span class="mord sizing reset-size6 size5">3</span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5">4</span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5">5</span><span class="mord sizing reset-size6 size5">6</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">÷</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5">6</span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.614997em;vertical-align:0></span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5">9</span><span class="mord sizing reset-size6 size5">6</span><span class="mord sizing reset-size6 size5">3</span><span class="mord sizing reset-size6 size5">4</span><span class="mspace nobreak sizing reset-size6 size5"> </span><span class="mord text sizing reset-size6 size5"><span class="mord cjk_fallback">余</span><span class=mord>12</span></span></span></span></span>，然后用<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mn>19634</mn><mo>÷</mo><mn>16</mn><mo>=</mo><mn>1227</mn><mtext> 余2</mtext></mstyle></mrow><annotation encoding=application/x-tex>\small 19634 \div 16=1227 ~ \text{余2}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.654993em;vertical-align:-.07499700000000001em></span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5">9</span><span class="mord sizing reset-size6 size5">6</span><span class="mord sizing reset-size6 size5">3</span><span class="mord sizing reset-size6 size5">4</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">÷</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5">6</span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.614997em;vertical-align:0></span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5">2</span><span class="mord sizing reset-size6 size5">2</span><span class="mord sizing reset-size6 size5">7</span><span class="mspace nobreak sizing reset-size6 size5"> </span><span class="mord text sizing reset-size6 size5"><span class="mord cjk_fallback">余</span><span class=mord>2</span></span></span></span></span>，继续<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mn>1227</mn><mo>÷</mo><mn>16</mn><mo>=</mo><mn>76</mn><mtext> 余11</mtext></mstyle></mrow><annotation encoding=application/x-tex>\small 1227 \div 16=76 ~ \text{余11}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.654993em;vertical-align:-.07499700000000001em></span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5">2</span><span class="mord sizing reset-size6 size5">2</span><span class="mord sizing reset-size6 size5">7</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">÷</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5">6</span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.614997em;vertical-align:0></span><span class="mord sizing reset-size6 size5">7</span><span class="mord sizing reset-size6 size5">6</span><span class="mspace nobreak sizing reset-size6 size5"> </span><span class="mord text sizing reset-size6 size5"><span class="mord cjk_fallback">余</span><span class=mord>11</span></span></span></span></span>，最后<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mn>76</mn><mo>÷</mo><mn>16</mn><mo>=</mo><mn>4</mn><mtext> 余12</mtext></mstyle></mrow><annotation encoding=application/x-tex>\small 76 \div 16=4 ~ \text{余12}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.654993em;vertical-align:-.07499700000000001em></span><span class="mord sizing reset-size6 size5">7</span><span class="mord sizing reset-size6 size5">6</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">÷</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5">6</span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.614997em;vertical-align:0></span><span class="mord sizing reset-size6 size5">4</span><span class="mspace nobreak sizing reset-size6 size5"> </span><span class="mord text sizing reset-size6 size5"><span class="mord cjk_fallback">余</span><span class=mord>12</span></span></span></span></span>，直到商不能被16整除，余数为4。将得到的余数用16进制数来表示，自下而上，就可以得到最终得十六进制数为<code>0x4CB2C</code>。反过来将一个十六进制数转换为十进制数，用16得幂乘以相应位数得十六进制数，例如十六进制数0x7AF，<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>F</mi><mo>∗</mo><mn>1</mn><msup><mn>6</mn><mn>0</mn></msup><mo>+</mo><mi>A</mi><mo>∗</mo><mn>1</mn><msup><mn>6</mn><mn>1</mn></msup><mo>+</mo><mn>7</mn><mo>∗</mo><mn>1</mn><msup><mn>6</mn><mn>2</mn></msup><mo>=</mo><mn>1967</mn></mstyle></mrow><annotation encoding=application/x-tex>\small F*16^0+A*16^1+7*16^2=1967</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.614997em;vertical-align:0></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.13889em>F</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">∗</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.788361em;vertical-align:-.07499700000000001em></span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5"><span class=mord>6</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.7926266666666666em><span style=top:-2.963em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.614997em;vertical-align:0></span><span class="mord mathnormal sizing reset-size6 size5">A</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">∗</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.788361em;vertical-align:-.07499700000000001em></span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5"><span class=mord>6</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.7926266666666666em><span style=top:-2.963em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">7</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">∗</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.713364em;vertical-align:0></span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5"><span class=mord>6</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.7926266666666666em><span style=top:-2.963em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5">9</span><span class="mord sizing reset-size6 size5">6</span><span class="mord sizing reset-size6 size5">7</span></span></span></span>。对于较大数值的十进制与十六进制之间的转换，可以借助一些软件工具来实现。</p><hr><p><strong>字长</strong>(word size)决定了虚拟地址空间的最大值(Virtual Address Space)，即一个字长为<code>w</code>位的机器，虚拟地址的范围是[<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mn>0</mn><mo separator=true>,</mo><msup><mn>2</mn><mi>w</mi></msup><mo>−</mo><mn>1</mn></mstyle></mrow><annotation encoding=application/x-tex>\small 0,2^w-1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.760032em;vertical-align:-.174996em></span><span class="mord sizing reset-size6 size5">0</span><span class="mpunct sizing reset-size6 size5">,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class="mord sizing reset-size6 size5"><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.65004em><span style=top:-2.963em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mathnormal mtight" style=margin-right:.02691em>w</span></span></span></span></span></span></span></span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">−</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">1</span></span></span></span>]。对于32位的机器，虚拟地址空间最大为4GB，而64位的机器，虚拟地址空间最大为16EB。在迁移的过程中，大多数64位的机器做了向后兼容，因此32位机器编译的程序也可以运行在64位机器上。在64位的机器上，可以通过命令<code>gcc -m32 -o hello32 hello.c</code>编译生成可以在32位机器上运行的程序，通过修改编译选项<code>gcc -m64 -o hello64 hello.c</code>，就可以编译生成在64位机器上运行的程序，其中的hello32程序即可在32位机器上运行，也可在64位机器上运行，但是hello64程序只能运行在64位的机器上。对于32位程序和64位程序，主要的区别还是在于程序是如何编译的，而不是运行机器的类型。</p><p>C语言中，支持整数和浮点数多种数据格式。例如一个int类型的变量<code>x(0x01234567)</code>，假设地址位于<code>0x100</code>处，由于int类型占4个字节，因此变量<code>x</code>被存储在地址为<code>0x100,0x101,0x102,0x103</code>的内存处。地址在内存中的布局有两种规则，首先是大端法，最高有效字节存储在最前面，也就是低地址处；另外一种规则就是小端法，最低有效字节存储在最前面。对于变量<code>x</code>，最高有效字节是<code>0x01</code>，最低有效字节是<code>0x67</code>。大多数Intel兼容机采用小端模式，IBM和Sun公司的机器大多数采用大端法。对于很多新的处理器，支持双端法，可以配置成大端或小端运行，例如基于ARM架构的处理器，支持双端法，但是Android系统和ios系统只能运行在小端模式。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part1/7.webp alt=""></p><p>C语言中的字符串被编码为以NULL字符(<code>\0</code>)结尾的字符数组。例如字符<code>abcde</code>，有5个字符，但长度却为6，因为还有个结尾字符，其十六进制表示为<code>0x00</code>。</p><p>使用ASCII码来表示字符，在任何系统上都会得到相同的结果，因此，文本数据比二进制数据具有更强的平台独立性，二进制是计算机编码，存储和操作信息的核心。</p><hr><p>数学家<strong>乔治布尔</strong>将逻辑值<code>true/false</code>编码成二进制的<code>1/0</code>，以此设计了布尔代数并作为逻辑推理的基本原则。</p><p>第一种布尔运算中的波浪线(<code>~</code>)对应逻辑运算<strong>非</strong>(NOT)，在计算机中通常将非运算称为<strong>取反</strong>。对0进行取反时运算结果是1；对1进行取反时运算结果是0。</p><p>第二种布尔运算对应逻辑运算<strong>与</strong>(AND)。运算的两个参数如果其中有一个数为0，那么与运算结果就为0；只有当运算的两个参数都为1时，运算结果才为1。</p><p>第三种布尔运算对应逻辑运算<strong>或</strong>(OR)。只有当运算的两个参数都为0时，运算结果才为0；如果两个参数都为1或者其中有一个参数为1，运算的结果才为1。</p><p>最后一种是<strong>异或</strong>(EXCLUSIVE-OR)。当两个参数同为0或者同为1时，异或运算的结果为0；当两个参数不同时，异或运算的结果才为1。</p><hr><p>C语言支持按位进行布尔运算。位运算的一个常见的用法就是实现掩码运算，即通过位运算可以得到特定的位序列。例如操作数<code>0x89ABCDEF</code>，当想得到该操作数的最低有效字节的值时，可通过按位与(<code>&amp;</code>)<code>0xFF</code>，以此可得到最低有效字节<code>0x00 00 00 EF</code>。</p><p>除了位级运算外，C语言还提供了一组<strong>逻辑运算</strong>。逻辑运算的运算符与位级运算的容易混淆，逻辑运算认为所有非零的参数都表示true，只有参数0表示false。逻辑运算的结果只有两种，true或false，而位运算只有在特殊的数值条件下才会得到0或1。</p><p>除以上外，C语言还提供了一组<strong>移位运算</strong>。对于左移运算(Left Shift)，左移一位就是丢弃最高的一位并在右端补一个0；对于右移，分为逻辑右移和算术右移，逻辑右移一位就是丢弃最低的一位，并在左端补一个0。对于算术右移，当其操作对象的最高位为0时，算术右移与逻辑右移没有任何差别，但当操作数的最高位为1时，算术右移后，左端需要补1，而不是补0。C语言中没有明确的规定有符号数应该使用哪一种类型的右移方法，但实际上，几乎所有的编译器以及机器的组合都是对有符号数采用算术右移。</p><h3 id=整数表示integer-representations><a class=anchor href=#整数表示integer-representations>#</a> 整数表示(Integer Representations)</h3><p>C语言支持多种整形数据类型，整形关键字可以用来指定不同整形类型数据的大小(所占的字节数也不同)，这是导致数值取值范围不同的直接原因。对于long类型的大小，其取值范围与机器字长相关，在64位机器上，long类型占8个字节；在32位机器上，long类型占4个字节，当变量声明带有unsigned关键字时，会限制表示的数字只能为非负数。</p><p>在计算机领域中，非负数通常称为<strong>无符号数</strong>。C语言中支持无符号数和有符号数，有符号数既可以是正数，也可以是负数。计算机中对于有符号数的编码采用了<strong>补码</strong>(<code>two's-complement</code>)形式，其最高位为符号位。虽然C语言标准中并没有要求用补码来表示有符号数，但几乎所有的机器都是用补码来表示有符号数。对于大多数C语言的实现，有符号和无符号数之间的转换的规则是 - 位模式不变，但是解释这些位的方式改变了。</p><p>在C语言中执行一个运算时，如果一个运算数是有符号数，另外一个运算数是无符号数，那么C语言会隐式地将有符号数强制转换为无符号数来执行运算。C语言中还有一个常见的运算是在不同字长的整数之间进行转换，将一个较大的数据类型转换成较小的数据类型，由于目标数据类型太小，想要保持数值不变时不可能的，然而将一个较小数据类型转换为较大的类型时，保持数值不变是可以的。</p><p>将一个<code>unsigned char</code>类型变量a，转换成<code>unsigned short</code>类型变量b，变量a占8个bit位，而变量b占16个bit位，对于无符号数的转换比较简单，只需要在扩展的数位进行补零即可，将这种运算称为<strong>零扩展</strong>。根据无符号数的编码定义，零扩展之后的数值不变，与无符号数相比，将有符号数转换成一个更大的数据类型，需要执行符号位扩展，这个符号位就是最高位。对于符号位扩展，当有符号数表示非负数时，最高位是0，此时扩展的数位进行补零即可；当有符号数表示负数时，最高位是1，此时扩展的数位需要进行补1。</p><p>当有符号数从一个较小的数据类型转换成较大类型时，进行符号位扩展，可以保持数值不变。对于较大的数据类型转换为较小类型的情况，将int类型强制转换为short类型时，int类型高16位数据被丢弃，留下低16位的数据，因此截断一个数字，可能会改变它原来的数值，将一个w位的无符号数，截断成k位时，丢弃最高的w-k位，截断操作可以对应于取模运算，对于二进制取模运算，就是除以2的k次方之后得到的余数。</p><h3 id=整数运算integer-arithmetic><a class=anchor href=#整数运算integer-arithmetic>#</a> 整数运算(Integer Arithmetic)</h3><p>假如有<code>unsigned char a = 255</code>和<code>unsigned char b = 1</code>，这两个无符号数相加，期望得到结果256，然而实际运行结果为0，这是因为a加b的和超过了<code>unsigned char</code>类型所能表示的最大值255，将这种情况称为<strong>溢出</strong>，在C语言中溢出时并不会报错。</p><p>对于无符号数的<strong>加法</strong>，当发生溢出时得到的和，小于其中任意一个数。对于有符号数加法，其溢出分为正溢出(Positive overflow)和负溢出(Negative overflow)，当两个正数相加得到的结果为负数，则发生了正溢出；当两个负数相加得到的结果为正数，则说明发生了负溢出。</p><p>关于<strong>减法</strong>，有一个新概念加法逆元(additive inverse)[<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>x</mi><mo>+</mo><msup><mi>x</mi><mo mathvariant=normal lspace=0em rspace=0em>′</mo></msup><mo>=</mo><msup><mi>x</mi><mo mathvariant=normal lspace=0em rspace=0em>′</mo></msup><mo>+</mo><mi>x</mi><mo>=</mo><mn>0</mn><mo stretchy=false>(</mo><mn>0</mn><mo>≤</mo><mi>x</mi><mo>&lt;</mo><msup><mn>2</mn><mi>w</mi></msup><mo stretchy=false>)</mo></mstyle></mrow><annotation encoding=application/x-tex>\small x+x&#x27;=x&#x27;+x=0(0 \le x&lt;2^w)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.599994em;vertical-align:-.07499700000000001em></span><span class="mord mathnormal sizing reset-size6 size5">x</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.660036em;vertical-align:0></span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal">x</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.7333733333333333em><span style=top:-2.963em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.7350329999999999em;vertical-align:-.07499700000000001em></span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal">x</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.7333733333333333em><span style=top:-2.963em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.387504em;vertical-align:0></span><span class="mord mathnormal sizing reset-size6 size5">x</span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.9em;vertical-align:-.225em></span><span class="mord sizing reset-size6 size5">0</span><span class="mopen sizing reset-size6 size5">(</span><span class="mord sizing reset-size6 size5">0</span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">≤</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.5203800000000001em;vertical-align:-.035190000000000006em></span><span class="mord mathnormal sizing reset-size6 size5">x</span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">&lt;</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.9em;vertical-align:-.225em></span><span class="mord sizing reset-size6 size5"><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.65004em><span style=top:-2.963em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mathnormal mtight" style=margin-right:.02691em>w</span></span></span></span></span></span></span></span><span class="mclose sizing reset-size6 size5">)</span></span></span></span>]，加法逆元也可以互为相反数。对于减法运算<code>y-x</code>，可以转换为y加上x的相反数。</p><p>对于无符号数的<strong>乘法</strong>，无论是无符号数乘法还是补码乘法，运算结果的位级表示都是一样的，但补码乘法比无符号乘法多一步，即需要将无符号数转为补码(有符号数)。无符号数和补码两种乘法乘积的完整位表示不同，但是截断之后结果的位级表示是相同的。由于乘法指令的执行需要多个时钟周期，很多C语言的编译器试图用移位，加法以及减法来代替整数乘法的操作，例如乘2对应左移一位，乘4对应左移两位，乘k次对应左移k位。</p><p>对于<strong>除法</strong>运算，除以2的幂运算可以用右移来实现，对于无符号数采用的是逻辑右移，而有符号数采用的是算术右移。整数的除法会遇到除不尽的情况，总是朝向0的方向进行舍入，例如<code>3.14</code>向零舍入的结果是<code>3</code>，<code>-3.14</code>向零舍入的结果是<code>-3</code>，对于x大于等于0，y大于0，结果会是向下舍入；当x小于0，y大于0时，结果将向上舍入。对于补码的除法，当补码的最高位等于0时，对于非负数而言，算术右移与除以2的k次方时一样的；对于负数而言，当需要舍入时，移位导致向下舍入，这与期望的结果不同，因此需要在移位之前加一个偏置来修正这种不合适的舍入，偏置的值等于1左移k位减去1。对于补码除以2的k次幂的情况，当x小于0时，需要先加上偏置再进行算术右移[<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mo stretchy=false>(</mo><mi>x</mi><mo>&lt;</mo><mn>0</mn><mtext> </mtext><mo stretchy=false>?</mo><mtext> </mtext><mi>x</mi><mo>+</mo><mo stretchy=false>(</mo><mn>1</mn><mo>&lt;</mo><mo>&lt;</mo><mi>k</mi><mo stretchy=false>)</mo><mo>−</mo><mn>1</mn><mo>:</mo><mi>x</mi><mo stretchy=false>)</mo><mo>&gt;</mo><mo>&gt;</mo><mi>k</mi></mstyle></mrow><annotation encoding=application/x-tex>\small (x&lt;0 ~ ? ~ x+(1&lt;&lt;k)-1:x)&gt;&gt;k</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.9em;vertical-align:-.225em></span><span class="mopen sizing reset-size6 size5">(</span><span class="mord mathnormal sizing reset-size6 size5">x</span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">&lt;</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.699993em;vertical-align:-.07499700000000001em></span><span class="mord sizing reset-size6 size5">0</span><span class="mspace nobreak sizing reset-size6 size5"> </span><span class="mclose sizing reset-size6 size5">?</span><span class="mspace nobreak sizing reset-size6 size5"> </span><span class="mord mathnormal sizing reset-size6 size5">x</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.9em;vertical-align:-.225em></span><span class="mopen sizing reset-size6 size5">(</span><span class="mord sizing reset-size6 size5">1</span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">&lt;</span></span><span class=base><span class=strut style=height:.5203800000000001em;vertical-align:-.035190000000000006em></span><span class="mrel sizing reset-size6 size5">&lt;</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.9em;vertical-align:-.225em></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.03148em>k</span><span class="mclose sizing reset-size6 size5">)</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">−</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">1</span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">:</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.9em;vertical-align:-.225em></span><span class="mord mathnormal sizing reset-size6 size5">x</span><span class="mclose sizing reset-size6 size5">)</span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">&gt;</span></span><span class=base><span class=strut style=height:.5203800000000001em;vertical-align:-.035190000000000006em></span><span class="mrel sizing reset-size6 size5">&gt;</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.624996em;vertical-align:0></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.03148em>k</span></span></span></span>]；对于x大于0的情况，可以直接进行算术右移，但这种方法不能推广到除以任意常数，与乘法不同，除法不能用除以2的幂的方法来表示除以任意常数k的除法。</p><h3 id=浮点数floatin-point><a class=anchor href=#浮点数floatin-point>#</a> 浮点数(Floatin Point)</h3><p>理解浮点数的第一步是考虑含有小数的二进制。</p><p>根据国际标准IEEE(电气和电子工程协会)754，任意一个二进制浮点数可以表示成下面的形式</p><p><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mo stretchy=false>(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy=false>)</mo><mi>S</mi></msup><mo>∗</mo><mi>M</mi><mo>∗</mo><msup><mn>2</mn><mi>E</mi></msup></mstyle></mrow><annotation encoding=application/x-tex>\small (-1)^S*M*2^E</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.9616979999999999em;vertical-align:-.225em></span><span class="mopen sizing reset-size6 size5">(</span><span class="mord sizing reset-size6 size5">−</span><span class="mord sizing reset-size6 size5">1</span><span class="mclose sizing reset-size6 size5"><span class=mclose>)</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8185533333333332em><span style=top:-2.963em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mathnormal mtight" style=margin-right:.05764em>S</span></span></span></span></span></span></span></span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">∗</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.614997em;vertical-align:0></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.10903em>M</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">∗</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.736698em;vertical-align:0></span><span class="mord sizing reset-size6 size5"><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8185533333333332em><span style=top:-2.963em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mathnormal mtight" style=margin-right:.05764em>E</span></span></span></span></span></span></span></span></span></span></span>，其中</p><ul><li><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mo stretchy=false>(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy=false>)</mo><mi>S</mi></msup></mstyle></mrow><annotation encoding=application/x-tex>\small (-1)^S</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.9616979999999999em;vertical-align:-.225em></span><span class="mopen sizing reset-size6 size5">(</span><span class="mord sizing reset-size6 size5">−</span><span class="mord sizing reset-size6 size5">1</span><span class="mclose sizing reset-size6 size5"><span class=mclose>)</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8185533333333332em><span style=top:-2.963em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mathnormal mtight" style=margin-right:.05764em>S</span></span></span></span></span></span></span></span></span></span></span> - 表示符号位，当S为0时，浮点数为正数；当S为1时，浮点数为负数</li><li><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>M</mi></mstyle></mrow><annotation encoding=application/x-tex>\small M</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.614997em;vertical-align:0></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.10903em>M</span></span></span></span> - 表示有效数字(<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mn>1</mn><mo>≤</mo><mi>M</mi><mo>&lt;</mo><mn>2</mn></mstyle></mrow><annotation encoding=application/x-tex>\small 1≤M&lt;2</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.702369em;vertical-align:-.12237300000000001em></span><span class="mord sizing reset-size6 size5">1</span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">≤</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.6501870000000001em;vertical-align:-.035190000000000006em></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.10903em>M</span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">&lt;</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">2</span></span></span></span>)</li><li><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><msup><mn>2</mn><mi>E</mi></msup></mstyle></mrow><annotation encoding=application/x-tex>\small 2^E</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.736698em;vertical-align:0></span><span class="mord sizing reset-size6 size5"><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8185533333333332em><span style=top:-2.963em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mathnormal mtight" style=margin-right:.05764em>E</span></span></span></span></span></span></span></span></span></span></span> - 表示规格化后的指数位</li></ul><p>例如</p><p>十进制的<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mn>5.0</mn></mstyle></mrow><annotation encoding=application/x-tex>\small 5.0</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">5</span><span class="mord sizing reset-size6 size5">.</span><span class="mord sizing reset-size6 size5">0</span></span></span></span>，其二进制为<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mn>101.0</mn></mstyle></mrow><annotation encoding=application/x-tex>\small 101.0</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5">0</span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5">.</span><span class="mord sizing reset-size6 size5">0</span></span></span></span>，规格化后即<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mn>1.01</mn><mo>∗</mo><msup><mn>2</mn><mn>2</mn></msup></mstyle></mrow><annotation encoding=application/x-tex>\small 1.01*2^2</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5">.</span><span class="mord sizing reset-size6 size5">0</span><span class="mord sizing reset-size6 size5">1</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">∗</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.713364em;vertical-align:0></span><span class="mord sizing reset-size6 size5"><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.7926266666666666em><span style=top:-2.963em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>(底下的2表示是二进制，指数是进位数)，使用以上规则可以得出</p><ul><li><p>S = 0 - 即正数</p></li><li><p>M =<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mn>101</mn></mstyle></mrow><annotation encoding=application/x-tex>\small 101</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5">0</span><span class="mord sizing reset-size6 size5">1</span></span></span></span>(小数位<code>.</code>的前面)</p></li><li><p>E = 2 - 即规格化后的指数</p></li></ul><p>IEEE754规定，对于32位浮点数，最高位的1位是<strong>符号位</strong><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>S</mi></mstyle></mrow><annotation encoding=application/x-tex>\small S</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.614997em;vertical-align:0></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.05764em>S</span></span></span></span>，符号位之后的8位是<strong>指数</strong><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>E</mi></mstyle></mrow><annotation encoding=application/x-tex>\small E</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.614997em;vertical-align:0></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.05764em>E</span></span></span></span>(阶码部分)，剩下的23位为<strong>有效数字</strong><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>M</mi></mstyle></mrow><annotation encoding=application/x-tex>\small M</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.614997em;vertical-align:0></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.10903em>M</span></span></span></span>(尾数部分)。</p><p>浮点数的数值可以分为三类</p><ul><li>规格化的值(Normalized Values)</li><li>非规格化的值(Denormalized Values)</li><li>特殊值(Special Values)</li></ul><p>阶码的值决定了这个数属于其中哪一类，当阶码字段的二进制位不全为0，且不全为1时，此时表示的是规格化的值；当阶码字段的二进制位全为0时，此时表示的数值是非规格化的值；当阶码字段的二进制位全为1时，此时表示的数值是特殊值，特殊值分为两类，一类表示无穷大或无穷小，另外一类表示<code>不是一个数</code>(NaN)。</p><hr><p><font size=3><ins><strong>规格化的值</strong></ins></font></p><p>当表示规格化的值时，其中阶码字段的取值范围[最小值1，最大值254]。阶码的值并不等于8个二进制位所表示的值，而是8个二进制位减去一个偏置量，偏置量的值与阶码字段的位数是相关的，当表示单精度的值时，阶码字段的长度为8，偏置量等于127；当表示双精度的数时，阶码字段的长度为11，偏置量等于1023。因此，对于单精度浮点数，阶码的最小值是<code>-126</code>，最大值为127。</p><p>对于小数字段，尾数M被定义为<code>1+f</code>，对于尾数M的二进制表示，可以通过调整E的取值使得尾数M的取值范围大于等于1，小于2。由于第一位总是1，就没必要显示出来，这就是尾数M的值需要加1的原因。</p><p><font size=3><ins><strong>非规格化的值</strong></ins></font></p><p>非规格化的数有两个用途，一是提供了表示数值0的方法，当符号位s等于0，阶码字段全为0，小数字段也全为0时，此时表示正零。当符号位s等于1，阶码字段全为0，小数字段也全为0时，此时表示负零。根据IEEE的浮点规则，正零和负零在某些方面被认为不同，而其他方面是相同的。非规格化的数另外一个用途就是可以表示非常接近0的数，当阶码字段全为0时，阶码E的值等于<code>1-bias</code>，而尾数的值M等于f，不包含隐藏的1，这与规格化的值的解释方法不同。</p><p><font size=3><ins><strong>特殊值</strong></ins></font></p><p>当阶码字段全为1，且小数字段全为0时，表示无穷尽大的数，无穷大分为正无穷大和负无穷大，如果符号位s等于0时，表示正无穷大；符号位s等于1，表示负无穷大。当遇到一些运算结果不为实数或用无穷也无法表示的情况，这里引入的一个新的概念 - <code>不是一个数</code>(Not a Number - NaN)，例如对<code>-1</code>进行开方运算，无穷减无穷的运算，得到的结果就是NaN。当阶码字段全为1，且小数字段不为0时，可以表示NaN。</p><p>对比整形数12345与单精度浮点数12345.0的二进制表示，通过移位发现二者有一段数位是相同的。将整形数12345转换成浮点数<code>12345.0</code>，整形数12345，其二进制的表示为<code>0000 0000 0000 0000 0011 0000 0011 1001</code>，虽然int类型的变量占32个比特位，由于该数高18位都等于0，因此可以将高18位忽略，只看低14位，根据规格化的表示规则，可以将12345表示为<code>1.1 0000 0011 1001 x 2^13</code>，根据IEEE浮点数的编码规则，可以将小数点左边的1丢弃，由于单精度的小数字段长度为23，还需要在末端增加10个零，这样就得到了浮点数的小数字段，从12345的规格化表示可以发现阶码E的值等于13，由于单精度浮点数的bias等于127，根据公式<code>E=e-bias</code>，可以计算出<code>e</code>的值等于140，其二进制表示为<code>1000 1100</code>，这样浮点数的阶码字段也得到了，最后再加上符号位的零，整个单精度浮点数的二进制表示就构造完了。</p><hr><p>由于表示方法的原因，限制了浮点数的范围和精度，所以浮点运算只能近视的表示实数运算，对于值x，可能无法用浮点形式来精确地表示，故希望可以找到最接近的值<code>x'</code>来代替<code>x</code>，这就是舍入操作的任务，有一个关键的问题是在两个可能的值中间确定舍入方向，例如一个数值1.5，想把该舍入到最接近的整数，舍入结果应该是1还是2呢？IEEE浮点格式定义了四种不同的舍入方式，分别是</p><ul><li>向偶数舍入(Round-to-even)</li><li>向零舍入(Round-toward-zero)</li><li>向下舍入(Round-down)</li><li>向上舍入(Round-up)</li></ul><p><strong>向下舍入</strong>总是朝向小的方向进行舍入，而<strong>向上舍入</strong>总是朝向大的方向进行舍入。</p><p><strong>向零舍入</strong>是把正数向下舍入，把负数向上舍入，将这种舍入规则映射到数轴上，可以发现舍入是朝向零的方向。</p><p><strong>向偶数舍入</strong>，也被称为向最接近的值进行舍入，当遇到两个可能结果的中间数值时，舍入结果应该如何计算？向偶数舍入的舍入结果要遵循最低有效数字是偶数的规则。如果总是采用向上舍入，会导致结果的平均值相对真实值略高；如果总是采用向下舍入，会导致结果的平均值相对真实值略低。向偶数舍入就避免了这种统计偏差，使得有一半的情况需要向上舍入，有一半的情况需要向下舍入，对于不想舍入到整数的情况，向偶数舍入的方法同样适用，只需要考虑最低有效位是偶数还是奇数就可以了。向偶数舍入也可以用在二进制小数上，将最低有效位的值0认为是偶数，1认为是奇数。</p><hr><p>对于浮点数的加法，是不具有结合性的，由于计算结果可能发生溢出或由于舍入而失去精度而导致浮点数的乘法也不具有结合性，此外，浮点乘法在加法上不具备分配性。</p><p>C语言提供了两种不同的浮点数据类型，单精度float类型和双精度double类型，当int，float，double不同数据类型之间进行强制类型转换时，得到的结果并非预期那样。当int类型转换成float类型时，数字不会发生溢出，但是可能会被舍入，这是由于单精度浮点数的小数字段是23位，可能会出现无法保留精度的情况；当int类型或者float类型转换成double类型时，由于double类型具有更大的范围，所以可以保留精确的数值；从double类型转换成float类型，由于float类型所表示数值的范围更小，所以可能会发生溢出。此外，float类型的精度相对于double较小，转换后还可能被舍入；当float类型或double类型的浮点数转换成int类型，一种可能的情况是值会向零舍入，另外一种可能的情况是发生溢出。</p><h2 id=程序的机器级表示machine-level-representation-of-programs><a class=anchor href=#程序的机器级表示machine-level-representation-of-programs>#</a> 程序的机器级表示(Machine-Level Representation of Programs)</h2><p>假如有两个C源文件<code>main.c</code>和<code>mstore.c</code>，以源文件<code>mstore.c</code>为例，先通过命令<code>gcc -Og -S mstore.c</code>生成汇编文件<code>mstore.s</code>，<code>-S</code>编译选项是让编译器GCC产生的文件为汇编文件。生成后，通过vim打开<code>.s</code>文件，其中的以<code>.</code>开头的行都是指汇编器和连接器工作的伪命令，即可以完全忽略以<code>.</code>开头的行，剩余的汇编代码与源文件中的C代码是相关的。例如，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">long</span> <span class="token function">mult2</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">,</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">void</span> <span class="token function">mulstore</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span><span class="token keyword">long</span> y<span class="token punctuation">,</span><span class="token keyword">long</span><span class="token operator">*</span> dest<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">long</span> t <span class="token operator">=</span> <span class="token function">mult2</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token operator">*</span>dest <span class="token operator">=</span> t<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>pushq <span class="token operator">%</span><span class="token register variable">rbx</span></pre></td></tr><tr><td data-num=2></td><td><pre>movq <span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token operator">%</span><span class="token register variable">rbx</span></pre></td></tr><tr><td data-num=3></td><td><pre>call mult2</pre></td></tr><tr><td data-num=4></td><td><pre>movq <span class="token operator">%</span><span class="token register variable">rax</span>,(<span class="token operator">%</span><span class="token register variable">rbx</span>)</pre></td></tr><tr><td data-num=5></td><td><pre>popq <span class="token operator">%</span><span class="token register variable">rbx</span></pre></td></tr><tr><td data-num=6></td><td><pre>ret</pre></td></tr></table></figure><p>pushq这条指令的意思是将寄存器rbx的值压入程序栈中来进行保存操作，为什么程序一开始要保存寄存器rbx的内容？在<code>Inter x86-64</code>的处理器中包含了16个通用目的寄存器，这些寄存器用来存放整数数据和指针，寄存器的名字都是以<code>%r</code>开头的。</p><hr><p><font size=3><ins><strong>调用者保存寄存器(Caller-saved)和被调用者保存寄存器(Callee-saved Register)</strong></ins></font></p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">func_A:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	<span class="token comment">; ...</span></pre></td></tr><tr><td data-num=3></td><td><pre>	movq <span class="token number">$123</span>,<span class="token operator">%</span><span class="token register variable">rbx</span></pre></td></tr><tr><td data-num=4></td><td><pre>	call func_B</pre></td></tr><tr><td data-num=5></td><td><pre>	addq <span class="token operator">%</span><span class="token register variable">rbx</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=6></td><td><pre>	<span class="token comment">; ...</span></pre></td></tr><tr><td data-num=7></td><td><pre>	ret</pre></td></tr><tr><td data-num=8></td><td><pre>	</pre></td></tr><tr><td data-num=9></td><td><pre><span class="token label function">func_B:</span></pre></td></tr><tr><td data-num=10></td><td><pre>	<span class="token comment">; ...</span></pre></td></tr><tr><td data-num=11></td><td><pre>	addq <span class="token number">$456</span> <span class="token operator">%</span><span class="token register variable">rbx</span></pre></td></tr><tr><td data-num=12></td><td><pre>	<span class="token comment">; ...</span></pre></td></tr><tr><td data-num=13></td><td><pre>	ret</pre></td></tr></table></figure><p>例如上面的例子，函数A中调用了函数B，因此，函数A称为<strong>调用者</strong>(caller)，函数B称为<strong>被调用者</strong>(callee)。按逻辑而言，寄存器rbx的内容在调用函数B的前后应该保持一致。达到这个目的有两个策略，一个是函数A在调用函数B之前，提前保存寄存器rbx的内容。执行完函数B之后，再恢复寄存器rbx原来存储的内容，这个策略被称为<strong>调用者保存</strong>；另外一个策略是函数B在使用寄存器rbx之前，先保存寄存器rbx的值，在函数B返回之前，先恢复寄存器rbx原来存储的内容，这种策略被称为<strong>被调用者保存</strong>。不同寄存器被定义时使用了不同的策略，此处的寄存器rbx被定义为被调用者保存寄存器，因此，pushq就是用来保存寄存器rbx的内容。在函数返回之前，使用了pop指令来恢复寄存器rbx的内容。</p><hr><p><code>movq %rdx,%rbx</code>汇编代码的含义是将寄存器rdx的内容复制到寄存器rbx。根据寄存器用法的定义，函数multstore的三个参数分别保存在，寄存器rdi，rsi和rdx中，这条指令执行结束后，寄存器rbx与寄存器rdx的内容一致，都是dest指针所指向的内存地址。mov指令的后缀<code>q</code>表示数据的大小，由于早期的机器是16位的，后来才扩展到32位，因此Intel用字(word)来表示16位的数据类型，所以，32位的数据类型称为双字，64位的数据类型称为四字，下图的表格给出了C语言基本类型对应的汇编后缀表示。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part1/8.webp alt=""></p><p>需要特别注意<code>Assembly-code suffix</code>这一列，大多数GCC生成的汇编指令都有一个字符后缀来表示操作数的大小，例如<strong>数据传送指令</strong>就有四个变种，分别为</p><ul><li><code>movb</code> - 是<code>move byte</code>的缩写，表示传送字节</li><li><code>movw</code> - 是<code>move word</code>的缩写，表示传送字</li><li><code>movl</code> - 是<code>move long word</code>的缩写，表示传送双字</li><li><code>movq</code> - 是<code>move quad word</code>的缩写，表示传送四字</li></ul><p><code>call mult2</code>中call指令对应于C代码中的函数调用，该函数的返回值会保存到寄存器rax中，故寄存器rax中保存了x和y的乘积结果。</p><p><code>movq %rax,(%rbx)</code>，该指令将寄存器rax的值送入到内存中，内存的地址就存放在寄存器rbx中。</p><p>最后一条指令<code>ret</code>就是函数返回。</p><p>执行命令<code>gcc -Og -c mstore.c</code>后即可生成<code>mstroe.c</code>对应的机器代码文件<code>mstore.o</code>，由于该文件是二进制格式，因此无法直接查看，但可以借助<strong>反汇编工具</strong>(objdump)查看。汇编器将汇编代码翻译成二进制的机器代码，而反汇编器就是机器代码翻译成汇编代码。通过命令<code>objdump -d mstore.o</code>即可查看<code>mstore.o</code>中的相关信息。反汇编得到的代码与编译器直接产生的汇编代码会有略微的差异，反汇编代码省略了很多指令后缀的<code>q</code>，但在call和ret指令后添加后缀<code>q</code>，由于q只是表示大小指示符，大多数情况下可以省略。</p><h3 id=寄存器与数据传送指令><a class=anchor href=#寄存器与数据传送指令>#</a> 寄存器与数据传送指令</h3><p>最早在8086的处理器中，包含8个16位的通用寄存器，每个寄存器都有特殊的功能，它们的名字反映了各自的用途，当处理器从16位扩展到32位时，寄存器的位数也扩展到了32位。如今的64位处理器中，原来8个16位寄存器已经扩展成64位了，还增加了8个新的寄存器。在一般的程序中，不同寄存器扮演着不同的角色，相应的编程规范规定了如何使用这些寄存器，例如寄存器rax用来保存函数的返回值，寄存器rsp用来保存程序栈的结束位置，此外，还有6个寄存器用来传递函数参数。</p><p>对于<strong>指令</strong>，大多数指令包含两部分，<strong>操作码</strong>(Operation code)和<strong>操作数</strong>(Operands)，例如<code>movq</code>，<code>addq</code>，<code>subq</code>被定义为操作码，用于决定CPU执行操作的类型，操作码之后的这部分是操作数，大多数指令具有一个或多个操作数，不过像ret返回指令，是没有操作数的。不同指令的操作数大致可分为三类，分别为</p><hr><p><font size=3><ins><strong>立即数(Immediate)</strong></ins></font></p><p>在<code>AT&amp;T</code>格式的汇编中，立即数是以<code>$</code>符号开头的，后面跟一个整数，这个整数需要满足标准C语言的定义。</p><p><font size=3><ins><strong>寄存器(Register)</strong></ins></font></p><p>操作数是寄存器的情况比较容易理解，即使在64位的处理器上，不仅64位的寄存器可以作为操作数，32位，16位甚至是8位的寄存器都可以作为操作数。</p><p><font size=3><ins><strong>内存引用(Memory Reference)</strong></ins></font></p><p>寄存器<strong>带小括号</strong>的表示为内存引用的情况，通常将内存抽象成一个字节数组，当需要从内存中存取数据时，需要获得目的数据的起始地址addr，以及数据长度b。最常用的内存引用包含四个部分，分别为一个立即数，一个基址寄存器(Base Register)，一个变址寄存器(Index Register)，一个比例因子(Scale Factor)。</p><p>引用数组元素时，会使用到这种通用的形式，有效地址是通过立即数与基址寄存器的值相加，再加上变址寄存器与比例因子的乘积得到的。比例因子的取值必须是1，2，4或8，比例因子的取值是与源代码中定义的数组类型是相关的，编译器会根据数组的类型来确定比例因子的数值，例如定义char类型的数组，比例因子就是1；int类型，比例因子就是4；double类型比例因子就是8。</p><p>其他形式的内存引用都是这种普通形式的变种，需要注意的是，不带<code>$</code>符号的立即数和带了括号的寄存器。</p><hr><p><font size=3><ins><strong>mov类指令</strong></ins></font></p><p>包含<code>movb</code>(Move byte(1 Byte))，<code>movw</code>(Move word(2 Byte))，<code>movl</code>(Move double word(4 Byte))，<code>movq</code>(Move quad word(8 Byte))这四条指令，这些指令执行相同的操作，都是把数据从源位置复制到目的位置，主要区别在于它们操作的数据大小不同。</p><p>对于mov类指令，包含两个操作数，分别为</p><ul><li><strong>源操作数</strong>(Source operand) - 可以是一个立即数，一个寄存器或是内存引用</li><li><strong>目的操作数</strong>(Destination operand) - 用于存放源操作数的内容，其要么是一个寄存器，要么是一个内存引用，但不能是一个立即数。此外，<code>x86-64</code>处理器有一条限制，mov指令的源操作数和目的操作数不能同时是内存的地址</li></ul><p>当需要将一个数从内存的一个位置复制到另一个位置时，需要两条mov指令来完成，第一条指令<code>mov memory,register</code>将内存源位置的数值加载到寄存器，第二条指令<code>mov register,memory</code>将该寄存器的值写入内存的目的位置。</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"><span>mov指令例子</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">; Immediate → Register</span></pre></td></tr><tr><td data-num=2></td><td><pre>movl <span class="token operator">$</span><span class="token number">0x4050</span>, <span class="token operator">%</span><span class="token register variable">eax</span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment">; Register → Register</span></pre></td></tr><tr><td data-num=5></td><td><pre>movw <span class="token operator">%</span><span class="token register variable">bp</span>, <span class="token operator">%</span><span class="token register variable">sp</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token comment">; Memory → Register</span></pre></td></tr><tr><td data-num=8></td><td><pre>movb (<span class="token operator">%</span><span class="token register variable">rdi</span>,<span class="token operator">%</span><span class="token register variable">rcx</span>), <span class="token operator">%</span><span class="token register variable">al</span></pre></td></tr><tr><td data-num=9></td><td><pre></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token comment">; Immediate → Memory</span></pre></td></tr><tr><td data-num=11></td><td><pre>movb <span class="token operator">$</span><span class="token operator">-</span><span class="token number">17</span>, (<span class="token operator">%</span><span class="token register variable">rsp</span>)</pre></td></tr><tr><td data-num=12></td><td><pre></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token comment">; Register → Memory</span></pre></td></tr><tr><td data-num=14></td><td><pre>movq <span class="token operator">%</span><span class="token register variable">rax</span>, <span class="token operator">-</span><span class="token number">12</span>(<span class="token operator">%</span><span class="token register variable">rbp</span>)</pre></td></tr><tr><td data-num=15></td><td><pre></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token comment">; 给出了不同类型的源操作数和目的操作数的组合，第一个是源操作数，第二个是目的操作数。</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token comment">; mov指令的后缀与寄存器的大小一定得是匹配的，</span></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token comment">; 例如寄存器eax是32位，与双字`l`对应；寄存器al是8位，与字节b对应。</span></pre></td></tr></table></figure><p>此外，mov指令还有几个特殊的情况，当movq指令的源操作数是立即数时，该立即数只能是32位的补码表示，然后对该数值进行符号扩展之后，将得到的64位数传送到目的位置。这个限制会带来一个问题，当立即数是64位时，这里引入了一个新的指令<code>movabsq</code>，该指令的源操作数可以是任意的64位的立即数，目的操作数只能是寄存器。</p><p>使用mov指令进行数据传送时，对目的寄存器的修改结果会是怎样的？首先使用<code>movabsq $0x0011223344556677, %rax</code>指令将一个64位立即数复制到寄存器rax中，此时寄存器内保存的数值为<code>rax[00,11,22,33,44,55,66,77]</code>。接下来使用movb指令将立即数<code>-1</code>复制到寄存器al中，寄存器al的长度为8，与movb指令所操作的数据大小一致，此时寄存器rax的低8位发生了改变<code>rax[00,11,22,33,44,55,66,FF]</code>。接着第三条movw指令将立即数<code>-1</code>复制到寄存器ax，此时寄存器rax的低16位发生了变化<code>rax[00,11,22,33,44,55,FF,FF]</code>。接着movl指令将立即数<code>-1</code>复制到寄存器eax时，此时寄存器rax不仅是低32位发生变化，而且高32位也发生了变化<code>rax[00,00,00,00,FF,FF,FF,FF]</code>，当movl的目的操作数是寄存器时，会把该寄存器的高4字节设置为0，这是<code>x86-64</code>处理器的一个规定，即任何寄存器生成32位值的指令都会把该寄存器得高位部分置为0，以上情况都是源操作数与目的操作数得大小一致得情况。</p><p>当源操作数的数位小于目的操作数时，需要对目的操作数剩余的字节进行零扩展或符号位扩展。零扩展数据传送指令有5条，<code>movzbw</code>，<code>movzbl</code>，<code>movzwl</code>，<code>movzbq</code>，<code>movzwq</code>，其中字符z是zero的缩写，指令最后两个字符都是大小指示符，第一个字母表示源操作数得大小，第二个字母表示目的操作数得大小。符号位扩展传送指令有6条，<code>movsbw</code>，<code>movsbl</code>，<code>movswl</code>，<code>movsbq</code>，<code>movswq</code>，<code>movslq</code>，其中字符s是sign的缩写，同样指令最后的两个字符也是大小指示符。符号扩展比零扩展多一条4字节到8字节的扩展指令。由于<code>movzlq</code>指令的数据传送可以通过<code>movl</code>指令来实现，因此没有必要多一条<code>movzlq</code>指令。此外，符号位扩展还有一条没有操作数的特殊指令<code>cltq</code>，该指令的源操作数总是寄存器eax，目的操作数总是寄存器rax。<code>cltq</code>指令与<code>movslq %eax,%rax</code>指令效果一致，只是编码更紧凑。</p><h3 id=栈与数据传送指令><a class=anchor href=#栈与数据传送指令>#</a> 栈与数据传送指令</h3><p>程序加载过程中，最初，可执行文件是保存在硬盘上，通过shell程序可将执行程序从硬盘加载到内存，此时，程序指令以及数据都保存在内存中，当CPU要执行程序时，需要从内存中读取指令和数据。实际上，在一些程序的执行过程中，需要在CPU和内存之间进行频繁的数据存取。例如CPU执行一个简单的加法操作<code>c=a+b</code>，首先通过CPU执行数据传送指令将a和b的值从内存读到寄存器内，寄存器就是CPU内一种容量比较小的数据存储部件，以<code>x86-64</code>位处理器为例，寄存器rax的大小是64个比特位，即8个字节。如果变量a是long类型，需要占用8个字节，那么寄存器rax全部的数据位都用来保存变量a；如果变量a是int类型，那么只需要4个字节来存储该变量，那么只需要用到寄存器的低32位就够了；如果变量a是short类型，则只需要用到寄存器的低16位。对于寄存器rax，如果使用全部的64位，用符号<code>%rax</code>来表示，如果只用到低32位，用符号<code>%eax</code>来表示，对于低16位和低8位的，分别用<code>%ax</code>和<code>%al</code>来表示。虽然用了不同的表示符号，但实际上只是对同一寄存器的不同数位进行操作，处理器完成加法运算之后，再通过一条数据传送指令将计算结果保存到内存。以下为一个数据传送的代码示例</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">long</span> <span class="token function">exchange</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token operator">*</span> xp<span class="token punctuation">,</span><span class="token keyword">long</span> y<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> x <span class="token operator">=</span> <span class="token operator">*</span>xp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token operator">*</span>xp <span class="token operator">=</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">return</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=7></td><td><pre></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">long</span> a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token keyword">long</span> b <span class="token operator">=</span> <span class="token function">exchange</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%ld,b=%ld\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">exchange:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	movq (<span class="token operator">%</span><span class="token register variable">rdi</span>),<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=3></td><td><pre>	movq <span class="token operator">%</span><span class="token register variable">rsi</span>,(<span class="token operator">%</span><span class="token register variable">rdi</span>)</pre></td></tr><tr><td data-num=4></td><td><pre>	ret</pre></td></tr></table></figure><p>函数<code>exchange</code>由三条指令实现，包括两条数据传送指令和一条返回指令。根据寄存器的使用惯例，寄存器rdi和rsi分别用来保存函数传递的第一个参数和第二个参数，因此，寄存器rdi中保存了xp的值，寄存器rsi保存了变量y的值，汇编代码中并没有将以上部分显示出来。</p><p>第一条mov指令从内存中读取数值到寄存器，内存地址保存在寄存器rdi中，目的操作数是寄存器rax。<code>long x = *xp</code>对应于<code>movq (%rdi),%rax</code>，由于最后函数exchange需要返回变量x的值，这里将变量x放到寄存器rax中。</p><p>第二条mov指令将变量y的值写入内存中，变量y存储在寄存器rsi中，内存地址保存在寄存器rdi中，即xp指向的内存位置。<code>*xp = y</code>对应于<code>movq %rsi,(%rdi)</code>。</p><p>通过这个例子可以看到，C语言中的指针就是地址。</p><p>还有两个数据传送指令需要借助程序栈，栈是一种数据结构，通过push操作把数据压入栈，通过pop操作删除数据，栈具有一个特性，就是弹出的数据永远是最近被压入且仍然在栈中的。程序栈本质是一个内存中的一个区域，栈的增长方向是从高地址到低地址，因此，栈顶的元素是所有栈中元素地址中最低的。</p><p>根据惯例，栈是倒过来画的，栈顶在底部，栈底在顶部。例如需要保存寄存器rax内存中存储的数据<code>0x123</code>，可以使用<code>pushq</code>指令把数据压入栈内，该指令的执行过程可以分解为两步，首先指向栈顶的寄存器的rsp进行一个减法操作，例如，压栈之前，栈顶指针rsp指向栈顶的位置，此处的内存地址<code>0x108</code>，压栈的第一步就是寄存器rsp的值减8，此时指向的内存地址是<code>0x100</code>，然后将需要保存的数据复制到新的栈顶地址。此时，内存地址<code>0x100</code>处将保存寄存器rax内中存储的数据<code>0x123</code>，实际上pushq的指令等效于<code>subq $8,%rsp</code>与<code>movq %rax,(%rsp)</code>这两条指令，这两条指令与pushq指令的区别在于pushq这一条指令只需要一个字节，而这两条指令需要8个字节。</p><p>push指令的本质还是将数据写入到内存中，与之对应的pop指令就是从内存中读取数据，并且修改栈顶指针。例如<code>popq %rbx</code>指令，就是将栈顶保存的数据复制到寄存器rbx中，pop指令的操作也可以分解为两步，首先从栈顶的位置读出数据，复制到寄存器rbx，此时，栈顶指针rsp指向的内存地址是<code>0x100</code>，然后将栈顶指针加8，pop后栈顶指针rsp指向的内存地址是<code>0x108</code>，因此pop操作等效于<code>movq (%rsp),%rbx</code>和<code>addq $8,%rsp</code>这两条指令，实际上pop指令是通过修改栈顶指针所指向的内存地址来实现数据删除的。此时内存地址<code>0x100</code>内所保存的数据<code>0x123</code>仍存在，直到下次push操作，此处保存的数值才会被覆盖。</p><h3 id=算术和逻辑操作指令><a class=anchor href=#算术和逻辑操作指令>#</a> 算术和逻辑操作指令</h3><p><code>leaq S,D</code>指令，它实现的功能是加载有效地址，<code>q</code>表示地址的长度是四个字，由于<code>x86-64</code>位处理器上，地址长度都是64位，因此不存在<code>leab</code>，<code>leaw</code>这类有关大小的变种。例如<code>leaq 7(%rdx,%rdx,4),%rax</code>这条指令，它表示把有效地址复制到寄存器rax中，对于leaq指令所执行的操作并不是去内存地址处读取数据，而是将有效地址这个值直接写入到目的寄存器rax。除了加载有效地址的功能外，leaq指令还可以用来表示加法和有限的乘法运算。例如，以下例子</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">long</span> <span class="token function">scale</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span><span class="token keyword">long</span> y<span class="token punctuation">,</span><span class="token keyword">long</span> z<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> t <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">*</span> y <span class="token operator">+</span> <span class="token number">12</span> <span class="token operator">*</span> z<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">return</span> t<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">scale:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	leaq (<span class="token operator">%</span><span class="token register variable">rdi</span>,<span class="token operator">%</span><span class="token register variable">rsi</span>,<span class="token number">4</span>),<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=3></td><td><pre>	leaq (<span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token number">2</span>),<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=4></td><td><pre>	leaq (<span class="token operator">%</span><span class="token register variable">rax</span>,<span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token number">4</span>),<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=5></td><td><pre>	ret</pre></td></tr></table></figure><p>根据寄存器的使用惯例，参数x，y，z分别保存在寄存器rdi，rsi，rdx中。由于比例因子取值只能是1，2，4，8这四个数中的一个，因此不能使用<code>leaq (%rax,%rdx,12),%rax</code>指令来一步完成。</p><p><strong>一元操作指令(Unary Operations)</strong> - 一组指令只有一个操作数，因此该操作数既是源操作数也是目的操作数，操作数可以是寄存器，也可以是内存地址。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part1/9.webp alt=""></p><p><strong>二元操作指令(Binary Operations)</strong> - 一组指令包含两个操作数，第一个操作数是源操作数，这个操作数可以是立即数，寄存器或内存地址。第二个操作数既是源操作数也是目的操作数，这个操作数可以是寄存器或内存地址，但不能是立即数。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part1/10.webp alt=""></p><p>例子，一开始，内存以及寄存器中保存的数据如下，</p><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>0x100  0x108  0x110  0x118</pre></td></tr><tr><td data-num=2></td><td><pre>|______|______|______|______|__</pre></td></tr><tr><td data-num=3></td><td><pre>|0xff  |oxAB  |0x13  |0x11  |</pre></td></tr><tr><td data-num=4></td><td><pre>|——————|———---|------|------|--</pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment">%rax ← 0x100</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token comment">%rcx ← 0x1</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token comment">%rdx ← 0x3</span></pre></td></tr></table></figure><p><code>addq %rcx,(%rax)</code> - <strong>加法指令</strong>将内存地址<code>0x100</code>内的数据与寄存器rcx相加，二者之和再存储到内存地址<code>0x100</code>处，该指令执行完后，内存地址<code>0x100</code>处所存储的数据由<code>0xFF</code>变成<code>0x100</code>。</p><p><code>subq %rdx,8(%rax)</code> - <strong>减法指令</strong>将内存地址<code>0x108</code>内的数据减去寄存器rdx内的数据，二者之差存储到内存地址<code>0x108</code>处，该指令执行完毕后，内存地址所存储数据由<code>0xAB</code>变成<code>0xA8</code>。</p><p><code>incq 16(%rax)</code> - <strong>加一指令</strong>将内存地址<code>0x110</code>内存储的数据加1，结果是内存地址<code>0x110</code>处所存储的数据由<code>0x13</code>变为<code>0x14</code>。</p><p><code>subq %rdx,%rax</code> - <strong>减法指令</strong>将寄存器rax内的值减去寄存器rdx内的值，最终寄存器rax的值由<code>0x100</code>变成<code>0xFD</code>。</p><p><font size=3><ins><strong>移位操作(Shift Operations)</strong></ins></font></p><p>左移指令有SAL和AHL，二者的效果都是一样的，都是在右边填零。</p><p>右移指令分为算术右移(Arithmetic right shift)和逻辑右移(Logical right shift)，算术右移需要填符号位，逻辑右移需要填零。</p><p>对于移位量(Shift Amount)，可以是一个立即数，或是放在寄存器cl中的数，对于移位指令只允许以特定的寄存器cl作为操作数。由于寄存器cl的长度为8，原则上移位量的编码范围可达<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><msup><mn>2</mn><mn>8</mn></msup><mo>−</mo><mn>1</mn></mstyle></mrow><annotation encoding=application/x-tex>\small 2^8 - 1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.788361em;vertical-align:-.07499700000000001em></span><span class="mord sizing reset-size6 size5"><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.7926266666666666em><span style=top:-2.963em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">−</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">1</span></span></span></span>(255)，实际上，对于w位的操作数进行移位操作，移位量是由寄存器cl的低m位来决定，即对于指令<code>salb</code>，当前目的操作数是8位，移位量由寄存器cl的低3位来决定；对于指令<code>salw</code>，移位量则由寄存器cl的低4位来决定，以此类推，双字对应的是低5位，四字对应的是低6位。</p><p>移位指令的用途，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">long</span> <span class="token function">arith</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span><span class="token keyword">long</span> y<span class="token punctuation">,</span><span class="token keyword">long</span> z<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> t1 <span class="token operator">=</span> x<span class="token operator">^</span>y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">long</span> t2 <span class="token operator">=</span> z <span class="token operator">*</span> <span class="token number">48</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">long</span> t3 <span class="token operator">=</span> t1 <span class="token operator">&amp;</span> <span class="token number">0</span>xOFOFOFOF<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">long</span> t4 <span class="token operator">=</span> t2 <span class="token operator">-</span> t3<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">return</span> t4<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">arith:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	xorq (<span class="token operator">%</span><span class="token register variable">rsi</span>),<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=3></td><td><pre>	leaq (<span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token number">2</span>),<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=4></td><td><pre>	salq <span class="token number">$4</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=5></td><td><pre>	andl <span class="token number">$252645135</span>,<span class="token operator">%</span><span class="token register variable">edi</span></pre></td></tr><tr><td data-num=6></td><td><pre>	subq <span class="token operator">%</span><span class="token register variable">rdi</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=7></td><td><pre>	ret</pre></td></tr></table></figure><p><code>long t2 = z * 48</code>被分解为<code>leaq (%rdx,%rdx,2),%rax</code>与<code>salq $4,%rax</code>，第一步，首先计算<code>3 * z</code>由指令leaq来实现，计算结果保存到寄存器rax。第二步，将寄存器rax进行左移4位，左移4位的操作等效于乘以2的4次方，即乘以16，通过一条leaq指令和一条左移指令，来实现乘法操作。由于乘法指令的执行时间需要更长的时间，故编译器不使用乘法指令来实现运算，编译器在生成汇编指令时，会优先考虑更高效的方式。</p><h3 id=指令与条件码><a class=anchor href=#指令与条件码>#</a> 指令与条件码</h3><p>算术逻辑单元，简称ALU，ALU从寄存器中读取数据后，执行相应的运算，然后将相应的结果返回到目的寄存器rdx中。ALU除了执行算术和逻辑运算指令外，还会根据该运算的结果去设置条件码寄存器(Condition Code Register)。</p><p><font size=3><ins><strong>条件码寄存器</strong></ins></font></p><p>条件码寄存器是由CPU来维护的，长度是单个比特位，描述了最近执行操作的属性，例如ALU执行两条连续的算术指令，t1时刻执行指令1<code>addq %rax,%rbx</code>，t2时刻执行指令2<code>subq %rcx,%rdx</code>，t1时刻条件码寄存器中保存的是指令1的执行结果的属性，t2时刻条件寄存器中的内容将被下一条指令所覆盖。</p><p><font size=3><ins><strong>常用的条件码寄存器</strong></ins></font></p><p><strong>CF</strong>(Carry Flag) - 进位标志，当CPU最近执行的一条指令的最高位产生了进位时，进位标志会被设置为1，它可以用来检测无符号数操作的溢出，例如无符号数a和b相加，当a等于255，b=1时，由于最高位会发生进位操作，相加的结果发生溢出，此时进位标志被设置为1。</p><p><strong>ZF</strong>(Zero Flag) - 零标志，当最近操作的结果等于零时，零标志会被设置为1， 例如int类型的a的值为1，int类型的b值为<code>-1</code>，两者相加后置于int类型中，结果为0，此时零标志会被设置为1。</p><p><strong>SF</strong>(Sign Flag) - 符号标志，当最近的操作结果小于零时，符号标志会被设置为1。</p><p><strong>OF</strong>(Overflow Flag) - 溢出标志，针对有符号数，当最近的操作导致正溢出或负溢出时，溢出标志会被设置为1。</p><p>条件码寄存器的值是由ALU在执行算术和运算指令时写入的，对于不同的指令也定义了相应的规则来设置条件码寄存器，例如逻辑操作指令xor，进位标志和溢出标志会被设置为0；对于加一指令和减一指令会设置溢出标志和零标志，但不会改变进位标志。</p><p>除以上外，还有两类指令(<strong>cmp指令</strong>和<strong>test指令</strong>)可以设置条件码寄存器，<code>cmpq %rax,%rdx</code>与<code>testq %rax,%rdx</code>指令，cmp指令是根据两个操作数的差来设置条件码和寄存器，cmp指令和减法指令sub类似，也是根据两个操作数的差来设置条件码，二者不同的是cmp指令只是设置条件码寄存器并不会更新目的寄存器的值。test指令和and指令类似，同样test指令只是设置条件码寄存器而不改变目的寄存器的值。</p><p><font size=3><ins><strong>条件码的使用</strong></ins></font></p><p><strong>简单例子</strong></p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">comp</span><span class="token punctuation">(</span><span class="token keyword">long</span> a<span class="token punctuation">,</span><span class="token keyword">long</span> b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">comp:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	comq <span class="token operator">%</span><span class="token register variable">rsi</span>,<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=3></td><td><pre>	sete <span class="token operator">%</span><span class="token register variable">al</span></pre></td></tr><tr><td data-num=4></td><td><pre>	movzbl <span class="token operator">%</span><span class="token register variable">al</span>,<span class="token operator">%</span><span class="token register variable">eax</span></pre></td></tr><tr><td data-num=5></td><td><pre>	ret</pre></td></tr></table></figure><p>此代码的含义是比较a和b的大小，当a等于b时，函数返回1，否则返回0。</p><p>根据寄存器使用的惯例，参数a存放在寄存器rdi中，参数b存放在寄存器rsi中。</p><p>指令cmp对应的操作<code>comq %rsi,%rdi</code>，根据<code>a-b</code>结果设置条件码寄存器，当a和b的值相等时，指令cmp会将零标志位设置为1。</p><p><code>set %al</code>指令，通常情况下，并不会直接去读条件码寄存器，其中一种方式是根据条件码的某种组合，通过set类指令，将一个字节设置为0或1。这个例子中，指令sete根据零标志的值对寄存器al进行赋值，后缀e是<code>equal</code>的缩写。如果零标志等于1，指令sete将寄存器al寄存器al设置为1；如果零标志等于0，指令sete将寄存器al设置为0，然后mov指令对寄存器al进行零扩展，最后返回判断结果。</p><p><strong>复杂例子</strong></p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">comp</span><span class="token punctuation">(</span><span class="token keyword">char</span> a<span class="token punctuation">,</span><span class="token keyword">char</span> b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">return</span> a <span class="token operator">&lt;</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">comp:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	comb <span class="token operator">%</span>sil,<span class="token operator">%</span>dil</pre></td></tr><tr><td data-num=3></td><td><pre>	setl <span class="token operator">%</span><span class="token register variable">al</span></pre></td></tr><tr><td data-num=4></td><td><pre>	movzbl <span class="token operator">%</span><span class="token register variable">al</span>,<span class="token operator">%</span><span class="token register variable">eax</span></pre></td></tr><tr><td data-num=5></td><td><pre>	ret</pre></td></tr></table></figure><p>判断条件由a等于b变成了a小于b，经过编译器生成的汇编指令也发生了变化。</p><p>对比之前相等的情况，可以发现指令sete变成了指令setl，指令setl的含义是如果a小于b，将寄存器al设置为1，其中后缀<code>l</code>是less的缩写，表示<code>在小于时设置</code>，而不是表示大小的<code>long word</code>。</p><p>相对于相等的情况，判断小于的情况要稍微复杂一点，需要根据符号标志和溢出标志的异或结果来判定。例如，两个有符号数相减，当没有发生溢出时，如果a小于b，结果为负数，那么符号标志被设置为1；如果a大于b，结果为正数，那么符号标志就不会被设置为1。当a等于<code>-2</code>，b等于127时，由于发生负溢出，结果127大于0，此时符号标志不会被设置为1，但溢出标志会被设置为1，因此仅仅根据符号标志是无法判断a是否小于b；当a等于1，b等于<code>-128</code>，由于发生了正溢出，结果<code>-127</code>，虽然a大于b，但是由于溢出导致了结果小于0，此时符号标志和溢出标志都会被设置为1。综上所述，根据符号标志和溢出标志的异或结果，可以对a小于b是否为真做出判断；对于其他的判断情况，都可以通过条件码的组合来实现。</p><p>对于无符号数的比较情况，指令cmp会设置进位标志，进而针对无符号数的比较，采用的是进位标志和零标志的组合。</p><h3 id=跳转指令与循环><a class=anchor href=#跳转指令与循环>#</a> 跳转指令与循环</h3><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">long</span> <span class="token function">absdiff_se</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span><span class="token keyword">long</span> y<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">&lt;</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> result <span class="token operator">=</span> y <span class="token operator">-</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">else</span><span class="token punctuation">&#123;</span> result <span class="token operator">=</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">absdiff_se:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	cmpq <span class="token operator">%</span><span class="token register variable">rsi</span>,<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=3></td><td><pre>	jl .L4</pre></td></tr><tr><td data-num=4></td><td><pre>	movq <span class="token operator">%</span><span class="token register variable">rdi</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=5></td><td><pre>	subq <span class="token operator">%</span><span class="token register variable">rsi</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token label function">.L4:</span></pre></td></tr><tr><td data-num=7></td><td><pre>	movq <span class="token operator">%</span><span class="token register variable">rsi</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=8></td><td><pre>	subq <span class="token operator">%</span><span class="token register variable">rdi</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=9></td><td><pre>	ret</pre></td></tr></table></figure><p>上例这个函数用来计算两数之差的绝对值，条件语句x小于y由指令cmp来实现，指令cmp会根据<code>(x-y)</code>的结果来设置符号标志和溢出标志，跳转指令<code>jl</code>会根据符号标志和溢出标志的异或结果来判断究竟是顺序执行还是跳转到L4处执行。当x大于y时，指令顺序执行，然后返回执行结果，L4处的指令不会被执行，当x小于y时，程序跳转到L4处执行，然后返回执行结果。跳转指令会根据寄存器的某种组合来决定是否进行跳转，与set指令的设置条件是一样的。</p><p>对于<code>if-else</code>语义，当满足条件时，程序沿着一条执行路径执行。当不满足条件时，就走另外一条路径。这种机制在现代处理器上的执行效率可能会比较低。针对这种情况有一种代替的策略，就是使用数据的条件转移来代替控制的条件转移。</p><p>还是针对这两个数差的绝对值问题，以下为另外一种实现方式</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">long</span> <span class="token function">cmovdiff_se</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span><span class="token keyword">long</span> y<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> rval <span class="token operator">=</span> y <span class="token operator">-</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">long</span> eval <span class="token operator">=</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">long</span> ntest <span class="token operator">=</span> <span class="token punctuation">(</span> x <span class="token operator">>=</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>ntest<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> rval <span class="token operator">=</span> eval<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    </pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">return</span> rval<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">cmovdiff_se:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	movq <span class="token operator">%</span><span class="token register variable">rsi</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=3></td><td><pre>	subq <span class="token operator">%</span><span class="token register variable">rdi</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=4></td><td><pre>	movq <span class="token operator">%</span><span class="token register variable">rdi</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=5></td><td><pre>	subq <span class="token operator">%</span><span class="token register variable">rsi</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=6></td><td><pre>	cmpq <span class="token operator">%</span><span class="token register variable">rsi</span>,<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=7></td><td><pre>	cmovge <span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=8></td><td><pre>	ret</pre></td></tr></table></figure><p>这里既要计算<code>y-x</code>的值，也计算<code>x-y</code>的值，分别用两个变量来记录结果，然后再判断x与y的大小，根据测试情况来判断是否更新返回值。</p><p>这种写法的执行效率高，汇编源码中前面几条指令都是普通的数据传送和减法操作。<code>cmovge %rdx,%rax</code>指令是根据条件码的某种组合来进行有条件的传送数据。当满足规定的条件时，将寄存器rdx内的数据复制到寄存器rax内，在这个例子中，只有当x大于等于y时，才会执行这一条指令。</p><p>基于条件传送的代码会比基于跳转指令的代码效率高，这涉及到现代处理器通过流水线来获得高性能的知识。当遇到条件跳转指令时，处理器会根据分支预测器来猜测每条跳转指令是否执行。当发生错误预测时，会浪费大量的时间，导致程序性能严重下降。</p><p>C语言中提供了<code>do-while</code>，<code>while</code>以及<code>for</code>语句三种循环结构，汇编语言中没有定义专门的指令来实现循环结构，循环语句是通过条件测试与跳转的结合来实现的。</p><p>以实现N的阶乘为例</p><figure class="highlight c"><figcaption data-lang=c><span>do-while</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">long</span> <span class="token function">fact_do</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">do</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>        result <span class="token operator">*=</span> n<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>        n <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token keyword">return</span> result</pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">fact_do:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	movl <span class="token number">$1</span>,<span class="token operator">%</span><span class="token register variable">eax</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token label function">.L2:</span></pre></td></tr><tr><td data-num=4></td><td><pre>	imulq <span class="token operator">%</span><span class="token register variable">rdi</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=5></td><td><pre>	subq <span class="token number">$1</span>,<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=6></td><td><pre>	cmpq <span class="token number">$1</span>,<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=7></td><td><pre>	jg .L2</pre></td></tr><tr><td data-num=8></td><td><pre>	rep ret</pre></td></tr></table></figure><p>指令cmp与跳转指令的组合实现了循环操作，当n大于1时，跳转到L2处执行循环。直到n的值减少到1，循环结束。</p><figure class="highlight c"><figcaption data-lang=c><span>while</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">long</span> <span class="token function">fact_while</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>        result <span class="token operator">*=</span> n<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>        n <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">fact_while:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	mov1 <span class="token number">$1</span>,<span class="token operator">%</span><span class="token register variable">eax</span></pre></td></tr><tr><td data-num=3></td><td><pre>	movl <span class="token number">$2</span>,<span class="token operator">%</span><span class="token register variable">edx</span></pre></td></tr><tr><td data-num=4></td><td><pre>	jmp .L2</pre></td></tr><tr><td data-num=5></td><td><pre><span class="token label function">.L3:</span></pre></td></tr><tr><td data-num=6></td><td><pre>    imulq <span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=7></td><td><pre>    addq <span class="token number">$1</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token label function">.L2:</span></pre></td></tr><tr><td data-num=9></td><td><pre>    cmp1 <span class="token operator">%</span><span class="token register variable">rdi</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=10></td><td><pre>    jl .L3</pre></td></tr><tr><td data-num=11></td><td><pre>    rep ret</pre></td></tr></table></figure><p>while循环与<code>do-while</code>循环的差别在于N大于1这个测试的位置不同，<code>do-while</code>循环是先执行循环体的内容，然后再进行循环测试，while循环则是先进行循环测试，根据测试结果是否执行循环体内容。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">long</span> <span class="token function">fact_for</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">long</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=6></td><td><pre>        result <span class="token operator">*=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">fact_for:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	mov1 <span class="token number">$1</span>,<span class="token operator">%</span><span class="token register variable">eax</span></pre></td></tr><tr><td data-num=3></td><td><pre>	movl <span class="token number">$2</span>,<span class="token operator">%</span><span class="token register variable">edx</span></pre></td></tr><tr><td data-num=4></td><td><pre>	jmp .L2</pre></td></tr><tr><td data-num=5></td><td><pre><span class="token label function">.L3:</span></pre></td></tr><tr><td data-num=6></td><td><pre>    imulq <span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=7></td><td><pre>    addq <span class="token number">$1</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token label function">.L2:</span></pre></td></tr><tr><td data-num=9></td><td><pre>    cmpq <span class="token operator">%</span><span class="token register variable">rdi</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=10></td><td><pre>    jl3 .L3</pre></td></tr><tr><td data-num=11></td><td><pre>    rep ret</pre></td></tr></table></figure><p>与之前的两者循环的实现方式有较大的差别，将该for循环转换为while循环</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">long</span> <span class="token function">fact_for_while</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">long</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>        result <span class="token operator">*=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>        <span class="token operator">++</span>i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">return</span> reuslt<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">fact_for_while:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	movl <span class="token number">$1</span>,<span class="token operator">%</span><span class="token register variable">eax</span></pre></td></tr><tr><td data-num=3></td><td><pre>	movl <span class="token number">$2</span>,<span class="token operator">%</span><span class="token register variable">edx</span></pre></td></tr><tr><td data-num=4></td><td><pre>	jmp .L2</pre></td></tr><tr><td data-num=5></td><td><pre><span class="token label function">.L3:</span></pre></td></tr><tr><td data-num=6></td><td><pre>    imulq <span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=7></td><td><pre>    addq <span class="token number">$1</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token label function">.L2:</span></pre></td></tr><tr><td data-num=9></td><td><pre>    cmpq <span class="token operator">%</span><span class="token register variable">rdi</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=10></td><td><pre>    jl .L3</pre></td></tr><tr><td data-num=11></td><td><pre>    rep ret</pre></td></tr></table></figure><p>对比<code>fact_for</code>与<code>fact_for_while</code>的汇编代码，发现除了<code>jl3.L3</code>与<code>jl .L3</code>这一跳转指令不同，其他部分都是一致的，需要注意这两个汇编代码是采用<code>-Og</code>选项产生的。</p><p>综上所述，三种形式的循环语句都是通过条件测试和跳转指令来实现的。</p><p>C语言还提供了switch语句，它可以根据一个整数索引值进行多重的分支，在针对一个测试有多种可能的结果时，switch语言特别有用。switch语句通过跳转表这种数据结构使得实现更加高效。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">void</span> <span class="token function">switch_eg</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span><span class="token keyword">long</span> n<span class="token punctuation">,</span><span class="token keyword">long</span><span class="token operator">*</span> dest<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> val <span class="token operator">=</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">switch</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>        <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=7></td><td><pre>            cal <span class="token operator">*=</span> <span class="token number">13</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>            <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>        <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=10></td><td><pre>            val <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>            <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>        <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=13></td><td><pre>            val <span class="token operator">+=</span> <span class="token number">11</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre>            <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre>        <span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=16></td><td><pre>        <span class="token keyword">case</span> <span class="token number">6</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=17></td><td><pre>            val <span class="token operator">+=</span> <span class="token number">11</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=18></td><td><pre>            <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=19></td><td><pre>        <span class="token keyword">default</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=20></td><td><pre>            val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=21></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=22></td><td><pre>    <span class="token operator">*</span>dest <span class="token operator">=</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">switch_eg:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	cmpq <span class="token number">$6</span>,<span class="token operator">%</span><span class="token register variable">rsi</span></pre></td></tr><tr><td data-num=3></td><td><pre>	ja .L8</pre></td></tr><tr><td data-num=4></td><td><pre>	leaq .L4(<span class="token operator">%</span>rip),<span class="token operator">%</span><span class="token register variable">rcx</span></pre></td></tr><tr><td data-num=5></td><td><pre>	movslq (<span class="token operator">%</span><span class="token register variable">rcx</span>,<span class="token operator">%</span><span class="token register variable">rsi</span>,<span class="token number">4</span>),<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=6></td><td><pre>	addq <span class="token operator">%</span><span class="token register variable">rcx</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=7></td><td><pre>	jmp <span class="token operator">*</span><span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token label function">.L4:</span></pre></td></tr><tr><td data-num=9></td><td><pre>	<span class="token label function">.long:</span> .L3<span class="token operator">-</span>.L4 # case <span class="token number">0</span></pre></td></tr><tr><td data-num=10></td><td><pre>	<span class="token label function">.long:</span> .L8<span class="token operator">-</span>.L4 # case <span class="token number">1</span></pre></td></tr><tr><td data-num=11></td><td><pre>	<span class="token label function">.long:</span> .L5<span class="token operator">-</span>.L4 # case <span class="token number">2</span></pre></td></tr><tr><td data-num=12></td><td><pre>	<span class="token label function">.long:</span> .L6<span class="token operator">-</span>.L4 # case <span class="token number">3</span></pre></td></tr><tr><td data-num=13></td><td><pre>	<span class="token label function">.long:</span> .L7<span class="token operator">-</span>.L4 # case <span class="token number">4</span></pre></td></tr><tr><td data-num=14></td><td><pre>	<span class="token label function">.long:</span> .L8<span class="token operator">-</span>.L4 # case <span class="token number">5</span></pre></td></tr><tr><td data-num=15></td><td><pre>	<span class="token label function">.long:</span> .L7<span class="token operator">-</span>.L4 # case <span class="token number">6</span></pre></td></tr></table></figure><p>cmp指令判断参数n与立即数6的大小，如果n大于6，程序跳转到default对应的L8程序段，对于<code>case0~case6</code>的情况，可以通过跳转表来访问不同分支，C代码将跳转表声明为一个长度为7的数组，每个元素都是一个指向代码位置的指针。数组长度为7，因为需要覆盖<code>case0 ~ case6</code>的情况，对于重复的情况<code>case4</code>和<code>case6</code>，使用相同的标号，对于缺失的<code>case1</code>和<code>case5</code>的情况，使用默认情况的标号。</p><p>在这个例子中，程序使用跳转表来处理多重分支，甚至当switch有上百种情况时，虽然跳转表的长度会增加，但是程序的执行只需要一次跳转也能处理复杂分支的情况，与使用一组很长的<code>if-else</code>相比，使用跳转表的优点时执行switch语句的时间与case的数量是无关的，因此在处理多重分支时，与一组很长的if-else相比，switch的执行效率要高。</p><h3 id=过程procedures><a class=anchor href=#过程procedures>#</a> 过程(Procedures)</h3><p>过程提供了一种封装代码的方式，可以隐藏某个行为的具体实现，同时提供清晰简洁的接口定义。在不同的变成语言种，过程的具体实现多种多样，例如C语言中的函数，Java语言的方法等。</p><p>以C语言的函数调用为例，假设函数P调用函数Q，函数Q执行完返回函数P。这一系列操作包括以下的一个或多个机制</p><ul><li>传递控制(Passing control)</li><li>传递数据(Passing data)</li><li>分配和释放内存(Allocating and deallocating memory)</li></ul><p>程序运行时的内存分布，其中栈为函数调用提供了后进先出的内存管理机制，在函数P调用函数Q的例子中，当函数Q正在执行时，函数P以及相关调用链上的函数都会被暂时挂起。</p><p><strong>栈帧</strong> - 当函数执行所需要的存储空间超出寄存器能够存放的大小时，就会借助栈上的存储空间，这部分存储空间被称为函数的栈帧。对于函数P调用函数Q的例子，包括较早的帧，调用函数P的帧，还有正在执行函数Q的帧。</p><p>当函数P调用函数Q时，会把返回地址压入栈中，该地址指明了当函数Q执行结束返回时要从函数P的哪个位置继续执行，这个返回地址的压栈操作并不是由指令push来执行的，而是由函数调用指令call来实现的。</p><p>以以下程序为例来解释call指令和ret指令的执行情况。</p><figure class="highlight c"><figcaption data-lang=c><span>c main.c</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">void</span> <span class="token function">multstore</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">,</span><span class="token keyword">long</span><span class="token punctuation">,</span><span class="token keyword">long</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">long</span> d<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token function">multstore</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2 * 3 --> %ld\n"</span><span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=12></td><td><pre></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token keyword">long</span> <span class="token function">mult2</span><span class="token punctuation">(</span><span class="token keyword">long</span> a<span class="token punctuation">,</span><span class="token keyword">long</span> b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=15></td><td><pre>	<span class="token keyword">long</span> s <span class="token operator">=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token keyword">return</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight c"><figcaption data-lang=c><span>mstore.c</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">long</span> <span class="token function">mult2</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">,</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">void</span> <span class="token function">multstore</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span><span class="token keyword">long</span> y<span class="token punctuation">,</span><span class="token keyword">long</span><span class="token operator">*</span> dest<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">long</span> t <span class="token operator">=</span> <span class="token function">mult2</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token operator">*</span>dest <span class="token operator">=</span> t<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>由于需要查看两个函数的反汇编代码，需使用以下命令</p><ul><li><code>gcc -Og -o prog main.c mstore.c</code></li><li><code>objdump -d proc</code></li></ul><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre># 截选了相关的部分反汇编代码</pre></td></tr><tr><td data-num=2></td><td><pre>00000000000006da <span class="token operator">&lt;</span>main<span class="token operator">></span>:</pre></td></tr><tr><td data-num=3></td><td><pre>......</pre></td></tr><tr><td data-num=4></td><td><pre>	6fb: e8 <span class="token number">41</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span>		callq <span class="token number">741</span> <span class="token operator">&lt;</span>multstore<span class="token operator">></span></pre></td></tr><tr><td data-num=5></td><td><pre>	<span class="token number">700</span>: <span class="token number">48</span> 8b <span class="token number">14</span> <span class="token number">24</span>		mov (<span class="token operator">%</span><span class="token register variable">rsp</span>),<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token number">0000000000000741</span> <span class="token operator">&lt;</span>multstore<span class="token operator">></span>:</pre></td></tr><tr><td data-num=7></td><td><pre>....</pre></td></tr><tr><td data-num=8></td><td><pre>	<span class="token number">741</span>: <span class="token number">53</span>	push <span class="token operator">%</span><span class="token register variable">rbx</span></pre></td></tr><tr><td data-num=9></td><td><pre>	<span class="token number">742</span>: <span class="token number">48</span> <span class="token number">89</span> d3	mov <span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token operator">%</span><span class="token register variable">rbx</span></pre></td></tr></table></figure><p><code>callq 741 &lt;multstore&gt;</code>指令对应于multstore函数的调用，指令call不仅要将函数multstore的第一条指令的地址，写入到程序指令寄存器rip中，以此实现函数调用，同时还要将返回地址压入栈中，这个返回地址就是函数multstore调用执行完毕后，下一条指令的地址。当函数multstore执行完毕，指令ret从栈中将返回地址弹出，写入到程序指令寄存器rip中，函数返回，继续执行函数中相关的操作，以上整个过程就是函数调用与返回所涉及的操作。</p><p>接下来看参数传递，如果一个函数的参数数量大于6，超出的部分就要通过栈来传递。假设函数P有n个整形参数，当n的值大于6时，参数7参数n需要用到栈来传递，参数1参数6的传递可以使用对应的寄存器。</p><p><font size=3><ins><strong>参数传递的例子</strong></ins></font></p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">void</span> <span class="token function">proc</span><span class="token punctuation">(</span><span class="token keyword">long</span> a1<span class="token punctuation">,</span><span class="token keyword">long</span><span class="token operator">*</span> a1p<span class="token punctuation">,</span><span class="token keyword">int</span> a2<span class="token punctuation">,</span><span class="token keyword">long</span><span class="token operator">*</span> a2p<span class="token punctuation">,</span><span class="token keyword">short</span> a3<span class="token punctuation">,</span><span class="token keyword">long</span><span class="token operator">*</span> a3p<span class="token punctuation">,</span> <span class="token keyword">char</span> a4<span class="token punctuation">,</span><span class="token keyword">long</span><span class="token operator">*</span> a4p<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    a1p <span class="token operator">+=</span> a1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    a2p <span class="token operator">+=</span> a2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    a3p <span class="token operator">+=</span> a3<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    a4p <span class="token operator">+=</span> a4<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>proc函数有8个参数，包括字节数不同的整数以及不同类型的指针，参数1参数6是通过寄存器来传递，参数7参数8是通过栈来传递。通过栈传递参数时，所有数据的大小都是向8的倍数对齐，虽然变量a4只占一个字节，但仍然为其分配了8个字节的存储空间。由于返回地址占用了栈顶的位置，所以这两个参数距离栈顶指针的距离分别为8和16。使用寄存器进行参数传递时，寄存器的使用是有特殊顺序规定的，寄存器名字的使用取决于传递参数的大小，如果一个参数大小是4个字节，需要用寄存器edi来保存。</p><p>当代码中对一个局部变量使用地址运算符时，此时需要在栈上为这个局部变量开辟相应的存储空间。</p><p><font size=3><ins><strong>地址运算符相关的例子</strong></ins></font></p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">long</span> <span class="token function">caller</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> arg1 <span class="token operator">=</span> <span class="token number">534</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">long</span> arg2 <span class="token operator">=</span> <span class="token number">1057</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">long</span> sum <span class="token operator">=</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arg1<span class="token punctuation">,</span><span class="token operator">&amp;</span>arg2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">long</span> diff <span class="token operator">=</span> arg1 <span class="token operator">-</span> arg2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">return</span> sum <span class="token operator">*</span> diff<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">caller:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	subq <span class="token number">$16</span>,<span class="token operator">%</span><span class="token register variable">rsp</span></pre></td></tr><tr><td data-num=3></td><td><pre>	movq <span class="token number">$534</span>,(<span class="token operator">%</span><span class="token register variable">rsp</span>)</pre></td></tr><tr><td data-num=4></td><td><pre>	movq <span class="token number">$1057</span>,<span class="token number">8</span>(<span class="token operator">%</span><span class="token register variable">rsp</span>)</pre></td></tr><tr><td data-num=5></td><td><pre>	leaq <span class="token number">8</span>(<span class="token operator">%</span><span class="token register variable">rsp</span>),<span class="token operator">%</span><span class="token register variable">rsi</span></pre></td></tr><tr><td data-num=6></td><td><pre>	movq <span class="token operator">%</span><span class="token register variable">rsp</span>,<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=7></td><td><pre>	call swap</pre></td></tr><tr><td data-num=8></td><td><pre>	movq (<span class="token operator">%</span><span class="token register variable">rsp</span>),<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=9></td><td><pre>	subq <span class="token number">8</span>(<span class="token operator">%</span><span class="token register variable">rsp</span>),<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=10></td><td><pre>	imulq <span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=11></td><td><pre>	addq <span class="token number">$16</span>,<span class="token operator">%</span><span class="token register variable">rsp</span></pre></td></tr><tr><td data-num=12></td><td><pre>	ret</pre></td></tr></table></figure><p>函数caller定义了两个局部变量arg1和arg2，函数swap的功能是交换这两个变量的值，最后返回二者之和。</p><p>caller汇编指令的第一条减法指令将栈顶指针减去16，表示的含义是在栈上分配16个字节的空间。根据之后的两条mov指令可以推断出变量arg1和arg2存储在函数caller的栈帧上。接下来，分别计算变量arg1和arg2存储的地址，参数准备完毕，执行call指令调用swap函数，最后函数caller返回之前，通过栈顶指针加上16的操作来释放栈帧。</p><p>接着是一个更复杂的例子</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">long</span> <span class="token function">call_proc</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> x1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">int</span> x2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">short</span> x3 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    cahr x4 <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token function">proc</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span><span class="token operator">&amp;</span>x1<span class="token punctuation">,</span>x2<span class="token punctuation">,</span><span class="token operator">&amp;</span>x2<span class="token punctuation">,</span>x3<span class="token punctuation">,</span><span class="token operator">&amp;</span>x3<span class="token punctuation">,</span>x4<span class="token punctuation">,</span><span class="token operator">&amp;</span>x4<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">return</span> <span class="token punctuation">(</span>x1<span class="token operator">+</span>x2<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>x3<span class="token operator">-</span>x4<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>根据变量的类型可知x1占8个字节，x2占4个字节，x3占两个字节，x4占一个字节。由于函数proc需要8个参数，因此参数7和参数8需要通过栈帧来传递，传递的参数需要8个字节对齐，而局部变量是不需要对齐的。从上面的例子可知，当函数运行需要局部存储空间时，栈提供了内存分配与回收的机制。</p><p>在程序执行的过程中，寄存器是被所有函数共享的一种资源，为了避免寄存器的使用过程中出现数据覆盖的问题，处理器规定了寄存器的使用的惯例，所有的函数调用都必须遵守这个惯例，对于16个通用寄存器，除了寄存器rsp之外，其他15个寄存器分别被定义为调用者保存和被调用者保存。</p><p>接下来看一个<strong>栈保存寄存器数值</strong>的例子</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">void</span> <span class="token function">P</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span><span class="token keyword">long</span> y<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> u <span class="token operator">=</span> <span class="token function">Q</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">long</span> v <span class="token operator">=</span> <span class="token function">Q</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">return</span> u <span class="token operator">+</span> v<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">P:</span></pre></td></tr><tr><td data-num=2></td><td><pre>    pushq <span class="token operator">%</span><span class="token register variable">rbp</span></pre></td></tr><tr><td data-num=3></td><td><pre>    pushq <span class="token operator">%</span><span class="token register variable">rbx</span></pre></td></tr><tr><td data-num=4></td><td><pre>    subq <span class="token number">$8</span>,<span class="token operator">%</span><span class="token register variable">rsp</span></pre></td></tr><tr><td data-num=5></td><td><pre>    movq <span class="token operator">%</span><span class="token register variable">rdi</span>,<span class="token operator">%</span><span class="token register variable">rbp</span></pre></td></tr><tr><td data-num=6></td><td><pre>    movq <span class="token operator">%</span><span class="token register variable">rsi</span>,<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=7></td><td><pre>    call Q</pre></td></tr><tr><td data-num=8></td><td><pre>    ....</pre></td></tr><tr><td data-num=9></td><td><pre>    popq <span class="token operator">%</span><span class="token register variable">rbx</span></pre></td></tr><tr><td data-num=10></td><td><pre>    popq <span class="token operator">%</span><span class="token register variable">rbp</span></pre></td></tr><tr><td data-num=11></td><td><pre>    ret</pre></td></tr></table></figure><p>由于函数Q需要使用寄存器rdi来传递参数，因此，函数P需要保存寄存器rdi中的参数x。保存参数x使用了寄存器rbp，根据寄存器使用规则，寄存器rbp被定义为被调用者保存寄存器，所以便有了开头这条指令<code>pushq %rbp</code>，至于<code>pushq %rbx</code>也是类似的道理，在函数P返回之前，使用pop指令恢复寄存器rbp和rbx的值，由于栈的规则是后进先出，所以弹出的顺序与压入的顺序相反。</p><p>接着看一个<strong>递归调用</strong>的例子</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">long</span> <span class="token function">rfact</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">else</span><span class="token punctuation">&#123;</span> result <span class="token operator">=</span> n <span class="token operator">*</span> <span class="token function">rfact</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">rfact:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	pushq <span class="token operator">%</span><span class="token register variable">rbx</span></pre></td></tr><tr><td data-num=3></td><td><pre>	movq <span class="token operator">%</span><span class="token register variable">rdi</span>,<span class="token operator">%</span><span class="token register variable">rbx</span></pre></td></tr><tr><td data-num=4></td><td><pre>	movl <span class="token number">$1</span>,<span class="token operator">%</span><span class="token register variable">eax</span></pre></td></tr><tr><td data-num=5></td><td><pre>	cmpq <span class="token number">$1</span>,<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=6></td><td><pre>	jle .L35</pre></td></tr><tr><td data-num=7></td><td><pre>	leaq <span class="token operator">-</span><span class="token number">1</span>(<span class="token operator">%</span><span class="token register variable">rdi</span>),<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=8></td><td><pre>	call rfact</pre></td></tr><tr><td data-num=9></td><td><pre>	imulq <span class="token operator">%</span><span class="token register variable">rbx</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token label function">.L35:</span></pre></td></tr><tr><td data-num=11></td><td><pre>	popq <span class="token operator">%</span>rvx</pre></td></tr><tr><td data-num=12></td><td><pre>	ret</pre></td></tr></table></figure><p>这段代码是关于N的阶乘的递归实现。假设n=3，由于使用寄存器rbx来保存n的值，根据寄存器使用惯例，首先保存寄存器rbx的值，由于n=3，所以跳转指令jle不会跳转到L35处执行，指令leaq是用来计算<code>n-1</code>，然后再次调用该函数，此时寄存器rbx内保存的值是3，指令pushq执行完毕后。继续执行，直到n=1时，程序跳转到L35处，执行pop操作。递归调用一个函数本身与调用其他函数是一样的，每次函数调用都有它自己私有的状态信息。</p><p>栈分配与释放的规则与函数调用返回的顺序也是匹配的，不过当N的值非常大时，并不建议使用递归调用。</p><h3 id=数组的分配和访问><a class=anchor href=#数组的分配和访问>#</a> 数组的分配和访问</h3><p><code>char A[8];</code></p><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>|___|___|___|___|___|___|___|___|__</pre></td></tr><tr><td data-num=2></td><td><pre>|a0 |a1 |a2 |a3 |a4 |a5 |a6 |a7 |</pre></td></tr><tr><td data-num=3></td><td><pre>|---|---|---|---|---|---|---|---|--</pre></td></tr></table></figure><p>数组A是由8个char类型的元素组成，每个元素的大小是一个字节。假设数组A的起始地址是Xa，那么数组元素A[i]的地址就是<code>Xa+i</code>。</p><p><code>int B[4];</code></p><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>|___|___|___|___|__</pre></td></tr><tr><td data-num=2></td><td><pre>|b0 |b1 |b2 |b3 |</pre></td></tr><tr><td data-num=3></td><td><pre>|---|---|---|---|--</pre></td></tr></table></figure><p>数组B是由4个整数组成，每个元素占4个字节，因此数组B总的大小为16个字节。假设数组B的起始地址是Xb，那么数组元素B[i]的地址就是<code>Xb+4i</code>。</p><p>在C语言中，允许对指针进行运算，例如，声明了一个指向char类型的指针p和一个指向int类型的指针q。</p><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>0x100  0x101  0x102  0x103  0x104  0x105</pre></td></tr><tr><td data-num=2></td><td><pre>_|_____|______|______|______|______|______|___</pre></td></tr><tr><td data-num=3></td><td><pre>.|     |      |      |      |      |      |...</pre></td></tr><tr><td data-num=4></td><td><pre>-|-----|------|------|------|------|------|---</pre></td></tr></table></figure><p>把内存抽象成一个大的数组，假设<code>char* p</code>和<code>int* q</code>，指针p和指针q都指向<code>0x100</code>(内存地址)处，现在分别对指针p和指针q进行加一的操作，指针p加1指向<code>0x101</code>处，而指针q加1后指向<code>0x104</code>处。虽然都是对指针进行加一的运算，但是得到的结果却不同，这是因为对指针进行运算时，计算结果会根据该指针引用的数据类型进行相应的伸缩。</p><p>例子，定义一个数组E，<code>int E[6];</code>，假设这个数组存放在内存中，</p><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>0x100  0x104  0x108  0x10C  0x110  0x114</pre></td></tr><tr><td data-num=2></td><td><pre>_|_____|______|______|______|______|______|___</pre></td></tr><tr><td data-num=3></td><td><pre>.| e0  | e1   | e2   | e3   | e4   | e5   |...</pre></td></tr><tr><td data-num=4></td><td><pre>-|-----|------|------|------|------|------|---</pre></td></tr></table></figure><p>对于数组的每一个元素都有两个属性，一个属性是它存储的内容，另外一个属性是它的存储地址。对于元素的存储地址，可以通过取地址运算符来获得。通常习惯使用数组引用的方式来访问数组中的元素。例如可以使用<code>E[2]</code>来访问数组中的元素，另外还有另外一种方式<code>*(E + 2)</code>，其中<code>E+2</code>表示数组第二个元素的存储地址，大写字母E表示数组的起始地址(第0个元素)，此处加2的操作与指针加2的运算类似，也是与数据类型相关。指针运算符<code>*</code>可以理解成从该地址处取数据。可以发现指针其实就是地址的抽象表述。</p><p><strong>嵌套数组</strong>也被称为二维数组，例如，<code>int A[5][3];</code>，数组A可以被看成一个<code>5</code>行<code>3</code>列的二维数组，这种理解方式与矩阵的排列类似。在计算机系统中，通常把内存抽象为一个巨大的数组，对于二维数组在内存中是按照<code>行优先</code>的顺序进行存储的，基于这个规则，数组A在内存中的存储情况。</p><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>A<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span>  A<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>  A<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">[</span>2<span class="token punctuation">]</span>  A<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span>  A<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>        A<span class="token punctuation">[</span>4<span class="token punctuation">]</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span>  A<span class="token punctuation">[</span>4<span class="token punctuation">]</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>  A<span class="token punctuation">[</span>4<span class="token punctuation">]</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span></pre></td></tr><tr><td data-num=2></td><td><pre>__|________|________|________|_______|________|______|_______|_________|_______|</pre></td></tr><tr><td data-num=3></td><td><pre>..| a00    |  a01   | a02    | a10   |........| a40  | a41   | a41     |.......|</pre></td></tr><tr><td data-num=4></td><td><pre>--|--------|--------|--------|-------|--------|------|-------|---------|-------|</pre></td></tr></table></figure><p>关于数组的理解，还有一种方式，就是可以把数组A看成一个有5个元素的数组，其中每个元素都是一个长度为3的数组，这便是嵌套数组的理解方式。无论用何种方式来理解，数组元素在内存中的存储位置都是一样的。</p><p>数组元素的地址是如何计算的，对于数组D，<code>T D[R][C]</code>，任意一个元素可以通过图中的计算公式来计算地址<code>&amp;D[i][j] = XD + L(C*i+j)</code>，其中，Xd表示数组的起始地址，L表示数据类型T的大小，如果T是int类型，L就是等于4，T是char类型，L就等于1，在具体的示例中，C，i，j都是常数，根据图中的计算公式，对于5X3的数组A，其任意元素的地址可以<code>Xa + 4 * (3i+j)</code>来计算，假设数组起始地址Xa在寄存器rdi中，索引值i和j分别在寄存器rsi和rdx中，可以通过汇编代码</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>leaq (<span class="token operator">%</span><span class="token register variable">rsi</span>,<span class="token operator">%</span><span class="token register variable">rsi</span>,<span class="token number">2</span>),<span class="token operator">%</span><span class="token register variable">rax</span> # compute <span class="token number">3</span> <span class="token operator">*</span> i</pre></td></tr><tr><td data-num=2></td><td><pre>leaq (<span class="token operator">%</span><span class="token register variable">rdi</span>,<span class="token operator">%</span><span class="token register variable">rax</span>,<span class="token number">4</span>),<span class="token operator">%</span><span class="token register variable">rax</span> # compute XA <span class="token operator">+</span> <span class="token number">12</span> <span class="token operator">*</span> i</pre></td></tr><tr><td data-num=3></td><td><pre>movl (<span class="token operator">%</span><span class="token register variable">rax</span>,<span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token number">4</span>),<span class="token operator">%</span><span class="token register variable">eax</span> # Read from M<span class="token operator">[</span>XA <span class="token operator">+</span> 12i <span class="token operator">+</span> 4j<span class="token operator">]</span></pre></td></tr></table></figure><p>将<code>A[i][j]</code>的值复制到寄存器eax中。</p><p>编译器对定长多维数组的优化，首先使用</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">16</span></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">int</span> fix_matrix<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>将数据类型<code>fix_matrix</code>声明为<code>16*16</code>的整形数组，通过<code>define</code>声明将N与常数16关联到一起，之后的代码中就可以使用N来代替常数<code>16</code>，当需要修改数组的长度时，只需要简单的修改define声明即可。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">16</span></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">int</span> fix_matrix<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">int</span> <span class="token function">matrix</span><span class="token punctuation">(</span>fix_matrix A<span class="token punctuation">,</span>fix_matrix B<span class="token punctuation">,</span><span class="token keyword">long</span> i<span class="token punctuation">,</span><span class="token keyword">long</span> k<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>	<span class="token keyword">long</span> j<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>	<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>	<span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=9></td><td><pre>		result <span class="token operator">+=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">matrix:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	salq <span class="token number">$6</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=3></td><td><pre>	addq <span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=4></td><td><pre>	leaq (<span class="token operator">%</span><span class="token register variable">rsi</span>,<span class="token operator">%</span><span class="token register variable">rcx</span>,<span class="token number">4</span>),<span class="token operator">%</span><span class="token register variable">rcx</span></pre></td></tr><tr><td data-num=5></td><td><pre>	leaq <span class="token number">1024</span>(<span class="token operator">%</span><span class="token register variable">rcx</span>),<span class="token operator">%</span><span class="token register variable">rsi</span></pre></td></tr><tr><td data-num=6></td><td><pre>	movl <span class="token number">$0</span>,<span class="token operator">%</span><span class="token register variable">eax</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token label function">.L7:</span></pre></td></tr><tr><td data-num=8></td><td><pre>......</pre></td></tr></table></figure><p>这段代码是用来计算矩阵A的第i行与矩阵B的第k列的内积。由于编译器对相关的操作进行了优化，故这段汇编代码有些晦涩难懂。</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>salq <span class="token number">$6</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=2></td><td><pre>addq <span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=3></td><td><pre>leaq (<span class="token operator">%</span><span class="token register variable">rsi</span>,<span class="token operator">%</span><span class="token register variable">rcx</span>,<span class="token number">4</span>),<span class="token operator">%</span><span class="token register variable">rcx</span></pre></td></tr><tr><td data-num=4></td><td><pre>leaq <span class="token number">1024</span>(<span class="token operator">%</span><span class="token register variable">rcx</span>),<span class="token operator">%</span><span class="token register variable">rsi</span></pre></td></tr></table></figure><p>这四行汇编代码是用来计算三个数组元素的地址，一个是数组A第i行首个元素的地址，另外两个分别是数组B第k列的第一个元素和最后一个元素的地址，然后将这三个地址分别存放到不同的寄存器中。</p><p>下面的是循环的实现</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">.L7:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	movl (<span class="token operator">%</span><span class="token register variable">rdi</span>),<span class="token operator">%</span><span class="token register variable">edx</span></pre></td></tr><tr><td data-num=3></td><td><pre>	imull (<span class="token operator">%</span><span class="token register variable">rcx</span>),<span class="token operator">%</span><span class="token register variable">edx</span></pre></td></tr><tr><td data-num=4></td><td><pre>	addl <span class="token operator">%</span><span class="token register variable">edx</span>,<span class="token operator">%</span><span class="token register variable">eax</span></pre></td></tr><tr><td data-num=5></td><td><pre>	addq <span class="token number">$4</span>,<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=6></td><td><pre>	addq <span class="token number">$64</span>,<span class="token operator">%</span><span class="token register variable">rcx</span></pre></td></tr><tr><td data-num=7></td><td><pre>	cmpq (<span class="token operator">%</span><span class="token register variable">rsi</span>),<span class="token operator">%</span><span class="token register variable">rcx</span></pre></td></tr><tr><td data-num=8></td><td><pre>	jne .L7</pre></td></tr><tr><td data-num=9></td><td><pre>	rep<span class="token comment">;ret</span></pre></td></tr></table></figure><p>首先读取指针aptr指向元素的数据，然后将指针aptr指向的元素与指针bptr指向的元素相乘，最后将乘积结果进行累加，结果保存到寄存器eax中。计算完成之后，分别移动指针aptr和bptr指向下一个元素，由于int类型占4个字节，对寄存器rdi加4的这个操作，对应于移动指针aptr指向数组A的下一个元素，由于数组B一行元素的数量为16个，每个元素占4个字节，因此相邻列元素的地址相差为64个字节，对寄存器rcx进行加64的操作对应移动指针bptr指向数组B的下一个元素，判断循环结束的条件是指针bptr指针与指针bend是否指向同一个内存地址。如果二者不相等，继续跳转到L7处执行，如果二者相等，循环结束。可以发现编译器使用了很巧妙的方式来计算数组元素的地址，这些优化方法显著的提升了程序的执行效率。</p><p>在C89标准中，使用变长数组时需要使用malloc这类函数为数组动态分配存储空间。在ISO C99的标准中，引入了变长数组的概念，因此，可以通过<code>int A[expr1][expr2];</code>的方式来声明一个变长数组，它可以作为一个局部变量，也可以作为函数的参数。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">long</span> <span class="token function">var_ele</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> A<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">long</span> i<span class="token punctuation">,</span><span class="token keyword">long</span> k<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">return</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">var_ele:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	imulq <span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token operator">%</span><span class="token register variable">rdi</span> # compute n <span class="token operator">*</span> i</pre></td></tr><tr><td data-num=3></td><td><pre>	leaq (<span class="token operator">%</span><span class="token register variable">rsi</span>,<span class="token operator">%</span><span class="token register variable">rdi</span>,<span class="token number">4</span>),<span class="token operator">%</span><span class="token register variable">rax</span> # compute Xa <span class="token operator">+</span> <span class="token number">4</span>(n <span class="token operator">*</span> i)</pre></td></tr><tr><td data-num=4></td><td><pre>	movl (<span class="token operator">%</span><span class="token register variable">rax</span>,<span class="token operator">%</span><span class="token register variable">rcx</span>,<span class="token number">4</span>),<span class="token operator">%</span><span class="token register variable">eax</span> # Read from M<span class="token operator">[</span>Xa <span class="token operator">+</span> <span class="token number">4</span>(n <span class="token operator">*</span> i) <span class="token operator">+</span> 4j<span class="token operator">]</span></pre></td></tr><tr><td data-num=5></td><td><pre>	ret</pre></td></tr></table></figure><p>当变长数组作函数参数时，参数n必须在数组A之前，变长数组的地址计算与定长数组类似。不同点在于新增了参数n，需要使用乘法指令来计算n乘以i，还是矩阵A和矩阵B内积的例子，如果采用变长数组来存储矩阵A和矩阵B，与定长数组相比C代码的实现几乎没有差别。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">var_mat</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> A<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> B<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">long</span> i<span class="token punctuation">,</span><span class="token keyword">long</span> k<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> j<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=6></td><td><pre>        result  <span class="token operator">+=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">.L24:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	movl (<span class="token operator">%</span><span class="token register variable">rsi</span>,<span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token number">4</span>),<span class="token operator">%</span><span class="token register variable">r8d</span></pre></td></tr><tr><td data-num=3></td><td><pre>	imull (<span class="token operator">%</span><span class="token register variable">rcx</span>),<span class="token operator">%</span><span class="token register variable">r8d</span></pre></td></tr><tr><td data-num=4></td><td><pre>	addl <span class="token operator">%</span><span class="token register variable">r8d</span>,<span class="token operator">%</span><span class="token register variable">eax</span></pre></td></tr><tr><td data-num=5></td><td><pre>	addq <span class="token number">$1</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=6></td><td><pre>	addq <span class="token operator">$</span><span class="token register variable">r9</span>,<span class="token operator">%</span><span class="token register variable">rcx</span></pre></td></tr><tr><td data-num=7></td><td><pre>	cmpq <span class="token operator">%</span><span class="token register variable">rdi</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=8></td><td><pre>	jne .L24</pre></td></tr></table></figure><p>不过对比二者的汇编代码，可以发现编译器采用了不同的优化方法。</p><h3 id=结构体与联合体><a class=anchor href=#结构体与联合体>#</a> 结构体与联合体</h3><p>首先是一个结构体声明</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">rec</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">int</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">int</span> j<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>图中结构体包含四个字段，两个int类型的变量，一个int类型的数组和int类型的指针，下列是各个字段相对于结构体起始地址处的字节偏移。</p><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>0   4   8      12     16   </pre></td></tr><tr><td data-num=2></td><td><pre>|___|___|______|______|_____|</pre></td></tr><tr><td data-num=3></td><td><pre>| i | j | a<span class="token punctuation">[</span>0<span class="token punctuation">]</span> | a<span class="token punctuation">[</span>1<span class="token punctuation">]</span> |  p  |</pre></td></tr><tr><td data-num=4></td><td><pre>|---|---|------|------|-----|</pre></td></tr></table></figure><p>可以看出数组a的元素是嵌入到结构体中的。例如，声明一个结构体类型指针变量r，它指向结构体的起始地址，假设r存放在寄存器rdi中，它指向结构体的起始地址，假如r存放在寄存器rdi中，可以使用以下汇编指令将字段i的值复制到字段j中。</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>movl (<span class="token operator">%</span><span class="token register variable">rdi</span>),<span class="token operator">%</span><span class="token register variable">eax</span></pre></td></tr><tr><td data-num=2></td><td><pre>movl <span class="token operator">%</span><span class="token register variable">eax</span>,<span class="token number">4</span>(<span class="token operator">%</span><span class="token register variable">rdi</span>)</pre></td></tr></table></figure><p>由于字段i相对于结构体起始地址的偏移量为0，所以字段i的地址就是r的值，而字段j的偏移量为4，因此需要将r加上偏移量4。对于结构体中的数组a，可以通过图中的指令来计算任意一个数组元素的地址，其中结构体指针r存放在寄存器rdi中，数组元素的索引值i存放在寄存器rsi中，数组元素的索引值i存放在寄存器rsi中，最后地址的计算结果，存放在寄存器rax中，最后地址的计算结果，存放在寄存器rax中。综上所述，无论是单个变量还是数组元素，都是通过起始地址加偏移量的方式来访问。</p><p>关于结构体数据对齐的知识，例如结构体</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">S1</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">int</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">char</span> c<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">int</span> j<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>它包含两个int类型的变量和一个char类型的变量，我们会直观的认为该结构体占用9个字节的存储空间，但是当使用sizeof函数对该结构体的大小进行求值时，得到的结果却是12个字节。原因是为了提高内存系统的性能，系统对于数据存储的合法地址做出了一些限制。系统对于数据存储的合法地址做出了一些限制，例如变量j是int类型，占4个字节，它的起始地址必须是4的倍数。因此，编译器会在变量c和变量j之间插入一个3字节的间隙，这样变量j相对于起始地址的偏移量就为8，整个结构体的大小就变成了12个字节。对于不同的数据类型，地址对齐得到原则是任何K字节的基本对象的地址必须是K的倍数，也就是说对于short类型，起始地址必须是2的倍数，对于占8个字节的数据类型，起始地址必须是8的倍数。基于规则，编译器可能需要在字段的地址空间分配时插入间隙，以此保证每个结构体的元素都满足对齐的要求，除此之外，结构体的末尾可能需要填充间隙。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">S2</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">int</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">int</span> j<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">char</span> c<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>还是刚才的这个结构体，可以通过调整字段j和字段c的排列顺序，使得所有的字段都满足了数据对齐的要求，但是当我们声明一个结构体数组时，分配9个字节的存储空间，是无法满足所有数组元素的对齐要求。因此，编译器会在结构体的末端增加3个字节的填充。这样一来，所有的对齐限制都满足了。根据上述对齐原则，下列为一个复杂的示例</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">struct</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">char</span><span class="token operator">*</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">short</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">double</span> c<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">char</span> d<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">float</span> e<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">char</span> f<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token keyword">long</span> g<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">int</span> h<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#125;</span>rec<span class="token punctuation">;</span></pre></td></tr></table></figure><p>对于这个结构体，以下为所有字段起始地址的偏移量。变量a是一个指针变量，占8个字节，变量b是short类型，占两个字节，它起始地址的字节偏移量是8，满足对齐规则。由于变量c是double类型，占8个字节，因此，该变量起始地址的偏移量需要是8的倍数，所以需要在变量b之后插入6个字节的间隙，对于变量d只占一个字节，顺序排列即可。由于变量e占4个字节，它的偏移量需要是4的倍数，因此，需要在变量d之后插入3个字节的间隙。同样变量f是char类型，顺序排列即可，由于变量g占8个字节，因此需要在变量f之后插入7个字节的间隙，最后一个变量h占4个字节，此时结构体的大小为52个字节，为了保证每个元素都满足对齐要求，还需要在结构体的尾端填充4个字节的间隙，最终结构体的大小为56个字节。</p><p>C语言中还有一种数据类型-联合体，与结构体不同，联合体中的所有字段共享同一存储区域，因此联合体的大小取决于它最大字段的大小，变量v和数组i的大小都是8个字节，因此，这个联合体的占8个字节的存储空间，联合体的一种应用情况是，事先知道两个不同字段的使用是互斥的，那么可以将这两个字段声明为一个联合体。</p><p>例如，定义一个二叉树的数据结构，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">node_s</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">node_s</span><span class="token operator">*</span> left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">node_s</span><span class="token operator">*</span> right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">double</span> data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这个二叉树分为内部节点和叶子节点，其中每个内部节点不含数据，都有指向两个孩子节点的指针，每个叶子节点都有两个double类型的数据值。可以用结构体来定义该二叉树的节点，那么每个节点需要32个字节。该二叉树的任意一个节点不是内部节点就是叶子节点，因此，可以用联合体来定义节点，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">union</span> node_u</pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">struct</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>        <span class="token keyword">union</span> node_u<span class="token operator">*</span> left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>        <span class="token keyword">union</span> node_u<span class="token operator">*</span> right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token punctuation">&#125;</span>internal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">double</span> data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这样，每个节点只需要16个字节的存储空间，相对于结构体的定义方式，可以节省一半的空间。不过，这种编码方式存在一个问题，就是没有办法来确定一个节点到底是叶子节点还是内部节点，通常的解决方法就是引入一个枚举类型，然后创建一个结构体，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">enum</span><span class="token punctuation">&#123;</span>N_LEAF<span class="token punctuation">,</span>N_INTERNAL<span class="token punctuation">&#125;</span><span class="token class-name">nodetype_t</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">node_t</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token class-name">nodetype_t</span> type<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">union</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>        <span class="token keyword">struct</span></pre></td></tr><tr><td data-num=9></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>            <span class="token keyword">struct</span> <span class="token class-name">node_t</span><span class="token operator">*</span> left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>            <span class="token keyword">struct</span> <span class="token class-name">node_t</span><span class="token operator">*</span> right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>        <span class="token punctuation">&#125;</span>internal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>        <span class="token keyword">double</span> data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token punctuation">&#125;</span>info<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>它包含一个标签和一个联合体，其中type占4个字节，联合体占16个字节，type和联合体之间需要加入4个间隙，因此，整个结构体的大小为24个字节，在这种例子中，虽然使用联合体因此，对于有较多字段的情况，可以节省存储空间，但是相对于给代码编写造成的麻烦，这样的节省意义不大。因此，对于有较多字段的情况，使用联合体带来的空间节省才会更吸引人。除此之外，联合体还可以用来访问不同数据类型的位模式<code>unsigned long u = (unsigned long)d</code>，当使用简单的强制类型转换，将double类型的数据转换为<code>unsigned long</code>类型时，除了d等于0的情况，二者的二进制位表示差别很大，这时可以将两种类型的变量声明为一个联合体，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">long</span> u <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>d<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">double2bits</span><span class="token punctuation">(</span><span class="token keyword">double</span> d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">union</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>        <span class="token keyword">double</span> d<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> u<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token punctuation">&#125;</span>temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    temp<span class="token punctuation">.</span>d <span class="token operator">=</span> d<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">return</span> temp<span class="token punctuation">.</span>u<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这样就是可以以一种类型来存储，以另外一种类型来访问，变量u和d就具有相同的位表示，虽然平时编程时很少用到联合体，但是在一些特殊的场景中仍可以看到它的身影。</p><h3 id=缓冲区溢出><a class=anchor href=#缓冲区溢出>#</a> 缓冲区溢出</h3><p>栈帧中会保存程序执行所需要的重要信息，例如返回地址，以及保存的寄存器的值等。在C语言中，对数组的引用不会进行任何的边界检查，如果对越界的数组进行写操作，就会破坏存储在栈中的状态信息。当程序使用了被修改的返回地址时，就会导致严重的错误。</p><p>以下示例为缓冲区溢出</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">void</span> <span class="token function">echo</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token function">gets</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token function">puts</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">echo:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	subq <span class="token number">$24</span>,<span class="token operator">%</span><span class="token register variable">rsp</span></pre></td></tr><tr><td data-num=3></td><td><pre>	movq <span class="token operator">%</span><span class="token register variable">rsp</span>,<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=4></td><td><pre>	call gets</pre></td></tr><tr><td data-num=5></td><td><pre>	movq <span class="token operator">%</span><span class="token register variable">rsp</span>,<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=6></td><td><pre>	call puts</pre></td></tr><tr><td data-num=7></td><td><pre>	addq <span class="token number">$24</span>,<span class="token operator">%</span><span class="token register variable">rsp</span></pre></td></tr><tr><td data-num=8></td><td><pre>	ret</pre></td></tr></table></figure><p>例如上面的<code>echo</code>函数，声明了一个长度为8的字符数组，gets函数是C语言标准库中定义的函数，用于从标准输入读入一行字符串，在遇到回车或某个错误的情况时停止，gets函数将这个字符串复制到参数buf指明的位置，并在字符串结束的位置加上null字符。gets函数无法确定是否有足够大的空间来保存整个字符串，长一些字符串可能会导致栈上的其他信息被覆盖。</p><p>通过汇编代码，可以发现实际上栈上分配了24个字节的存储空间，栈的数据分布如下</p><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>|_______________________________| -|</pre></td></tr><tr><td data-num=2></td><td><pre>|                               | -|——————————|</pre></td></tr><tr><td data-num=3></td><td><pre>|                               | —|          |Stack frame for caller</pre></td></tr><tr><td data-num=4></td><td><pre>|_______________________________| -|——————————|</pre></td></tr><tr><td data-num=5></td><td><pre>|		Return Address          | -| ← <span class="token comment">%rsp+24</span></pre></td></tr><tr><td data-num=6></td><td><pre>|_______________________________| -| -|</pre></td></tr><tr><td data-num=7></td><td><pre>|                               |    -|---------|</pre></td></tr><tr><td data-num=8></td><td><pre>|_______________________________|    -|         |Stack frame for echo</pre></td></tr><tr><td data-num=9></td><td><pre>|___|___|___|___|___|___|___|___|    -|         |</pre></td></tr><tr><td data-num=10></td><td><pre>|<span class="token punctuation">[</span>7<span class="token punctuation">]</span>|<span class="token punctuation">[</span>6<span class="token punctuation">]</span>|<span class="token punctuation">[</span>5<span class="token punctuation">]</span>|<span class="token punctuation">[</span>4<span class="token punctuation">]</span>|<span class="token punctuation">[</span>3<span class="token punctuation">]</span>|<span class="token punctuation">[</span>2<span class="token punctuation">]</span>|<span class="token punctuation">[</span>1<span class="token punctuation">]</span>|<span class="token punctuation">[</span>0<span class="token punctuation">]</span>|    -|---------| ← buf=<span class="token comment">%rsp</span></pre></td></tr><tr><td data-num=11></td><td><pre>|___|___|___|___|___|___|___|___|    -|</pre></td></tr></table></figure><p>字符数组位于栈顶的位置，实际上当输入字符串的长度不超过23时，不会发生严重的后果，超过以后，返回地址以及更多的状态信息会被破坏，那么返回指令会导致程序跳转到一个完全意想不到的地方。历史上许多计算机病毒就是利用缓冲区溢出的方式对计算机系统进行攻击的，针对缓冲区溢出的攻击，现在编译器和操作系统实现了很多机制，来限制入侵者通过这种攻击方式来获得系统控制权，例如栈随机化，栈破坏检测以及限制可执行代码区域等。</p><p><font size=3><ins><strong>栈随机化(Stack Randomization)</strong></ins></font></p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> local<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"local at %p\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>local<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在过去，程序的栈地址非常容易预测，如果一个攻击者可以确定一个web服务器所使用的栈空间，那就可以设计一个病毒程序来攻击多台机器。栈随机化的思想是栈的位置在程序每次运行时都有变化，以上代码是简单的打印main函数中局部变量local的地址，每次运行打印结果都可能不同。在64位linux系统上，地址的范围<code>0x7fff0001b698 ~ 0x7ffffffaa4a8</code>，因此，采用了栈随机化的机制，即使许多机器都运行相同的代码，它们的栈地址也是不同的。</p><p>在linux系统中，栈随机化已成为标准行为，它属于<strong>地址空间布局随机化</strong>的一种，简称ASLR。采用ASLR，每次运行时程序的不同部分都会被加载到内存的不同区域，这类技术的应用增加了系统的安全性，降低了病毒的传播速度。</p><p><font size=3><ins><strong>栈破坏检测(Stack Corruption Detection)</strong></ins></font></p><p>编译器会在产生的汇编代码中加入一种栈保护者的机制来检测缓冲区越界，就是在缓冲区与栈保护的状态值之间存储一个特殊值，这个特殊值被称作金丝雀值，之所以叫这个名字，是由于从前煤矿工人会根据金丝雀的叫声来判断煤矿中有毒气体的含量。金丝雀值是每次程序运行时随机产生的，在函数返回之前，检测金丝雀值是否被修改来判断是否遭受攻击。</p><p>通过汇编代码看一下编译器是如何避免栈溢出攻击的，</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">echo:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	subq <span class="token number">$24</span>,<span class="token operator">%</span><span class="token register variable">rsp</span></pre></td></tr><tr><td data-num=3></td><td><pre>	movq <span class="token operator">%</span><span class="token register variable">fs</span>:<span class="token number">40</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=4></td><td><pre>	movq <span class="token operator">%</span><span class="token register variable">rax</span>,<span class="token number">8</span>(<span class="token operator">%</span><span class="token register variable">rsp</span>)</pre></td></tr><tr><td data-num=5></td><td><pre>	xorl <span class="token operator">%</span><span class="token register variable">eax</span>,<span class="token operator">%</span><span class="token register variable">eax</span></pre></td></tr><tr><td data-num=6></td><td><pre>	movq <span class="token operator">%</span><span class="token register variable">rsp</span>,<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=7></td><td><pre>	call gets</pre></td></tr><tr><td data-num=8></td><td><pre>	movq <span class="token operator">%</span><span class="token register variable">rsp</span>,<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=9></td><td><pre>	call puts</pre></td></tr><tr><td data-num=10></td><td><pre>	movq <span class="token number">8</span>(<span class="token operator">%</span><span class="token register variable">rsp</span>),<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=11></td><td><pre>	xorq <span class="token operator">%</span><span class="token register variable">fs</span>:<span class="token number">40</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=12></td><td><pre>	je .L9</pre></td></tr><tr><td data-num=13></td><td><pre>	call __stack_chk_fail</pre></td></tr><tr><td data-num=14></td><td><pre><span class="token label function">.L9:</span></pre></td></tr><tr><td data-num=15></td><td><pre>	addq <span class="token number">$24</span>,<span class="token operator">%</span><span class="token register variable">rsp</span></pre></td></tr><tr><td data-num=16></td><td><pre>	ret</pre></td></tr></table></figure><p><code>movq %fs:40,%rax</code>与<code>movq %rax,8(%rsp)</code>是从内存中读取一个数值，然后将该数值放到栈上，其中这个数值就是金丝雀值，存放的位置与程序中定义的缓冲区是相邻的，其中指令源操作数<code>%fs:40</code>可以简单的理解为一个内存地址，这个内存地址属于特殊的段，被操作系统标记为<code>只读</code>，因此，攻击者是无法修改金丝雀值的，函数返回之前，可以通过指令xor来检查金丝雀值是否被更改。如果金丝雀值被更改，那么程序就会调用一个错误处理例程，如果金丝雀值被更改，那么程序就会调用一个错误处理例程。如果没有被更改，程序就正常执行。</p><p><font size=3><ins><strong>限制可执行代码区域(Limiting Executable Code Regions)</strong></ins></font></p><p>用于消除攻击者向系统插入可执行代码的能力。</p><p>以前，<code>x86</code>的处理器将可读和可执行的访问控制合并成一位标志，所以可读的内存页也都是可执行的，所以可读的内存页也都是可执行的。由于栈上的数据需要被读写，因此栈上的数据也是可执行的，虽然实现了一些机制能够限制一些页可读且不可执行，但是这些机制通常会带来严重的性能损失。后来，处理器的内存保护引入了不可执行位，将可读和可执行访问模式分开了。有了这个特性，栈可以被标记为可读和可写，但是不可执行。检查页是否可执行由硬件来完成，效率上没有损失。</p><p>以上为三种常用机制来减少针对缓冲区溢出的攻击，这三种机制，都不需要开发者做任何额外的工作，都是通过编译器和操作系统来实现的。单独每一种机制都能降低漏洞的等级，组合起来使用会更加有效，但仍然由方法能够对计算机进行攻击。</p><div class=tags><a href=/tags/computer-basic/ rel=tag><i class="ic i-tag"></i> 计算机基础</a></div></div><footer><div class=meta><span class=item><span class=icon><i class="ic i-calendar-check"></i></span> <span class=text>更新于</span> <time title="修改时间：2025-09-19 22:25:08" itemprop=dateModified datetime=2025-09-19T22:25:08+08:00>2025-09-19</time></span><span class=item data-path=/computer-science/computer-basic/composition/ccppart1/ title=阅读次数><span class=icon><i class="ic i-eye"></i></span> <span class=text>阅读次数</span><span class=waline-pageview-count></span> <span class=text>次</span></span></div><div id=copyright><ul><li class=author><strong>本文作者：</strong> ReverseSacle <i class="ic i-at"><em>@</em></i>逆转天平</li><li class=link><strong>本文链接：</strong> <a href=https://www.reversesacle.com/computer-science/computer-basic/composition/ccppart1/ title=计算机组成原理-CSAPP-第一部分>https://www.reversesacle.com/computer-science/computer-basic/composition/ccppart1/</a></li><li class=license><strong>版权声明：</strong> 本站所有文章除特别声明外，均采用 <span class=exturl data-url=aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class=post-nav><div class="item left"><a href=/computer-science/programming/web/nginx/ itemprop=url rel=prev data-background-image=https:&#x2F;&#x2F;resa-imgs.oss-accelerate.aliyuncs.com&#x2F;img&#x2F;acg16.webp title=Nginx基础><span class=type>上一篇</span><span class=category><i class="ic i-flag"></i> web</span><h3>Nginx基础</h3></a></div><div class="item right"><a href=/computer-science/computer-basic/composition/ccppart2/ itemprop=url rel=next data-background-image=https:&#x2F;&#x2F;resa-imgs.oss-accelerate.aliyuncs.com&#x2F;img&#x2F;acg21.webp title=计算机组成原理-CSAPP-第二部分><span class=type>下一篇</span><span class=category><i class="ic i-flag"></i> 计算机组成原理</span><h3>计算机组成原理-CSAPP-第二部分</h3></a></div></div><div class=wrap id=comments><div id=waline-comment></div></div></div><div id=sidebar><div class=inner><div class=panels><div class=inner><div class="contents panel pjax" data-title=文章目录><ol class=toc><li class="toc-item toc-level-2"><a class=toc-link href=#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8a-tour-of-computer-system><span class=toc-number>1.</span> <span class=toc-text>计算机系统漫游(A Tour of Computer System)</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0><span class=toc-number>1.1.</span> <span class=toc-text>编译原理概述</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83%E5%A4%84%E7%90%86%E5%99%A8%E6%A6%82%E8%BF%B0central-processing-unit-cpu><span class=toc-number>1.2.</span> <span class=toc-text>中央处理单元(处理器)概述(Central Processing Unit - CPU)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88><span class=toc-number>1.3.</span> <span class=toc-text>可执行程序执行时发生了什么</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84memory-hierarchy><span class=toc-number>1.4.</span> <span class=toc-text>计算机内存层次结构(Memory Hierarchy)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0><span class=toc-number>1.5.</span> <span class=toc-text>进程概述</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%A6%82%E8%BF%B0><span class=toc-number>1.6.</span> <span class=toc-text>虚拟内存概述</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E5%9C%A8%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F><span class=toc-number>1.7.</span> <span class=toc-text>通过网络在远程主机上运行程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86representing-and-manipulating-information><span class=toc-number>2.</span> <span class=toc-text>信息的表示和处理(Representing and Manipulating Information)</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8information-storage><span class=toc-number>2.1.</span> <span class=toc-text>信息存储(Information Storage)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%95%B4%E6%95%B0%E8%A1%A8%E7%A4%BAinteger-representations><span class=toc-number>2.2.</span> <span class=toc-text>整数表示(Integer Representations)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97integer-arithmetic><span class=toc-number>2.3.</span> <span class=toc-text>整数运算(Integer Arithmetic)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%B5%AE%E7%82%B9%E6%95%B0floatin-point><span class=toc-number>2.4.</span> <span class=toc-text>浮点数(Floatin Point)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BAmachine-level-representation-of-programs><span class=toc-number>3.</span> <span class=toc-text>程序的机器级表示(Machine-Level Representation of Programs)</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4><span class=toc-number>3.1.</span> <span class=toc-text>寄存器与数据传送指令</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%A0%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4><span class=toc-number>3.2.</span> <span class=toc-text>栈与数据传送指令</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%AE%97%E6%9C%AF%E5%92%8C%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4><span class=toc-number>3.3.</span> <span class=toc-text>算术和逻辑操作指令</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%9D%A1%E4%BB%B6%E7%A0%81><span class=toc-number>3.4.</span> <span class=toc-text>指令与条件码</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%BE%AA%E7%8E%AF><span class=toc-number>3.5.</span> <span class=toc-text>跳转指令与循环</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%BF%87%E7%A8%8Bprocedures><span class=toc-number>3.6.</span> <span class=toc-text>过程(Procedures)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E8%AE%BF%E9%97%AE><span class=toc-number>3.7.</span> <span class=toc-text>数组的分配和访问</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E8%81%94%E5%90%88%E4%BD%93><span class=toc-number>3.8.</span> <span class=toc-text>结构体与联合体</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA><span class=toc-number>3.9.</span> <span class=toc-text>缓冲区溢出</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title=系列文章><ul><li class=active><a href=/computer-science/computer-basic/composition/ccppart1/ rel=bookmark title=计算机组成原理-CSAPP-第一部分>计算机组成原理-CSAPP-第一部分</a></li><li><a href=/computer-science/computer-basic/composition/ccppart2/ rel=bookmark title=计算机组成原理-CSAPP-第二部分>计算机组成原理-CSAPP-第二部分</a></li><li><a href=/computer-science/computer-basic/composition/ccppart3/ rel=bookmark title=计算机组成原理-CSAPP-第三部分>计算机组成原理-CSAPP-第三部分</a></li><li><a href=/computer-science/computer-basic/composition/ccppart4/ rel=bookmark title=计算机组成原理-CSAPP-第四部分>计算机组成原理-CSAPP-第四部分</a></li></ul></div><div class="overview panel" data-title=站点概览><div class=author itemprop=author itemscope itemtype=http://schema.org/Person><img class=image itemprop=image alt=ReverseSacle data-src=/images/avatar.webp><p class=name itemprop=name>ReverseSacle</p><div class=description itemprop=description>知识书库 & 学习点滴</div></div><nav class=state><div class="item posts"><a href=/archives/ ><span class=count>186</span> <span class=name>文章</span></a></div><div class="item categories"><a href=/categories/ ><span class=count>52</span> <span class=name>分类</span></a></div><div class="item tags"><a href=/tags/ ><span class=count>18</span> <span class=name>标签</span></a></div></nav><div class=social><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JldmVyc2VTYWNsZQ==" title=https:&#x2F;&#x2F;github.com&#x2F;ReverseSacle><i class="ic i-github"></i></span><span class="exturl item email" data-url="bWFpbHRvOnByaXZhdGVAcmV2ZXJzZXNhY2xlLmNvbQ==" title=mailto:private@reversesacle.com><i class="ic i-envelope"></i></span></div><ul class=menu><li class=item><a href=/ rel=section><i class="ic i-home"></i> 首页</a></li><li class="item dropdown"><a href=javascript:void(0);><i class="ic i-feather"></i> 文章</a><ul class=submenu><li class=item><a href=/archives/ rel=section><i class="ic i-list-alt"></i> 归档</a></li><li class=item><a href=/categories/ rel=section><i class="ic i-th"></i> 分类</a></li><li class=item><a href=/tags/ rel=section><i class="ic i-tags"></i> 标签</a></li></ul></li><li class=item><a href=/about/ rel=section><i class="ic i-user"></i> 关于</a></li><li class=item><a href=/friend-links/ rel=section><i class="ic i-heart"></i> 友链</a></li></ul></div></div></div><ul id=quick><li class="prev pjax"><a href=/computer-science/programming/web/nginx/ rel=prev title=上一篇><i class="ic i-chevron-left"></i></a></li><li class=up><i class="ic i-arrow-up"></i></li><li class=down><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href=/computer-science/computer-basic/composition/ccppart2/ rel=next title=下一篇><i class="ic i-chevron-right"></i></a></li><li class=percent></li></ul></div></div><div class=dimmer></div></div></main><footer id=footer><div class=inner><div class=widgets><div class="rpost pjax"><h2>随机文章</h2><ul><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/database/ title="分类于 数据库">数据库</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/database/mysql/ title="分类于 MySQL">MySQL</a></div><span><a href=/computer-science/programming/database/mysql/mspart1/ title=MySQL数据库基础-第一部分>MySQL数据库基础-第一部分</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/computer-basic/ title="分类于 计算机基础">计算机基础</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/computer-basic/computer-network/ title="分类于 计算机网络">计算机网络</a></div><span><a href=/computer-science/computer-basic/network/nwpart3/ title=计算机网络-第三部分>计算机网络-第三部分</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/android-development/ title="分类于 安卓开发">安卓开发</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/android-development/automation-testing/ title="分类于 自动化测试">自动化测试</a></div><span><a href=/computer-science/programming/android-development/automation-testing/adb-integration/ title="Android Debug Bridge(adb)教程">Android Debug Bridge(adb)教程</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/seqlist/ title="分类于 顺序表">顺序表</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/seqlist/search/ title=顺序表-查找>顺序表-查找</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/network-programming/ title="分类于 网络编程">网络编程</a></div><span><a href=/computer-science/programming/network-programming/thread-synchronization/ title=Linux线程同步>Linux线程同步</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a></div><span><a href=/computer-science/programming/c-language/c-data-structure/linear-structure/dynamic-seqstring/ title=C语言-字符动态结构存储>C语言-字符动态结构存储</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/c-data-structure/ title="分类于 C语言数据结构">C语言数据结构</a></div><span><a href=/computer-science/programming/c-language/c-data-structure/linklist/ title=线性表之链表>线性表之链表</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/stack/ title="分类于 栈">栈</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/stack/trick/ title=栈基础技巧>栈基础技巧</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/network-programming/ title="分类于 网络编程">网络编程</a></div><span><a href=/computer-science/programming/network-programming/ubuntu-obs-server/ title="Ubuntu服务器OBS Studio配置">Ubuntu服务器OBS Studio配置</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/dev-tool/ title="分类于 开发工具">开发工具</a></div><span><a href=/computer-science/programming/dev-tool/git/ title=分布式版本控制系统Git>分布式版本控制系统Git</a></span></li></ul></div><div><h2>最新评论</h2><ul id=waline-recent></ul></div></div><div class=status><div class=copyright>&copy; 2021 – <span itemprop=copyrightYear>2025</span><span class=with-love><i class="ic i-sakura rotate"></i></span> <span class=author itemprop=copyrightHolder>ReverseSacle @ ReverseSacle-Blog</span></div><div class=count><i class="ic i-clock" aria-hidden=true></i> <span id=time align=center>载入时间中...<script defer>var now=new Date;function createtime(){var n=new Date("2021-11-16 22:30:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("time").innerHTML="已经过 "+dnum+" 天 "+hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></span><span class=post-meta-item-icon>|&nbsp<i class="ic i-chart-area"></i></span> <span title=站点总字数>2.1m 字</span> <span class=post-meta-item-icon>|&nbsp<i class="ic i-coffee"></i></span> <span title=站点阅读时长>40:40</span></div></div></div></footer></div><script data-config>var LOCAL={path:"computer-science/computer-basic/composition/ccppart1/",favicon:{show:"ReverseSacle-Blog",hide:"ReverseSacle-Blog"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},waline:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src=https://polyfill.alicdn.com/v3/polyfill.min.js></script><script src=https://cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1.16.0/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js></script><script src=/js/app.js></script></body></html>