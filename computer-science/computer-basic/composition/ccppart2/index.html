<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content=#222><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=icon type=image/ico sizes=48x48 href=/images/favicon.ico><link rel=alternate type=application/rss+xml title=逆转天平 href=https://www.reversesacle.com/rss.xml><link rel=alternate type=application/atom+xml title=逆转天平 href=https://www.reversesacle.com/atom.xml><link rel=alternate type=application/json title=逆转天平 href=https://www.reversesacle.com/feed.json><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel=stylesheet href=/css/app.css><meta name=description content=计算机基础><link rel=canonical href=https://www.reversesacle.com/computer-science/computer-basic/composition/ccppart2/ ><title>计算机组成原理-CSAPP-第二部分 - 计算机组成原理 - 计算机基础 - 计算机科学 | ReverseSacle-Blog</title><meta name=generator content="Hexo 6.3.0"></head><body itemscope itemtype=http://schema.org/WebPage><div id=loading><div class=dotloader><div class=dot></div><div class=dot></div><div class=dot></div><div class=dot></div><div class=dot></div></div></div><div id=container><header id=header itemscope itemtype=http://schema.org/WPHeader><div class=inner><div id=brand><div class=pjax><h1 itemprop="name headline">计算机组成原理-CSAPP-第二部分</h1><div class=meta><span class=item title="创建时间：2023-10-09 18:50:12"><span class=icon><i class="ic i-calendar"></i></span> <span class=text>发表于</span> <time itemprop="dateCreated datePublished" datetime=2023-10-09T18:50:12+08:00>2023-10-09</time></span><span class=item title=本文字数><span class=icon><i class="ic i-pen"></i></span> <span class=text>本文字数</span> <span>36k</span> <span class=text>字</span></span><span class=item title=阅读时长><span class=icon><i class="ic i-clock"></i></span> <span class=text>阅读时长</span> <span>42 分钟</span></span></div></div></div><nav id=nav><div class=inner><div class=toggle><div class=lines role=navigation aria-label=切换导航栏><span class=line></span><span class=line></span><span class=line></span></div></div><ul class=menu><li class="item title"><a href=/ rel=start>ReverseSacle-Blog</a></li></ul><ul class=right><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id=imgs class=pjax><ul><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg19.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg15.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg14.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg11.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg16.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg17.webp></li></ul></div></header><div id=waves><svg class=waves xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink viewBox="0 24 150 28" preserveAspectRatio=none shape-rendering=auto><defs><path id=gentle-wave d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352z"/></defs><g class=parallax><use xlink:href=#gentle-wave x=48 y=0 /><use xlink:href=#gentle-wave x=48 y=3 /><use xlink:href=#gentle-wave x=48 y=5 /><use xlink:href=#gentle-wave x=48 y=7 /></g></svg></div><main><div class=inner><div id=main class=pjax><div class="article wrap"><div class=breadcrumb itemscope itemtype=https://schema.org/BreadcrumbList><i class="ic i-home"></i> <span><a href=/ >首页</a></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/ itemprop=item rel=index title="分类于 计算机科学"><span itemprop=name>计算机科学</span></a><meta itemprop=position content=1></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/computer-basic/ itemprop=item rel=index title="分类于 计算机基础"><span itemprop=name>计算机基础</span></a><meta itemprop=position content=2></span><i class="ic i-angle-right"></i> <span class=current itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/computer-basic/computer-composition-principles/ itemprop=item rel=index title="分类于 计算机组成原理"><span itemprop=name>计算机组成原理</span></a><meta itemprop=position content=3></span></div><article itemscope itemtype=http://schema.org/Article class="post block" lang=zh-CN><link itemprop=mainEntityOfPage href=https://www.reversesacle.com/computer-science/computer-basic/composition/ccppart2/ ><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content=/images/avatar.webp><meta itemprop=name content=ReverseSacle><meta itemprop=description content="所见即所得，所思即所行, 知识书库 & 学习点滴"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content=逆转天平></span><div class="body md" itemprop=articleBody><h2 id=处理器体系结构processor-architecture><a class=anchor href=#处理器体系结构processor-architecture>#</a> 处理器体系结构(Processor Architecture)</h2><h3 id=指令系统结构instruction-set-architecture><a class=anchor href=#指令系统结构instruction-set-architecture>#</a> 指令系统结构(Instruction Set Architecture)</h3><p>指令系统是计算机软件和硬件交互的接口，程序员根据指令系统设计软件，处理器设计人员根据指令系统实现硬件，由于<code>x86-64</code>指令系统过于复杂，为了方便学习和理解，CSAPP中参照<code>x86-64</code>的指令系统，自定义了一个相对简单的指令系统<code>Y86-64</code>，该指令系统包括定义各种状态单元，指令集以及它们的编码，编程规范以及异常事件处理这几部分。</p><p>什么是程序员的可见状态，这里的程序员即可以是用汇编代码写程序的人，也可以是产生机器级代码的编译器，可见状态是指每条指令都会去读取或修改处理器的某些部分，例如内存，寄存器，条件码，程序计数器以及程序状态等。</p><p>在<code>Y86-64</code>指令系统中，寄存器<code>%rsp</code>也是被定义为栈指针，至于其他14个寄存器没有固定的含义。除此之外，<code>Y86-64</code>的指令系统还简化了条件码寄存器，仅保留了3个条件码，分别为零标志(ZF)，符号标志(SF)和溢出标志(OF)。程序计数器PC是用来存放当前正在执行指令的地址，注意是指令的地址，不是指令的内容。对于程序的执行状态，这里引入状态码来表示。</p><p>在目前这个阶段，可以简单的认为虚拟内存系统，向<code>Y86-64</code>程序提供了一个单一的字节数组映射。</p><p>类比<code>x86-64</code>的指令集，<code>Y86-64</code>指令集做了一些相应的简化，将<code>x86-64</code>中的movq指令分成了四种不同的指令，<code>rrmovq</code>，<code>irmovq</code>，<code>rmmovq</code>，<code>mrmovq</code>，重定义后的数据传送指令显示的指明了源操作数和目的操作数的格式，指令名字的第一个字母表明了源操作数的类型，源操作数可以是立即数<code>i</code>，寄存器<code>r</code>或内存<code>m</code>，指令名字的第二个字母指明了目的操作数的类型，目的操作数可以是寄存器和内存，这样设计的目的主要是为了降低处理器实现的复杂度。</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>rrmovq rA,rB <span class="token operator">|</span><span class="token number">2</span><span class="token operator">|</span><span class="token number">0</span><span class="token operator">|</span>rA<span class="token operator">|</span>rB<span class="token operator">|</span></pre></td></tr><tr><td data-num=2></td><td><pre>irmovq V,rB	 <span class="token operator">|</span><span class="token number">3</span><span class="token operator">|</span><span class="token number">0</span><span class="token operator">|</span>F<span class="token operator">|</span>rB<span class="token operator">|</span>   V   <span class="token operator">|</span></pre></td></tr><tr><td data-num=3></td><td><pre>rmmovq rA,D(rB) <span class="token operator">|</span><span class="token number">4</span><span class="token operator">|</span><span class="token number">0</span><span class="token operator">|</span>rA<span class="token operator">|</span>rB<span class="token operator">|</span>   D   <span class="token operator">|</span></pre></td></tr><tr><td data-num=4></td><td><pre>mrmovq D(rB),rA <span class="token operator">|</span><span class="token number">5</span><span class="token operator">|</span><span class="token number">0</span><span class="token operator">|</span>rA<span class="token operator">|</span>rB<span class="token operator">|</span>   D   <span class="token operator">|</span></pre></td></tr></table></figure><p>对上述数据传送指令进行编码，每条指令的第一个字节表明指令的类型。这个字节分为两部分，每一部分占4个比特位。高4位表示指令代码，低4位表示指令功能。对于定义的数据传送指令，不同的指令代码表示不同的指令，指令的功能部分都为0，当指令中有寄存器类型的操作数时，会附加一个字节，这个字节被称为寄存器指示符字节，它用来指定一个或两个寄存器，因此还需要对寄存器进行编码，在<code>Y86-64</code>的指令系统中，定义了15个寄存器，虽然每个寄存器定义了不同的名字，但是还需要为每一个寄存器指定一个编号。寄存器的编号可以用十六进制数<code>0~0xE</code>来表示，具体如下</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/1.webp alt=""></p><p>如果指令中某个寄存器字段的值为<code>0xF</code>，表示此处没有寄存器操作数。</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>OPq rA,rB <span class="token operator">|</span><span class="token number">6</span><span class="token operator">|</span>fn<span class="token operator">|</span>rA<span class="token operator">|</span>fB<span class="token operator">|</span></pre></td></tr><tr><td data-num=2></td><td><pre>addq <span class="token operator">|</span><span class="token number">6</span><span class="token operator">|</span><span class="token number">0</span><span class="token operator">|</span>		subq <span class="token operator">|</span><span class="token number">6</span><span class="token operator">|</span><span class="token number">1</span><span class="token operator">|</span></pre></td></tr><tr><td data-num=3></td><td><pre>andq <span class="token operator">|</span><span class="token number">6</span><span class="token operator">|</span><span class="token number">2</span><span class="token operator">|</span>		xorq <span class="token operator">|</span><span class="token number">6</span><span class="token operator">|</span><span class="token number">3</span><span class="token operator">|</span></pre></td></tr></table></figure><p>例如irmovq指令中第一个操作数是立即数，所以此处用0xF来填充，在<code>Y86-64</code>指令系统中，定义了四条整数操作指令，它们只能对寄存器数据进行操作，而<code>x86-64</code>还允许对内存数据进行操作，由于这四条指令属于同一类型，所以指令代码是一样的，不同的是功能部分。</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>jxx Dest <span class="token operator">|</span><span class="token number">7</span><span class="token operator">|</span>fn<span class="token operator">|</span>  Dest  <span class="token operator">|</span></pre></td></tr><tr><td data-num=2></td><td><pre>jmp <span class="token operator">|</span><span class="token number">7</span><span class="token operator">|</span><span class="token number">0</span><span class="token operator">|</span>	jle <span class="token operator">|</span><span class="token number">7</span><span class="token operator">|</span><span class="token number">1</span><span class="token operator">|</span>	jl <span class="token operator">|</span><span class="token number">7</span><span class="token operator">|</span><span class="token number">2</span><span class="token operator">|</span>	je <span class="token operator">|</span><span class="token number">7</span><span class="token operator">|</span><span class="token number">3</span><span class="token operator">|</span></pre></td></tr><tr><td data-num=3></td><td><pre>jne <span class="token operator">|</span><span class="token number">7</span><span class="token operator">|</span><span class="token number">4</span><span class="token operator">|</span>	jge <span class="token operator">|</span><span class="token number">7</span><span class="token operator">|</span><span class="token number">5</span><span class="token operator">|</span>	jg <span class="token operator">|</span><span class="token number">7</span><span class="token operator">|</span><span class="token number">6</span><span class="token operator">|</span></pre></td></tr></table></figure><p>跳转指令一共有7条，跳转指令一共有7条，跳转的条件与<code>x86-64</code>中的跳转指令是一样的，都是根据条件码的某种结合来判断是否进行跳转。</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>cmovxx rA,rB <span class="token operator">|</span><span class="token number">2</span><span class="token operator">|</span>fn<span class="token operator">|</span>rA<span class="token operator">|</span>fB<span class="token operator">|</span></pre></td></tr><tr><td data-num=2></td><td><pre>rrmovq <span class="token operator">|</span><span class="token number">2</span><span class="token operator">|</span><span class="token number">0</span><span class="token operator">|</span>  cmovle <span class="token operator">|</span><span class="token number">2</span><span class="token operator">|</span><span class="token number">1</span><span class="token operator">|</span> cmovl <span class="token operator">|</span><span class="token number">2</span><span class="token operator">|</span><span class="token number">2</span><span class="token operator">|</span> cmove <span class="token operator">|</span><span class="token number">2</span><span class="token operator">|</span><span class="token number">3</span><span class="token operator">|</span></pre></td></tr><tr><td data-num=3></td><td><pre>cmovne <span class="token operator">|</span><span class="token number">2</span><span class="token operator">|</span><span class="token number">4</span><span class="token operator">|</span>  cmovge <span class="token operator">|</span><span class="token number">2</span><span class="token operator">|</span><span class="token number">5</span><span class="token operator">|</span> cmovg <span class="token operator">|</span><span class="token number">2</span><span class="token operator">|</span><span class="token number">6</span><span class="token operator">|</span></pre></td></tr></table></figure><p>条件传送指令有6条，它与数据传送指令<code>rrmovq</code>有相同的指令格式，但是只有条件码满足条件时，才会更新目的寄存器的值。</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>halt <span class="token operator">|</span><span class="token number">0</span><span class="token operator">|</span><span class="token number">0</span><span class="token operator">|</span>	nop <span class="token operator">|</span><span class="token number">1</span><span class="token operator">|</span><span class="token number">0</span><span class="token operator">|</span></pre></td></tr><tr><td data-num=2></td><td><pre>call Dest <span class="token operator">|</span><span class="token number">8</span><span class="token operator">|</span><span class="token number">0</span><span class="token operator">|</span>  Dest  <span class="token operator">|</span></pre></td></tr><tr><td data-num=3></td><td><pre>ret <span class="token operator">|</span><span class="token number">9</span><span class="token operator">|</span><span class="token number">0</span><span class="token operator">|</span></pre></td></tr><tr><td data-num=4></td><td><pre>pushq rA <span class="token operator">|</span>A<span class="token operator">|</span><span class="token number">0</span><span class="token operator">|</span>rA<span class="token operator">|</span>F<span class="token operator">|</span>	popq rA <span class="token operator">|</span>B<span class="token operator">|</span><span class="token number">0</span><span class="token operator">|</span>rA<span class="token operator">|</span>F<span class="token operator">|</span></pre></td></tr></table></figure><p>停止指令<code>halt</code>可以使整个系统暂停运行。<code>nop</code>指令表示一个空操作。它们的指令编码只有一个字节，比较简单，call指令与ret指令分别实现函数调用和返回，push指令和pop指令分别实现入栈和出栈的操作，这四条指令与<code>x86-64</code>中的指令定义类似。</p><p>综上所述，<code>Y86-64</code>的指令集以及编码规则的定义就完成了。通过上述定义的指令编码规则，可以将<code>Y86-64</code>的汇编代码翻译成二进制表示。</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>rmmovq <span class="token operator">%</span><span class="token register variable">rsp</span>,<span class="token number">0x123456789abcd</span>(<span class="token operator">%</span><span class="token register variable">rdx</span>)</pre></td></tr><tr><td data-num=2></td><td><pre>rmmovq rA,D(rB) <span class="token operator">|</span><span class="token number">4</span><span class="token operator">|</span><span class="token number">0</span><span class="token operator">|</span>rA<span class="token operator">|</span>rB<span class="token operator">|</span>  D  <span class="token operator">|</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token label function">result:</span> <span class="token operator">|</span><span class="token number">40</span><span class="token operator">|</span>		<span class="token operator">|</span></pre></td></tr></table></figure><p>根据<code>rmmovq</code>指令的编码定义，指令二进制表示的第一个字节为<code>0x40</code>。接着是指令的操作数部分，根据寄存器的编号规则，寄存器<code>%rsp</code>对应十六进制数<code>0x4</code>，基址寄存器rdx对应<code>0x2</code>。因此，可以得到第二个字节的编码为<code>0x42</code>，指令编码中偏移量占8个字节。</p><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>result: |40|42|		|</pre></td></tr></table></figure><p>需要在该偏移量的前面通过填0来补齐8个字节。由于<code>x86-64</code>采用小端法存储，所以需要对偏移量进行字节反序操作，最终得到了长度为10个字节的二进制指令。</p><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>00 01 23 45 67 89 ab cd</pre></td></tr><tr><td data-num=2></td><td><pre>result: |40|42|cd|ab|89|67|45|23|01|00|</pre></td></tr></table></figure><p><font size=3><ins><strong>程序的状态码</strong></ins></font></p><p>它描述了程序执行的总体状态，</p><p>当代码值为1时，表示程序正常执行，而其他三个代码表示程序发生了某种类型的异常，</p><p>当代码值为2，表示处理器执行了一条停止指令<code>halt</code>，</p><p>当代码值为3，表示程序正试图从非法地址读取数据或向非法地址写入数据，</p><p>当代码值为4，表示程序遇到了非法指令。</p><p>对于<code>Y86-64</code>，当遇到异常情况时，就简单的让处理器停止执行指令，然而在成熟完整的设计中，处理器遇到异常会调用异常处理程序。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/2.webp alt=""></p><h3 id=数字电路与处理器设计><a class=anchor href=#数字电路与处理器设计>#</a> 数字电路与处理器设计</h3><p>程序寄存器，从本质上进它属于处理器内部的存储单元，通常将寄存器的集合称为寄存器文件，有的资料也称寄存器堆。</p><p>在处理器内部，寄存器文件和算术逻辑单元ALU是串联的，寄存器文件的输出端口与ALU的输入端口相连，例如执行<code>subq %rax,%rdx</code>这条减法指令，ALU从寄存器文件中读取操作数，然后执行减法操作，最后将计算结果写入到寄存器文件中。</p><p>这里以寄存器文件为例，刨析它的具体实现来阐述处理器设计与数字电路之间关系。</p><p>这里展示一个寄存器文件的功能表述，它有一个读端口和一个写端口，端口的数据位宽是64位。这里规矩读写操作共用地址线，由于定义了15个程序寄存器，因此地址线的宽度设计成4位即可满足寻址的要求。</p><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>addr -->  |---------------|</pre></td></tr><tr><td data-num=2></td><td><pre>we_ -->   |               | 64</pre></td></tr><tr><td data-num=3></td><td><pre>      64  | Register File |---->d_out</pre></td></tr><tr><td data-num=4></td><td><pre>d_in ---> |               |</pre></td></tr><tr><td data-num=5></td><td><pre>clock --> |               |</pre></td></tr><tr><td data-num=6></td><td><pre>reset --> |---------------|</pre></td></tr></table></figure><p>此外，还有时钟信号(clock)，复位信号(rest)以及写使能信号(<code>we_</code>)。根据上述功能定义，可以使用硬件描述语言(HDL)对寄存器文件进行行为级建模，常用的硬件描述语言有两种，最常用的是<code>Verilog</code>，另外一种是<code>VHDL</code>。</p><figure class="highlight verilog"><figcaption data-lang=verilog></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">module</span> <span class="token function">regfile</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">output</span> <span class="token keyword">reg</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_out<span class="token punctuation">,</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">input</span> <span class="token keyword">wire</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_in<span class="token punctuation">,</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">input</span> <span class="token keyword">wire</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> addr<span class="token punctuation">,</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">input</span> <span class="token keyword">wire</span> clock<span class="token punctuation">,</span>we_<span class="token punctuation">,</span>erset_</pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">reg</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>	regfile<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">assign</span> data_out <span class="token operator">=</span> regfile<span class="token punctuation">[</span>addr<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token keyword">endmodule</span></pre></td></tr></table></figure><p>这段Verilog程序就是对寄存器文件的描述，采用电子设计自动化EDA工具对这段程序进行逻辑综合，得到的电路就能实现预期的功能。逻辑综合的过程与编译有点类似。</p><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>Verilog程序  |——————————------—|Netlist(网表)</pre></td></tr><tr><td data-num=2></td><td><pre>------------->| Logic Synthesis |-----------></pre></td></tr><tr><td data-num=3></td><td><pre>              |   (逻辑综合)     |</pre></td></tr><tr><td data-num=4></td><td><pre>              |-----------------|</pre></td></tr><tr><td data-num=5></td><td><pre>			  </pre></td></tr><tr><td data-num=6></td><td><pre>    C程序      |——————————------—----|可执行程序</pre></td></tr><tr><td data-num=7></td><td><pre>------------->| Compilation System  |-----------></pre></td></tr><tr><td data-num=8></td><td><pre>              |      (编译系统)      |</pre></td></tr><tr><td data-num=9></td><td><pre>              |---------------------|</pre></td></tr></table></figure><p>接下来是寄存器的内部结构，当执行读取操作时，使用地址线来传输寄存器的编号，多路选择器根据地址信号筛选出寄存器的值，最终数值会通过输出信号输出，这里暂时将时钟信号和复位信号省去。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/3.webp alt=""></p><p>执行写操作需要确定三个参数，目的寄存器的ID，写入的数据以及是否能够写入，即能不能写，往哪儿写，写什么，输入数据信号线与每一个寄存器单元都相连，这里忽略了数据的位宽。能不能执行写入操作由we信号线来确定，we是write enable的缩写。地址信号线是读操作和写操作共用的，经过地址解析后的信号与we信号共同来确定对哪个寄存器执行写操作。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/4.webp alt=""></p><p><font size=3><ins><strong>数字电路相关知识</strong></ins></font></p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/5.webp alt=""></p><p>逻辑门是数字电路的基本计算单元，例如与门，或门，非门，它们的输出等于输入值按位进行相应的布尔运算，</p><p>逻辑门实际上是由晶体管级电路实现的，在现代计算机中，晶体管通常是指基于(Complementary Metal-Oxide Semiconductor - CMOS，互补金属氧化物半导体)工艺的。CMOS有两种晶体管，一种叫N沟道MOS晶体管，简称N管，另外一种叫P沟道MOS晶体管，简称P管。N管和P管都有3个信号端口，分别为栅极，源极，漏极。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/6.webp alt=""></p><p>可以将一个P管和N管串联起来实现非门，具体实现是将二者的漏极连在一起作为输出，栅极连在一起作为输入，然后将P管的源极接电源，N管的源极接地。当输入为高电平时，N管导通，P管不导通，输出为0；当输入为低电平，P管导通，N管不导通，输出为1，以上为非门的基本组成以及工作原理。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/7.webp alt=""></p><p>在CMOS工艺中，与门和或门实现起来不如非门和或非门高效，在设计CMOS电路的时候最好使用与非门，或非门以及非门来实现，这些基本的门结构都可以通过P管和N管组合来实现。</p><p>使用基本的门电路实现一个多路选择器，以下图中为一个双路多选择器的门级表示，当select等于0时，输入端a的数据可以通过该电路到达输出端；当select等于1时，输入端b的数据会到达输出端，通常多路选择器有多条输入通道和一条输出通道。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/8.webp alt=""></p><p>多路选择器可以实现控制某个特定寄存器的内容传输到ALU的输入端，可以使用基本的门电路实现。通常情况下，寄存器文件内的存储部件是由D触发器来实现的。以下图为一种D触发器的门级实现，图中虚线框内的部分被称为D锁存器。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/9.webp alt=""></p><p>通过以上的两个示例，可以发现逻辑电路可以使用基本的门电路来搭建。很早以前，电路设计是将一个个门电路绘制在图纸上，但随着半导体技术的发展，这种方式很难高效的实现大规模的复杂电路。目前，电路的逻辑设计通常采用硬件描述语言来实现，然后采用电子设计自动化EDA工具进行综合和后端设计。</p><p>接下来为一个D触发器的Verilog实现，</p><figure class="highlight verilog"><figcaption data-lang=verilog></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">module</span> <span class="token function">dflipflop</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">input</span> D<span class="token punctuation">,</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">input</span> C<span class="token punctuation">,</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">input</span> G<span class="token punctuation">,</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">output</span> <span class="token keyword">reg</span> Q</pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> C<span class="token punctuation">)</span> <span class="token keyword">begin</span></pre></td></tr><tr><td data-num=8></td><td><pre>        <span class="token function">if</span><span class="token punctuation">(</span>G<span class="token punctuation">)</span> Q <span class="token operator">&lt;=</span> D<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token keyword">end</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token keyword">endmodule</span></pre></td></tr></table></figure><p>其中dfilpflop表示模块的名称，D，C，G表示输入，Q表示输出。always语句表示当前钟C上升沿的时候，如果G为1，就把输入D的值赋给触发器的输出Q，否则Q保持不变。通过这个例子可以发现用Verilog来描述电路比逻辑门要简单的多，Verilog语言的语法跟C语言有许多类似的地方，但是表达的含义与C语言有着本质的区别，Verilog程序是并行执行的，而C程序是串行执行的。</p><p>组合逻辑(Combinational Logic)电路与时序逻辑(Sequential Logic)电路的区别，这两种电路的主要差异在于是否含有存储单元，其中组合逻辑电路的输出值仅由当前的输入状态来决定，而时序逻辑电路得到输出值不仅与当前输入的状态有关，而且与原来的状态也有关。</p><p>Verilog做设计只用三种语句</p><ul><li><code>assign</code>语句 - 用于描述组合逻辑</li><li><code>always @(posedge clock)</code>语句 - 用于描述时序逻辑，其中<code>posedge clock</code>表示在时钟上升沿的时候变化</li><li>模块调用语句</li></ul><h3 id=y86-64的顺序实现><a class=anchor href=#y86-64的顺序实现>#</a> Y86-64的顺序实现</h3><p><code>Y86-64</code>指令系统做了相应的简化处理，其中指令编码的长度从1个字节到10个字节不等，每条指令都含有一个长度为8个比特位的指令指示符，有的指令含有一个单字节的寄存器指示符，还有的指令含有一个8字节的常数。</p><p>以下为C程序翻译成<code>Y86-64</code>汇编代码</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">long</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token operator">*</span> start<span class="token punctuation">,</span><span class="token keyword">long</span> count<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>        sum <span class="token operator">+=</span> <span class="token operator">*</span>start<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>        start<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>        count<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">sum:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	irmovq <span class="token number">$8</span>,<span class="token operator">%</span><span class="token register variable">r8</span></pre></td></tr><tr><td data-num=3></td><td><pre>	irmovq <span class="token number">$1</span>,<span class="token operator">%</span><span class="token register variable">r9</span></pre></td></tr><tr><td data-num=4></td><td><pre>	xorq <span class="token operator">%</span><span class="token register variable">rax</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=5></td><td><pre>	andq <span class="token operator">%</span><span class="token register variable">rsi</span>,<span class="token operator">%</span><span class="token register variable">rsi</span></pre></td></tr><tr><td data-num=6></td><td><pre>	jmp test</pre></td></tr><tr><td data-num=7></td><td><pre><span class="token label function">loop:</span></pre></td></tr><tr><td data-num=8></td><td><pre>	mrmovq (<span class="token operator">%</span><span class="token register variable">rdi</span>),<span class="token operator">%</span><span class="token register variable">r10</span></pre></td></tr><tr><td data-num=9></td><td><pre>	addq <span class="token operator">%</span><span class="token register variable">r10</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=10></td><td><pre>	...</pre></td></tr></table></figure><p>这段C代码用来计算一个数组的元素之和，指针start指向数组的起始位置，count用来表示数组的长度。</p><p>汇编代码除了数据传送指令，其他的指令与<code>x86-64</code>指令差异不大，使用<code>Y86-64</code>汇编器可以将汇编代码翻译成二进制指令，</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token number">0x056</span>:</pre></td></tr><tr><td data-num=2></td><td><pre><span class="token number">0x056</span>: 30f80800000000000000</pre></td></tr><tr><td data-num=3></td><td><pre><span class="token number">0x060</span>: 30f90100000000000000</pre></td></tr><tr><td data-num=4></td><td><pre><span class="token number">0x06a</span>: <span class="token number">6300</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token number">0x06c</span>: <span class="token number">6266</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token number">0x06e</span>: <span class="token number">70870000000000000000</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token number">0x077</span>:</pre></td></tr><tr><td data-num=8></td><td><pre><span class="token number">0x077</span>: 50a70000000000000000</pre></td></tr><tr><td data-num=9></td><td><pre><span class="token number">0x081</span>: 60a0</pre></td></tr><tr><td data-num=10></td><td><pre>.....</pre></td></tr></table></figure><p><code>Y86-64</code>汇编器的翻译过程是基于<code>Y86-64</code>指令系统的，因此，图中的二进制指令可以运行在<code>Y86-64</code>的处理器上。</p><p>通常，处理器执行一条指令包含很多操作，实现所有<code>Y86-64</code>指令所需要的计算可以被组织成6个基本阶段，分别为</p><ul><li><p><strong>取指阶段(Fetch)</strong> - 这个阶段对于所有的指令都是需要的，但定义的<code>Y86-64</code>指令系统中，指令的长度并不是固定的。取指阶段还会根据指令代码来判断指令是否含有寄存器指示符，是否含有常数，从而计算出当前指令的指令长度</p></li><li><p><strong>译码阶段(Decode)</strong> - 就是从寄存器文件中读取数据，寄存器文件有两个读端口，可以支持同时进行两个读操作</p></li><li><p><strong>执行阶段(Execute)</strong> - 算术逻辑单元ALU主要执行三类操作，第一类是执行算术逻辑运算，第二类操作是计算内存引用的有效地址，第三类操作是针对push指令和pop指令</p></li><li><p><strong>访存阶段(Memory)</strong> - 主要是针对内存的读写操作，即可以从内存中读取数据，也可以将数据写入内存</p></li><li><p><strong>写回阶段(Write Back)</strong> - 与译码阶段类似，都是针对寄存器文件的操作，不同的是译码阶段是读寄存器文件，写回阶段是写寄存器文件</p></li><li><p><strong>更新PC</strong> - 将PC设置成下一条指令的地址</p></li></ul><p>但并不是所有的指令执行都要经历这6个阶段。</p><p>以下例子为不同的指令在各个阶段执行的操作，例如，</p><p>(例1)这条<strong>减法指令</strong>，</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>subq <span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token operator">%</span><span class="token register variable">rbx</span> <span class="token operator">|</span><span class="token number">6</span><span class="token operator">|</span><span class="token number">1</span><span class="token operator">|</span><span class="token number">2</span><span class="token operator">|</span><span class="token number">3</span><span class="token operator">|</span></pre></td></tr></table></figure><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/10.webp alt=""></p><p>取址阶段会根据指令代码来判断该指令是否包含寄存器指示符，是否含有常数，根据判断结果可以得出该指令的长度，由于减法指令的源操作数和目的操作数都是寄存器类型的，在译码阶段会根据寄存器指示符来读取寄存器的值，执行阶段ALU根据译码阶段读取到的操作数以及指令功能来执行具体的运算，除了输出运算结果，还会根据结果来设置条件寄存器。由于减法指令不需要读写内存，因此访存阶段不需要任何操作，写回阶段将ALU的运算结果写回到寄存器rbx，最后对程序计数器PC进行更新，以上就是减法指令相关的操作。</p><p>(例2)<strong>数据传送指令</strong><code>irmovq</code>，</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>irmovq <span class="token number">$8</span>,<span class="token operator">%</span><span class="token register variable">rsp</span> <span class="token operator">|</span><span class="token number">3</span><span class="token operator">|</span><span class="token number">0</span><span class="token operator">|</span>f<span class="token operator">|</span><span class="token number">4</span><span class="token operator">|</span> <span class="token number">8000000000000000</span> <span class="token operator">|</span></pre></td></tr></table></figure><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/11.webp alt=""></p><p>这条指令执行的操作数是将一个立即数传送给寄存器，取指阶段根据指令代码可以判断该指令即含有寄存器指示符字节，也含有常数字段，由于这条指令不需要从寄存器文件中读取数据，所以译码阶段不需要执行任何操作，从表面上看，数据传送指令只是数据搬运，并不需要ALU部件，在实际的硬件中，ALU的输出端口与寄存器文件的写入端口相连，该指令在执行阶段使用ALU对立即数执行加0的操作，在写回阶段将运算结果写入寄存器文件就完成了数据传送的操作。由于该指令不涉及内存的读写，所以访存阶段不执行任何操作，执行阶段使用ALU对常数进行加0的操作需要注意。</p><p>(例3)<strong>数据传送指令</strong><code>rmmovq</code>，</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>rmmovq <span class="token operator">%</span><span class="token register variable">rsp</span>,<span class="token number">100</span>(<span class="token operator">%</span><span class="token register variable">rbx</span>) <span class="token operator">|</span><span class="token number">4</span><span class="token operator">|</span><span class="token number">0</span><span class="token operator">|</span><span class="token number">4</span><span class="token operator">|</span><span class="token number">3</span><span class="token operator">|</span> <span class="token number">6400000000000000</span> <span class="token operator">|</span></pre></td></tr></table></figure><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/12.webp alt=""></p><p>取址阶段和译码阶段跟前面的类似，ALU根据偏移量和基址寄存器来计算访存地址，访存阶段将寄存器rsp的数值写入内存中，内存地址由执行阶段得出，由于不需要写寄存器，所以写回阶段不进行任何操作，通过上面的描述，ALU还可以用来计算内存引用地址。</p><p>(例4)pushq指令的操作流程，</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>pushq <span class="token operator">%</span><span class="token register variable">rdx</span> <span class="token operator">|</span>a<span class="token operator">|</span><span class="token number">0</span><span class="token operator">|</span><span class="token number">2</span><span class="token operator">|</span>f<span class="token operator">|</span></pre></td></tr></table></figure><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/13.webp alt=""></p><p>取址阶段根据指令代码来判断该指令含有寄存器指示符，不含常数，因此，指令长度为2个字节，需要注意的是：译码阶段不仅需要寄存器rdx的值，还需要读寄存器rsp的值，这是因为指令pushq要将寄存器rdx的值保存到栈(内存)上，执行阶段会计算内存地址，具体方法是，将寄存器rsp指向的内存地址进行减8的操作，因此，译码阶段还需要读寄存器rsp的值，访存阶段会将寄存器rdx的值写到栈上。由于寄存器rsp指向的内存地址发生了变化，因此写回阶段需要更新寄存器rsp的值，最后更新PC的值，以上就是push指令各个阶段所进行的操作。</p><p>(例5)跳转指令，</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>je <span class="token number">0x040</span> <span class="token operator">|</span><span class="token number">7</span><span class="token operator">|</span><span class="token number">3</span><span class="token operator">|</span> <span class="token number">4000000000000000</span> <span class="token operator">|</span></pre></td></tr></table></figure><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/14.webp alt=""></p><p>取址阶段根据指令代码来判断该指令含有常数字段，不含寄存器指示符字节，因此，指令的长度为9个字节，由于不需要读取寄存器文件，所以译码阶段不进行任何操作。执行阶段，标号为cond的硬件单元根据条件码和指令功能来判断是否执行跳转，这个模块产生一个信号Cnd，如果Cnd等于1，执行跳转；Cnd等于0，不执行跳转。在更新PC的阶段，如果Cnd等于1，就将PC的值设为0x040，如果Cnd等于0，PC的值就等于当前值加上9，以上就是跳转指令的执行流程。</p><p>通过这个统一的框架，能够处理不同类型的<code>Y86-64</code>指令，虽然指令的行为大不相同，但是可以将指令的处理组织成6个阶段。</p><h3 id=y86-64处理器硬件结构><a class=anchor href=#y86-64处理器硬件结构>#</a> Y86-64处理器硬件结构</h3><p>各个阶段的硬件实现。</p><p><font size=3><ins><strong>取址阶段</strong></ins></font></p><p>取址阶段以程序计数器(PC)的值作为起始地址，取址操作每次从指令内存中读取10个字节。由于在取址操作之前，无法判断当前指令的长度，<code>Y86-64</code>指令系统中最长的指令占10个字节，一次性从内存中取10个字节可以保证一次取指操作至少可以获取一条完整的<code>Y86-64</code>指令。</p><p>之后，将10个字节分成两部分，一部分占1个字节，另外一个部分占9个字节，下图标号为split的硬件单元处理第一部分，它将第一个字节分成两部分，每一部分占4个比特位，根据<code>Y86-64</code>指令系统的定义，这两个字段分别为指令代码和指令功能，这里用icode和ifun表示，根据icode可以确定当前指令的状态信息，首先可以判断这条指令是否是一条合法的指令，如果icode在0x00xB之间，那么这条指令就是一条合法指令，如果不是，则表示当前指令属于非法指令。此外，根据icode还可以判断当前指令是否包含寄存器指示符字节，以及是否包含常数字节，根据上述的判断结果，就可算出当前指令的长度。例如，既含有寄存器指示符字节，又含有常数字节，那么当前指令长度就是10个字节，如果即不含寄存器指示符字节，也不含常数字节，那么当前指令长度就是1个字节。既然通过icode可以获得当前指令的长度，那么指令内存中下一条指令的地址，就可以通过当前PC值加上当前指令的长度计算出来。接着看剩余9个字节是如何处理的，下图标号为align的硬件单元可以产生寄存器字段和常数字段，当need_regids等于1时，表示该指令包含寄存器指示符字节，那么第一个字节将被分成两部分，每一部分占4个比特位，然后分别装入寄存器指示符rA和rB中；当need_regids等于0时，表示这条指令没有寄存器指示符字节，此时rA和rB这两个字段会被置为0xF，当指令中只含有一个寄存器操作数时，同样另外一个字段也会被置为0xF。如果该指令含有常数，align单元还产生常数字段valC，同样需要根据信号need_regids的值来判断，当need_regids等于1时，第2字节到第9个字节表示常数字段valC；当need_regids等于0时，第1字节到第8个字节表示常数字段valC。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/15.webp alt=""></p><p><font size=3><ins><strong>译码阶段</strong></ins></font></p><p>译码阶段是从寄存器文件中读取数据，在<code>Y86-64处理器</code>中寄存器文件有两个读端口，它支持同时进行两个读操作，两个读端口的地址输入为srcA和srcB，从寄存器文件中读出的数值通过valA和valB输出，下图标号为srcA和srcB的圆角矩形块可以产生寄存器的ID值，产生寄存器的ID值需要指令代码icode以及寄存器指示值rA和rB。例如，push指令，该指令的寄存器指示符中只含有目的寄存器的ID值，当执行压栈操作时，还需要获得栈顶指针rsp的值，不仅仅是push指令，实际上对于下图中的这四条指令，在译码阶段都是需要读取寄存器rsp的内容，所以，译码阶段不仅需要rA和rB信号，还需要icode信号。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/16.webp alt=""></p><p>执行阶段的核心部件是算术逻辑单元，简称ALU。ALU根据指令功能(ifun)来判断对输入的操作数进行何种运算，每次运行时，ALU都会产生三个与条件码相关的信号 - 零，符号，溢出。不过，只希望ALU在执行算术逻辑指令时才会设置条件码，当ALU计算内存引用地址以及对栈进行操作时，并不会设置条件码，因此，下图Set_CC会根据指令代码icode来控制是否要更新条件码寄存器，标号为cond的硬件单元会根据指令功能和条件码寄存器产生一个cnd信号，对于跳转指令，如果cnd等于1，执行跳转；如果cnd等于0，则不执行跳转，对于ALU，不仅可以执行算术逻辑指令，还要涉及内存地址的计算以及栈指针的增加或减少的操作。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/17.webp alt=""></p><p><font size=3><ins><strong>访存阶段</strong></ins></font></p><p>访存阶段的任务就是从内存中读数据或将数据写入内存中，下图的读控制块表明应进行读操作，写控制块表明应该进行写操作，此外，还有产生内存地址和输入数据的控制块。访存阶段的最后操作会根据下图的信号来计算状态码Stat。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/18.webp alt=""></p><p><font size=3><ins><strong>写回阶段</strong></ins></font></p><p>写回阶段是将数据写入到寄存器文件，两个写端口分别为M和E，对应的地址输入为dstE和dstM。当执行条件传送指令(cmov)时，写入操作还要根据执行阶段计算出的cnd信号，当不满足条件时，可以将目的寄存器设置为0xF来禁止写入寄存器文件。</p><p><font size=3><ins><strong>更新PC</strong></ins></font></p><p>更新PC的值，PC的值可能有三种情况，第一种情况，如果当前正在执行的指令时函数调用指令Call，那么新的PC就等于call指令的常数字段。第二种情况，如果当前正在执行的指令是函数返回指令ret，指令ret在访存阶段会从内存(栈)中读出返回地址，这个返回地址就是新的PC值。第三种情况，如果当前正在执行的指令是跳转指令jxx，当cnd信号等于1时，即满足跳转条件时，此时新的PC等于跳转指令的常数字段，当不满足跳转条件时，跳转指令与其他指令一样，新的PC值等于当前PC的值加上当前指令的长度。</p><p>以上就是一个<code>Y86-64</code>处理器的完整设计，这种顺序结构指令的执行速度太慢了，时钟必须非常慢，这样才能使得所有的操作在一个时钟周期内完成。</p><h3 id=流水线的通用属性和原理><a class=anchor href=#流水线的通用属性和原理>#</a> 流水线的通用属性和原理</h3><p>首先是一个未流水化的硬件设计，在现代逻辑电路中，电路的延迟用皮秒来表示，1皮秒等于10的负12次方秒，信号从输入端经过组合逻辑电路到达输出端，中间会经过一系列的逻辑门，经过一段时间的延迟后，得到输出结果。假如信号经过组合逻辑电路的时间是300ps，输出信号加载到时钟寄存器保存需要20ps，那么整个过程的延迟为320ps，可以将这整个过程抽象为指令的执行，延迟即一条指令从开始执行到结束所需的时间。假设三条指令顺序通过上述组合逻辑单元，可以得到一个流水图，时间从左向右流动。在这个非流水化的实现中，开始下一条指令之前必须完成上一条指令的执行，因此，指令的执行不存在相互重叠的情况。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/19.webp alt=""></p><p>这里为了评估上述系统的执行效率，引入吞吐量的概念。假如一条指令执行需要320ps，那么这个系统1秒中的时间大约可以执行<code>3.12</code>乘以10的9次方条指令。将吞吐量的单位定义为每秒千兆条指令(Giga-Instructions Per Second - GIPS)，即每秒十亿条指令，因此该系统的最大吞吐量约为<code>3.12</code>GIPS。</p><p>在电路设计中，时钟寄存器直接将它的输入和输出连接到电路中，大多数情况下，寄存器都保存在稳定的状态。假设一个寄存器当前的状态为x，那么产生的输出就等于x，当寄存器的输入端产生了一个新的输入y时，如果时钟是低电位，那么寄存器的状态不会立即发生改变，当时钟信号由低电平变成高电位时，输入信号y才会加载到寄存器中，直到下一个时钟上升沿之前，寄存器的输出一直都是y。假设将组合逻辑单元所执行的操作分为三个阶段，信号经过每个阶段的延迟为100ps，然后在各个阶段之前放上流水线寄存器，寄存器的延迟是20ps，每条指令的执行都会经过A，B，C三个阶段处理，将时钟周期设置为120ps，那么指令从开始到结束需要三个完整的时钟周期。</p><p>接着是指令的流水线图，只要指令1从A阶段进入B阶段之后，就可以让指令2进入A阶段，以此类推，三个阶段都是处于运行状态，之后系统每隔120ps，就有一条指令离开系统，一条新的指令进入，因此，对于流水化系统的吞吐量大约为<code>8.33</code>GIPS，与非流水化的设计相比，系统的吞吐量提高了<code>2.67</code>倍。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/20.webp alt=""></p><p><span class=exturl data-url=aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVRwNHkxODdkaj90PTI1MC4xJmFtcDtwPTI3>→流水线计算的时序和操作例子</span></p><p>之前都是假设指令之间都是相互独立的，然而实际程序中，指令之间是有依赖关系的，例如</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>irmovq <span class="token number">$50</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=2></td><td><pre>addq <span class="token operator">%</span><span class="token register variable">rax</span>,<span class="token operator">%</span><span class="token register variable">rbx</span></pre></td></tr><tr><td data-num=3></td><td><pre>mrmovq <span class="token number">100</span>(<span class="token operator">%</span><span class="token register variable">rbx</span>),<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr></table></figure><p>第二条指令addq的执行需要依赖第一条指令的执行结果，将这种情况称为数据依赖，也叫数据相关，同样第三条指令也需要依赖第二条指令的计算结果。</p><p>除了数据依赖外，还有一种依赖是由于指令控制流造成的控制依赖，例如</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">loop:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	subq <span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token operator">%</span><span class="token register variable">rbx</span></pre></td></tr><tr><td data-num=3></td><td><pre>	jne targ</pre></td></tr><tr><td data-num=4></td><td><pre>	irmovq <span class="token number">$10</span> <span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=5></td><td><pre>	jmp loop</pre></td></tr><tr><td data-num=6></td><td><pre><span class="token label function">targ:</span></pre></td></tr><tr><td data-num=7></td><td><pre>	halt</pre></td></tr></table></figure><p>跳转指令会产生一个控制依赖，因为条件测试结果会决定要顺序执行irmovq指令，还是执行halt指令，在顺序结构的设计中，这些相关是通过反馈来解决的，不过在流水线的系统中引入反馈路径是非常危险的。为了流水线技术加速系统，改变了系统的行为，显然这种行为是不可接受的，必须以某种方式来处理指令间的数据依赖和控制依赖。</p><h3 id=流水线硬件结构><a class=anchor href=#流水线硬件结构>#</a> 流水线硬件结构</h3><p><font size=3><ins><strong>Y86-64的顺序实现</strong></ins></font></p><p>首先是<strong>取指阶段</strong>，将程度计数器PC的值作为地址，从指令内存中读取指令字节，其中第一个字节被分成两部分，分别为指令代码icode和指令功能ifun，取出的指令字节中可能含有一个寄存器指示符字节，指明一个或者两个寄存器指示符(rA，rB)，还可能含有一个四字节的常数valC，PC增加器用来计算下一条指令的地址valP，valP的值等于PC加上当前已经取出指令的长度。</p><p>接着是<strong>译码阶段</strong>，寄存器文件有两个读端口A和B，一次译码操作可以同时读取两个寄存器的值，寄存器文件的读出端口与算术逻辑单元的输入相连，在执行阶段，ALU会根据指令功能(ifun)来执行指定的运算，从而得到运算结果valE，同时还会设置条件码寄存器(CC)，对于跳转指令，在执行阶段会根据条件码和跳转条件来产生信号Cnd。ALU除执行算术逻辑指令，还要计算访存的有效地址，以及针对栈指针的运算(加8和减8操作)，因此，ALU的输出端口会与数据内存的地址逻辑单元相连。</p><p>接着是<strong>访存阶段</strong>，可以将数据写入内存或从内存中读出数据，写入的数据可以由寄存器文件提高，也可以是指令中的常数字段。</p><p>接着是<strong>写回阶段</strong>，寄存器文件有两个写入端口M和E，端口E与ALU的输出端口相连，ALU的计算结果可以通过端口E写回到寄存器文件，端口M与数据内存的输出端口相连，从内存中读取的数据可以通过端口M写回到寄存器文件。</p><p>最后是<strong>更新PC</strong>的值，具体PC的值应该如何更新，需要根据当前执行的指令以及执行的状态来进行判断。例如当前正在执行的指令是跳转指令，那么接下来究竟是顺序执行还是执行跳转，需要根据信号Cnd来判断。例如当前正在执行函数返回指令，那么返回地址就要从内存(栈)中得到。此外，指令在执行的过程中可能会发生异常，产生异常的原因可能是取到了无效的指令或者是读取内存出现了错误，这些异常信号由stat模块来处理。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/21.webp alt=""></p><p>对于当前的顺序结构，所有阶段的操作都要在一个时钟周期内完成。例如，取指阶段发生在时钟周期刚开始的时候，那么更新PC发生在时钟周期快要结束的时候。</p><p>接下来调整当前的结构设计，使更新PC在时钟周期开始的时候执行，而不是结束时才执行。具体的实现方法是，创建一个寄存器来保存指令在执行过程中产生的信号。当一个新的时钟周期开始时，根据寄存器中保存的信号值来计算当前指令的PC值，通过引入寄存器的方式将更新PC的操作从时钟周期快要结束时运行移到了时钟刚开始时运行。从改造后的结构来看，其他的硬件单元和控制模块都没有发生改变，将这种改进方法称为电路重定时。重定时只是改变了系统的状态表示，但是并没有改变它的逻辑行为。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/22.webp alt=""></p><p>接下来把顺序结构改造成流水结构，从宏观的角度来看，只需要在顺序结构的各个阶段之间插入流水线寄存器，然后对信号进行重新排列，就可以得到流水结构。</p><p>接下来是五级流水的整体设计，流水线寄存器用蓝色矩形框来表示，每个寄存器包含不同的字段，第一个寄存器F，用来保存PC的预测值，取指阶段的逻辑单元与顺序结构类似。第二个寄存器D，位于取指阶段和译码阶段之间，用于保存刚刚取出指令的信息，例如指令代码，指令功能，寄存器指示符等，这些信息由译码阶段来处理。第三个寄存器E，位于译码阶段和执行阶段之间，它保存了最新译码指令的状态以及从寄存器文件中读取的数值，上述信息都保存到寄存器E中，即将由执行阶段进行处理。第四个寄存器M，位于执行阶段和访存阶段之间，它保存了最新执行指令的结果，这里的结果不仅仅是执行算术逻辑指令的结果，还有处理跳转指令的分支条件信息。最后一个寄存器W，位于访存阶段和反馈路径之间，访存执行的结果保存到寄存器W中，反馈路劲将结果写回到寄存器文件，如果当前执行的是函数返回指令ret，那么访存读出的数值就是下一条即将执行的指令地址，所以需要将该数值提供给PC的选择逻辑。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/23.webp alt=""></p><h3 id=数据冒险><a class=anchor href=#数据冒险>#</a> 数据冒险</h3><p>通过示例代码来看指令在流水线中的执行情况。</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>irmovq <span class="token number">$1</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=2></td><td><pre>irmovq <span class="token number">$2</span>,<span class="token operator">%</span><span class="token register variable">rbx</span></pre></td></tr><tr><td data-num=3></td><td><pre>irmovq <span class="token number">$3</span>,<span class="token operator">%</span><span class="token register variable">rcx</span></pre></td></tr><tr><td data-num=4></td><td><pre>irmovq <span class="token number">$4</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=5></td><td><pre>halt</pre></td></tr></table></figure><p>这段代码序列包含5条指令，为了方便表述，用简化的蓝色矩形框表示指令执行的不同阶段，例如F表示取指阶段(Fetch)，D表示译码阶段(Decode)。第一个时钟周期执行指令1的取指操作，第二个时钟周期进行译码操作，指令1的不同阶段将在不同的时钟周期内完成，经过5个时钟周期执行完毕。根据流水结构的特性，第二个时钟周期进行指令2的取指操作，此时指令1已经完成了取指操作，释放了取指操作使用的硬件单元，因此可以对指令2进行取指操作，同样经过5个时钟周期后，指令2执行完毕。以此类推，剩下的3条指令按照顺序依次进入流水线执行，最终经过9个时钟周期后，5条指令全部执行完毕。下图描述了不同指令通过流水线各个阶段的过程，时间从左向右在增大，例如在第五个时钟周期时，整个流水线中同时在执行5条指令，不过5条指令都处于不同的执行阶段。通常会使用指令的流水图来表示流水线的状态。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/24.webp alt=""></p><p>之前提到过数据相关和控制相关，例如</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>irmovq <span class="token number">$10</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=2></td><td><pre>irmovq <span class="token number">$3</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=3></td><td><pre>addq <span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=4></td><td><pre>halt</pre></td></tr></table></figure><p>第三条指令<code>addq</code>的执行需要依赖前两条指令的执行结果。这段指令序列在执行的过程中会出现什么样的问题。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/25.webp alt=""></p><p>这里假设所有程序寄存器的初始值都为0，下图中的这段指令将立即数10和3分别放入到寄存器rdx和rax中，然后二者相加，最终结果存放到寄存器rax中。重点看第四个时钟周期，此时指令add处于译码阶段，需要从寄存器文件中读取寄存器rax和rdx的值，期望从寄存器rdx中读到数值10，从寄存器rax中读到数值3，然而实际上从寄存器中读到的值却都是0，出现这种情况是因为此时指令1正处于访存阶段，立即数10还未写回到寄存器rdx，同样指令2处于执行阶段，立即数3也没有写回到寄存器rax，所以在第四个时钟周期时，寄存器rdx和rax的值还都是默认值0，在这个示例中，由于指令irmovq和指令addq之间存在数据相关导致流水线产生了错误的计算结果，将这种情况称为<strong>冒险</strong>或者<strong>冲突</strong>。与相关一样，冒险也分为两类，一类是数据冒险，另外一类是控制冒险。</p><p>此处主要是如何避免数据冒险，首先想让指令addq暂停一下，等到指令1和指令2完成写回操作时，再继续指令addq的执行，这样一来就能够避免数据冒险，这种解决冒险的方法看起来比较简单，不过需要判断什么时候执行暂停操作，如何实现暂停操作以及暂停多久。判断暂停的方法时指令在译码阶段读取寄存器时，通过读取寄存器的ID值分别与执行阶段，访存阶段以及写回阶段所执行指令的目的寄存器进行对比。如果存在寄存器ID值相等的情况，就说明指令之间存在数据相关，那么该指令就要在译码阶段等待，对于流水线的执行阶段，原本是要正常的执行指令，暂停之后，通过插入气泡来代替暂停的指令，气泡不会改变寄存器，内存，条件码以及程序状态，下图红色的矩形框表示的为气泡，箭头表明插入气泡是为了代替指令addq。虽然使用暂停技术可以解决数据冒险，但是基于这种机制实现的流水线性能并不高，这是因为程序中数据相关的情况非常的多，频繁暂停指令的执行会严重降低流水线的吞吐量，在这个例子中指令addq需要等待指令irmovq将结果写回到寄存器文件之后，再从寄存器文件中读取相应寄存器的数据。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/26.webp alt=""></p><p>指令irmovq在访存阶段没有执行任何操作，那么有没有可能直接把运算结果传给addq指令，这样指令addq就不用通过暂停来等待数据写回了，具体实现得方法可以添加一条信号线，将指令irmovq经过ALU得执行结果直接传送到指令addq的译码阶段，将这种实现技术称为数据转发，也称旁路。数据转发的实现需要在基本的硬件结构中增加一些额外的数据连接和控制逻辑。与之前的硬件结构相比，带有转发功能的流水结构增加了两个逻辑块，通过添加的旁路路径能够转发前面指令的结果，这使得流水线可以不暂停就能处理大多数情况的数据冒险。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/27.webp alt=""></p><p>但是，还有一种类型的数据冒险不能单纯的使用转发来解决，例如下面代码示例</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>mrmovq <span class="token number">0</span>(<span class="token operator">%</span><span class="token register variable">rdx</span>),<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=2></td><td><pre>addq <span class="token operator">%</span><span class="token register variable">rbx</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=3></td><td><pre>halt</pre></td></tr></table></figure><p>指令mrmovq指令需要从内存中读取数据，由于读内存的操作发生在流水线的后期，即使采用转发逻辑也来无法将值送回到过去的时间，为了解决这一类数据冒险，需要将暂停和转发结合使用，指令addq在译码阶段暂停一个周期，等到指令mrmovq访存结束后，使用旁路路径将访存结果转发到译码阶段，指令addq继续执行。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/28.webp alt=""></p><h3 id=控制冒险><a class=anchor href=#控制冒险>#</a> 控制冒险</h3><p>控制冒险出现的原因，在流水线的设计中，期望每个时钟周期都能完成一条指令的执行，想要达到这个目的，流水线在每一个时钟周期都要取到一条指令，因此每一次取指操作后，必须马上确定下一条指令的地址，对于<code>Y86-64</code>的指令集系统，大多数情况下都能满足上述要求。当取出的指令是返回指令ret时，下一条指令的地址需要从栈中读出，因此必须等到访存操作结束之后才能确定下一条指令的地址，当遇到这种情况时，流水线需要进行特殊的处理来避免控制冒险。除此之外，还有一种情况，当取到的指令是分支条件指令时，流水线无法立即判断是否要进行跳转操作，需要经过执行阶段后才能确定是否进行跳转，同样流水线也需要特殊的处理来避免控制冒险。综上所述，在关于<code>Y96-64</code>的流水线设计中，当取指阶段取到了返回指令ret和条件分支指令时，由于无法根据当前指令立刻确定下一条指令的地址，从而引发控制冒险。</p><p>接下来为一个关于返回指令ret的示例程序，</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token number">0x000</span>: 	irmovq stack,<span class="token operator">%</span><span class="token register variable">rsp</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token number">0x00a</span>: 	call proc</pre></td></tr><tr><td data-num=3></td><td><pre><span class="token number">0x013</span>: 	irmovq <span class="token number">$10</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token number">0x01d</span>: 	halt</pre></td></tr><tr><td data-num=5></td><td><pre><span class="token number">0x020</span>: .pos <span class="token number">0x20</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token number">0x020</span>: proc:</pre></td></tr><tr><td data-num=7></td><td><pre><span class="token number">0x020</span>: 	ret</pre></td></tr><tr><td data-num=8></td><td><pre><span class="token number">0x021</span>: 	rrmovq <span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token operator">%</span><span class="token register variable">rbx</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token number">0x030</span>: .pos <span class="token number">0x30</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token number">0x030</span>: stack:</pre></td></tr></table></figure><p>最左边的16进制数表示指令地址，第一条指令irmovq表示初始化栈指针，第二条指令call表示函数调用，函数proc包含两条指令，一条返回指令ret，另外一条指令rrmovq，不过这一条指令并不会执行，为了方便使用流水线图来表示返回指令ret的执行情况，根据指令的执行顺序来调整一下这段指令的顺序，</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token number">0x000</span>: irmovq stack,<span class="token operator">%</span><span class="token register variable">rsp</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token number">0x00a</span>: call proc</pre></td></tr><tr><td data-num=3></td><td><pre><span class="token number">0x020</span>: ret</pre></td></tr><tr><td data-num=4></td><td><pre><span class="token number">0x013</span>: irmovq <span class="token number">$10</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr></table></figure><p>接下来为这段指令在流水线中的执行情况，第3个时钟周期时，返回指令ret开始进入流水线执行，由于返回指令ret在完成访存阶段后才能得到下一条指令的地址，由于返回指令ret在完成访存阶段后才能得到下一条指令的地址，所以当返回指令ret处于译码，执行，访存这三个阶段时，流水线不能进行其他有用的操作，只能在流水线中插入三个气泡，具体如下图，直到第7个时钟周期时，返回指令ret到达写回阶段，此时PC的选择逻辑将读出的地址作为下一条指令的取指地址，之后流水线继续执行。关于返回指令ret所引发的控制冒险，可以通过暂停处理新指令的方式来避免。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/29.webp alt=""></p><p>接下来为另外一种情况，实际上对于条件分支指令的结果，无非是跳转和不跳转两种情况，可以假定一个策略，预设分支的结果总是跳转或者总是不跳转，这种猜测分支结果的方法被称为分支预测，分支预测的准确性对程序的性能有非常大的影响，这是因为当出现预测错误后，需要采取相应的方法来处理，接下来通过一个代码示例来看一下针对分支指令的处理，</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token number">0x000</span>: 	xorq <span class="token operator">%</span><span class="token register variable">rax</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token number">0x002</span>: 	jne target</pre></td></tr><tr><td data-num=3></td><td><pre><span class="token number">0x00b</span>: 	irmovq <span class="token number">$1</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token number">0x015</span>: 	halt</pre></td></tr><tr><td data-num=5></td><td><pre><span class="token number">0x016</span>: target:</pre></td></tr><tr><td data-num=6></td><td><pre><span class="token number">0x016</span>: 	irmovq <span class="token number">$2</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token number">0x020</span>: 	irmovq <span class="token number">$3</span>,<span class="token operator">%</span><span class="token register variable">rbx</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token number">0x02a</span>: halt</pre></td></tr></table></figure><p>第二条指令jne，需要根据条件码来判断是否执行跳转，如果执行跳转，流水线需要执行target代码段；如果不执行跳转，程序顺序执行，这里采用一个简单而又粗暴的分支预测策略，就是当遇到分支指令时，总是选择执行跳转，实际中分支预测的策略要比假设的复杂的多。基于上述假设的分支预测策略，在第3个时钟周期时，流水线会取出位于跳转目标处的指令。在第4个时钟周期时，根据跳转后的顺序继续进行取指操作，不过，在第4个时钟周期时，指令jne到达了执行阶段，此时根据执行结果发现不应该执行跳转，显然之前的分支预测发生了错误，根据程序的正常逻辑，这两条指令不应该出现在流水线中，因此，应该立即中止它们继续执行，不过这两条指令还没有进入执行阶段，因此并不会影响程序的正确性，所以只需要将两条指令从流水线中简单的剔除即可，具体的解决方法是在第5个时钟周期时，对于第1条指令，需要在执行阶段插入气泡，对于第二条指令，在译码阶段插入气泡即可，同时还要取出跳转指令后面的指令，这样一来，两条预测错误的指令就从流水线中剔除了，虽然没有引发程序的错误，但是分支预测错误导致了两个时钟周期的浪费。综上所述，对于控制冒险的处理方法，主要通过往流水线中插入气泡来解决，因此，可以通过暂停和插入气泡来动态的调整流水线的状态，从而解决由于指令间的相关问题而导致的冒险。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/30.webp alt=""></p><p>接下来为暂停和插入气泡是如何实现的，之前提到的流水线寄存器，流水线寄存器是通过时钟的上升沿来改变输出的值，为了实现暂停和插入气泡，为每个流水寄存器引入两个控制信号，分别为暂停信号和气泡信号，在流水线正常执行时，暂停信号和气泡信号都设置为0；当遇到时钟上升沿时，寄存器会加载它的输入来作为新的输出；当需要暂停流水线时，需要将暂停信号设为1时，此时寄存器会保持它以前的状态，即使遇到时钟上升沿，寄存器的输出也不会发生改变，这样一来，就可以实现指令阻塞在流水线的某个阶段中，当需要向流水线中插入气泡时，可以将气泡信号设置为1，此时寄存器的状态会设置成某个固定的复位配置，这个复位配置等效于指令nop的状态，具体如何配置流水线寄存器，通过以下例子来说明，假如，要往寄存器E中插入气泡，要将icode字段设置为INOP，并将dstE，dstM，srcA以及srcB设置为RNONE，这样就可以达到与指令nop一样的效果。</p><h3 id=y86-64的流水线实现><a class=anchor href=#y86-64的流水线实现>#</a> Y86-64的流水线实现</h3><p><font size=3><ins><strong>第一阶段-取指阶段</strong></ins></font></p><p>这个阶段最复杂的地方就是如何预测下一条指令的地址，实际上指令在具体执行时，有两种情况，一种是顺序执行，另外一种就是跳转执行。因此，可以将<code>Y86-64</code>指令集所定义的指令分为两大类，假如取指阶段取出的指令属于顺序执行的情况，那么，下一条指令的地址可以通过当前指令的地址加上当前指令的长度计算的得出。例如，取指阶段从地址<code>0x100</code>处取出了指令addq，根据指令集的定义，指令addq长度为两个字节，那么下一条指令的地址就是<code>0x102</code>，为了方便表示，用valP来代指顺序执行时下一条指令的地址。</p><p>接下来为跳转执行的情况，当取出的指令为函数调用指令或者跳转指令时，PC预测逻辑单元会直接将这两条指令中的常数字段(valC)作为下一条指令的地址，对于函数调用指令来说，这种处理方法非常容易理解，至于跳转指令，会有跳转和不跳转两种情况。这里假设的分支预测策略是总是执行跳转，所以下一条指令的地址就是指令中的常数字段。在之后的表述中，用valC来表示跳转执行时下一条指令的地址，如果取指阶段取出的指令是返回指令，下一条指令的地址需要从栈中读出，由于返回值的范围太大，所以在这里的设计中，不会尝试对返回地址做预测，既然无法预测，PC预测逻辑单元在预测返回指令的下一条指令地址时，采用与顺序执行的指令一样的方法来简单处理，综上所述，PC预测逻辑单元会根据指令类型(icode)来预测下一条指令的地址究竟是valP，还是valC，既然是预测下一条指令的地址，那么肯定会有出错的情况。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/31.webp alt=""></p><p>对于下图的PC选择逻辑单元可以理解为纠错部件，即PC预测逻辑单元出错了之后的PC选择逻辑单元会根据实际的执行情况来纠正预测错误。例如当前取指阶段取到了返回指令ret，下一条指令的地址还要等待指令ret经过译码，执行，访存之后才能从内存中读到正确的返回地址，也就是一条指令的地址，纠正的方法比较简单，即通过判断指令类型(icode)，如果是返回指令ret，就把流水线寄存器W中的访存结果(W_valM)作为下一条指令的地址，假如当前取指阶段取到了条件分支指令，那么究竟是否执行跳转，需要等待指令经过译码和执行之后才能判断，PC选择逻辑是通过信号Cnd来判断是否进行跳转，如果不跳转，证明假设的分支预测错了，需要纠正，具体纠正的方法是从流水线寄存器M中读出下一条指令的地址。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/32.webp alt=""></p><p>至于取指阶段的其他模块与之前的顺序结构一致。</p><p><font size=3><ins><strong>第二阶段-译码阶段</strong></ins></font></p><p>主要是根据寄存器得ID从寄存器文件中读取数据，寄存器得ID由字段rA和rB提供，经过srcA和srcB逻辑单元输入到寄存器文件，最终译码得结果用valA和valB来表示，为了提高流水线得执行效率，引入了数据转发得机制，数据转发可以直接使用相关寄存器得数据，而不是等写回阶段更新完寄存器的值后，再从寄存器文件中读取，所以译码阶段需要判断究竟是直接采用转发的数据，还是需要从寄存器文件中读取数据，判断的依据是根据当前需要读取寄存器的ID值与转发的目的寄存器的ID值是否相等。对于流水线的设计，译码阶段由于加入转发功能从而导致了硬件设计变得相对复杂了。</p><p>究竟是哪些数据需要转发，第一个转发源是ALU产生的输出结果，如果按照正常指令执行的流程，这个ALU的输出结果还要经过访存和写回阶段后，才能完成寄存器的数值更新，采用数据转发的设计，ALU的输出结果可以马上作为译码阶段的结果，从而避免了等待数据写回寄存器文件后再去读的问题。第二个转发源是内存的输出数据，与ALU的输出结果类似，通过转发内存的输出数据也可以避免等待的问题。第三个转发源是访存阶段时，对寄存器写入端口E还没有进行写入的数据。下图只画出前三个转发源。第四个转发源是写回阶段时，对寄存器写入端口M还没有进行写入的数据。第五个转发源是写回阶段时，对寄存器写入端口E还没有进行写入的数据，其中每一个转发源包括两个部分，一部分是寄存器的ID值，用白色信号线表示；另外一部分是转发数据，用红色信号线表示。这个5个转发源是存在优先级的，转发逻辑单元首先会检测执行阶段的转发源，然后是访存阶段，最后才是写回阶段。如果选择了其他的优先级顺序，对于某些程序来说就会出错。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/33.webp alt=""></p><p>这里为了方便辨认，将转发信号省略。如果不满足上述所有的转发条件，下图这个逻辑单元就选择从寄存器文件的A端口读出的数据作为输出，对于标号为<code>Sel+FwdA</code>的逻辑单元扮演了两个角色，与逻辑单元<code>FwdB</code>相比，逻辑单元<code>FwdA</code>多了一个valP的输入，它实现了将valP信号和valA信号的合并功能，减少了流水线寄存器中状态的数量。为什么这两个信号可以合并呢？valP表示的是顺序执行时，下一条指令的地址，而valA表示的从寄存器文件中读到的数据，看起来这两个信号之间并没有什么联系，事实上，只有函数调用指令和跳转指令在后面的阶段的才需要用到valP，而这两类指令并不需要从寄存器的A端口读取数据，所以可以根据指令代码icode来判断当前指令是否属于这两类。如果是，就可以进行合并。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/34.webp alt=""></p><p><font size=3><ins><strong>流水线控制逻辑</strong></ins></font></p><p>先来看一下指令执行时出现的特殊情况以及期望得到的处理，第一种特殊情况是加载/使用冒险，例如当这两条指令顺序出现时，</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>mrmovq <span class="token number">0</span>(<span class="token operator">%</span><span class="token register variable">rdx</span>),<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=2></td><td><pre>addq <span class="token operator">%</span><span class="token register variable">rbx</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr></table></figure><p>二者之间存在数据相关，因此会产生加载/使用冒险。当指令mrmovq处于执行阶段时，紧跟其后的addq指令处于译码阶段。此时，期望指令addq可以阻塞在译码阶段，等待指令mrmovq完成访存后，通过数据转发来解决这个数据冒险，然后指令addq继续执行，流水线的控制逻辑不仅需要监测这种冒险的发生，还要使得指令按照期望的反向去执行，具体的解决方法是，保持流水线寄存器F和D的状态不变，同时向寄存器E中插入一个气泡，这样一来，二者之间的冒险就解决了，除了指令mrmovq之外，指令popq同样可能产生加载/使用的冒险情况。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/35.webp alt=""></p><p>第二种特殊情况是分支预测发生错误时，当跳转指令达到执行阶段时可以检测到预测错误，那么下一个时钟周期，需要取消两条已经取到的指令，具体的解决方法是，向流水线寄存器D和E中插入气泡，这样一来就可以纠正预测导致的错误。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/36.webp alt=""></p><p>第三种情况是返回指令的处理，当取指阶段取到返回指令ret时，指令ret需要经过译码，执行以及访存之后才能读到下一条指令的地址，虽然取指阶段会不断取出错误的指令，但是在译码阶段就被替换成了气泡，气泡会经过剩下的流水阶段，因此通过插入3个气泡，就可以达到期望的效果，只不过流水线连续三个周期都取出了不正确的指令。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/37.webp alt=""></p><p>还有一种特殊情况是对异常的处理。对于以上四种特殊情况处理，可以通过流水线的控制逻辑来实现，控制逻辑执行的操作就是在出现特殊情况时，通过暂停和插入气泡来保证程序正确执行。通俗点讲，暂停就是保持流水线寄存器的状态不改变，插入气泡就是将寄存器的状态做一个类似清零的操作。</p><p>到目前为止，假设任意一个时钟周期内，最多只能出现一个特殊情况，然而实际情况中，会有两种情况的组合出现，例如下面这段汇编代码</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>jne target</pre></td></tr><tr><td data-num=2></td><td><pre>	irmovq <span class="token number">$1</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token label function">target:</span> ret</pre></td></tr></table></figure><p>包含一个条件分支指令和一个返回指令，当分支指令处于执行阶段，返回指令处于译码阶段时，由于分支指令并不会执行跳转，因此期望执行的指令是irmovq指令，而不是返回指令，因此，针对这种组合的具体解决方法是，暂停寄存器F，同时向寄存器D和E中插入气泡，幸运的是，下一个时钟周期，PC的选择逻辑会选择跳转之后的指令，而不是从PC预测单元读出的地址，所以无论寄存器F发生了什么，都没有关系。这样一来，跳转指令与返回指令的组合冒险就解决了。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/38.webp alt=""></p><p>再看另外一种组合的情况，这种组合包含一个加载/使用冒险和一个返回指令，其中加载指令的目的寄存器是<code>%rsp</code>，返回指令ret默认使用的寄存器也是rsp，此时指令mrmovq处于执行阶段，返回指令处于译码阶段，针对加载/使用冒险，流水线的控制逻辑会对寄存器F和D执行暂停操作，同时向寄存器E中插入气泡，针对返回指令，流水线的控制逻辑会对寄存器F执行暂停操作，同时向寄存器D中插入气泡，从下图可以看成，控制逻辑同时对寄存器D执行了暂停和插入气泡两种操作，这显然不合理。实际上，针对寄存器D仅执行暂停操作即可保证程序的正确性，因此，需要对这种组合进行特殊的处理。综上所述，在设计<code>Y86-64</code>的控制逻辑时，需要保证在出现上述特殊情况时，程序仍然可以正确运行。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/39.webp alt=""></p><p>为了定量分析设计的处理器的性能，引入一个CPI(Cycles Per Instruction)的概念，它表示一条指令执行所需要的时钟周期数，假设处理器在某个时间段内一共处理了Ci条指令和Cb个气泡，那么大约一共需要Ci + Cb个时钟周期，大约的意思是，这里忽略了启动指令通过流水线的时钟周期数，CPI等于1加上Cb/Ci，这里的Cb/Ci可以理解为惩罚项，它表示执行一条指令平均要插入多少个气泡。可以将这个惩罚项分解为三个部分(<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>C</mi><mi>P</mi><mi>I</mi><mo>=</mo><mn>1.0</mn><mo>+</mo><mi>l</mi><mi>p</mi><mo>+</mo><mi>m</mi><mi>p</mi><mo>+</mo><mi>r</mi><mi>p</mi></mstyle></mrow><annotation encoding=application/x-tex>\small CPI=1.0+lp+mp+rp</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.614997em;vertical-align:0></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.07153em>C</span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.13889em>P</span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.07847em>I</span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.654993em;vertical-align:-.07499700000000001em></span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5">.</span><span class="mord sizing reset-size6 size5">0</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.799992em;vertical-align:-.174996em></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.01968em>l</span><span class="mord mathnormal sizing reset-size6 size5">p</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.6999930000000001em;vertical-align:-.174996em></span><span class="mord mathnormal sizing reset-size6 size5">m</span><span class="mord mathnormal sizing reset-size6 size5">p</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.5625em;vertical-align:-.174996em></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.02778em>r</span><span class="mord mathnormal sizing reset-size6 size5">p</span></span></span></span>)，其中lp表示由于加载/使用冒险暂停时插入气泡的平均数，mp表示由于分支预测错误取消指令时插入气泡的平均数，rp表示返回指令造成暂停时插入气泡的平均数。通过一个例子来看一下如何计算CPI，例如，在一个程序中，加载指令占所有执行指令的<code>25%</code>，其中<code>20%</code>会导致加载/使用冒险，跳转指令占所有指令的<code>20%</code>，其中<code>60%</code>会执行跳转，<code>40%</code>不执行跳转，返回指令占所有指令的<code>2%</code>，根据下述的数据，可以计算出三种处罚的总和是<code>0.27</code>，因此得到的CPI为<code>1.27</code>，也就是平均执行一条指令需要<code>1.27</code>个时钟周期，这与期望每个时钟周期都能执行一条指令相比，虽然有一些差距，但是整体性能已经不错了，如果想要进一步降低CPI，提高处理器的性能，需要降低分支预测的错误。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/40.webp alt=""></p><h2 id=优化程序性能optimizing-program-performance><a class=anchor href=#优化程序性能optimizing-program-performance>#</a> 优化程序性能(Optimizing Program Performance)</h2><p>优化程序的性能，使程序运行的更快。编写高效的程序需要做到以下几点</p><ul><li>选择适当的算法和数据结构(Appropriate algorithms and data structures)</li><li>理解编译器的能力和局限性(Capabilities and Limitations of Optimizing Compilers)</li><li>处理运算量大时将一个任务划分为多个部分-探索并行化(Exploiting Parallelism)</li></ul><h3 id=编译器优化程序的局限性><a class=anchor href=#编译器优化程序的局限性>#</a> 编译器优化程序的局限性</h3><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">void</span> <span class="token function">add1</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token operator">*</span> xp<span class="token punctuation">,</span><span class="token keyword">long</span><span class="token operator">*</span> yp<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token operator">*</span>xp <span class="token operator">+=</span> <span class="token operator">*</span>yp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token operator">*</span>xp <span class="token operator">+=</span> <span class="token operator">*</span>yp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token keyword">void</span> <span class="token function">add2</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token operator">*</span> xp<span class="token punctuation">,</span><span class="token keyword">long</span><span class="token operator">*</span> yp<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token operator">*</span>xp <span class="token operator">+=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token operator">*</span>yp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这两个函数，二者的功能似乎是一样的，它们都是将指针yp所指向的数两次加到指针xp指向的数，不过函数add2的指向效率更高一些，这是因为函数add1需要执行6次内存引用，其中包含两次读xp指向的内存位置，两次读yp指向的内存位置，以及两次写xp指向的内存位置。然而函数add2只需要执行3次内存引用，包含一次读xp指向的内存位置，一次读yp指向的内存位置以及一次写xp指向的内存位置。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/41.webp alt=""></p><p>既然函数add2的执行效率比函数add1高，那么能不能用函数add2的计算方式作为函数1的优化版本呢？这里考虑一个特殊情况，当xp和yp指向的内存位置相同时，函数add1的执行结果是xp的值增加4倍，而函数add2的执行结果是xp的值增加了3倍。当编译器在优化代码时，会假设xp和yp有可能指向同一内存位置。因此，不能用函数add2的代码作为函数add1的优化版本。将两个指针可能指向同一个内存位置的情况称为内存别名使用。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre>x <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre>y <span class="token operator">=</span> <span class="token number">3000</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token operator">*</span>q <span class="token operator">=</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token operator">*</span>p <span class="token operator">=</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>t1 <span class="token operator">=</span> <span class="token operator">*</span>q<span class="token punctuation">;</span></pre></td></tr></table></figure><p>接着是一个类似的例子，上面这段代码并没有给出指针p和指针q的初始化代码，但是由于指针p和指针q指向了相同的位置，在这种情况下，t1的值等于1000。通过这个例子可以看出，如果编译器无法确定两个指针是否指向同一个位置，那么编译器就会假设所有的情况都有可能发生，这就限制了可能的优化策略，另外一个妨碍优化的因素是函数调用，以下面的代码为例</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">long</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">long</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token keyword">long</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token keyword">return</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果忽略函数f的具体内容，这两个函数的执行结果是相同的，但是func2只调用了f一次，而func1却调用了f四次，显然func2的执行效率是高于func1的，那么能不能把func2的代码作为func1的优化方式呢？假设函数f的内容是这样的</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">long</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">long</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">return</span> counter<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>其中counter是一个全局变量，每次调用f都会改变counter的值。假设程序开始运行时，变量counter的初始值为0，当函数func1被调用时，实际执行中对函数f发生了四次调用，每次调用函数f得到的返回值都是不同的，第一次函数f的返回值为0，第二次是1，第三次是2，第四次是3，所以函数func1执行完毕后返回结果是6，由于函数func2只调用了一次函数f，所以函数func2执行的返回结果是4乘以0。因此，大多数编译器不会把func1优化成func2的形式，由于编译器的优化并不是特别的激进，所以需要花费更多的精力来编写高质量的代码。</p><p>接下来通过一个例子来看一下如何表示程序的性能，对于一个向量a包含n个元素，其中n是一个变量，现在需要计算出向量a的前置和，并且保存到向量p中，关于前置和的计算过程是，<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><msub><mi>P</mi><mn>0</mn></msub><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub></mstyle></mrow><annotation encoding=application/x-tex>\small P_0 = a_0</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.749997em;vertical-align:-.135em></span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal" style=margin-right:.13889em>P</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.2796266666666667em><span style=top:-2.45em;margin-left:-.13889em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.5225040000000001em;vertical-align:-.135em></span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal">a</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.2796266666666667em><span style=top:-2.45em;margin-left:0;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span>，<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><msub><mi>p</mi><mn>1</mn></msub><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub></mstyle></mrow><annotation encoding=application/x-tex>\small p_1=a_0+a_1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.5625em;vertical-align:-.174996em></span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal">p</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.2796266666666667em><span style=top:-2.45em;margin-left:0;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.6599970000000001em;vertical-align:-.135em></span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal">a</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.2796266666666667em><span style=top:-2.45em;margin-left:0;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.5225040000000001em;vertical-align:-.135em></span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal">a</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.2796266666666667em><span style=top:-2.45em;margin-left:0;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span>，<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><msub><mi>P</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mstyle></mrow><annotation encoding=application/x-tex>\small P_{n-1}=a_0+a_{n-1}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.799995em;vertical-align:-.184998em></span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal" style=margin-right:.13889em>P</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.2796266666666667em><span style=top:-2.4499999999999997em;margin-left:-.13889em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.2055533333333333em><span></span></span></span></span></span></span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.6599970000000001em;vertical-align:-.135em></span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal">a</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.2796266666666667em><span style=top:-2.45em;margin-left:0;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.5725020000000001em;vertical-align:-.184998em></span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal">a</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.2796266666666667em><span style=top:-2.4499999999999997em;margin-left:0;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.2055533333333333em><span></span></span></span></span></span></span></span></span></span>，一直加到<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mstyle></mrow><annotation encoding=application/x-tex>\small a_{n-1}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.5725020000000001em;vertical-align:-.184998em></span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal">a</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.2796266666666667em><span style=top:-2.4499999999999997em;margin-left:0;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.2055533333333333em><span></span></span></span></span></span></span></span></span></span>。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">void</span> <span class="token function">psum1</span><span class="token punctuation">(</span><span class="token keyword">float</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">float</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">long</span> n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=6></td><td><pre>        p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>现在用一个程序来计算向量a的前置和，向量a的元素存储在数组a中，计算结果将保存到数组p中，n表示向量的个数，函数psum1通过一个for循环实现了上述功能，每一次迭代计算一个元素的值，这种实现方法是比较常用，不过还有更加高效的实现方法。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">void</span> <span class="token function">psum2</span><span class="token punctuation">(</span><span class="token keyword">float</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">float</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">long</span> n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>        <span class="token keyword">float</span> mid_val <span class="token operator">=</span> p<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>        p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> mid_val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>        p<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> mid_val <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>虽然函数psum2也是采用for循环来实现，与psum1不同的是，psum2一次迭代可以计算出两个元素的值，将这种技术称为循环展开。</p><p>对比一下函数psum1和psum2的性能，当n的数量不断增大时，程序执行所需要的时间也在增大。如下图所示，其中横坐标表示元素的个数，纵坐标表示时钟周期数，可以使用最小二乘法拟合出两条近似的直线，这两条直线近似的表示出随着数组元素n的增加，两个函数执行所需的时钟周期数的变化情况，函数psum1的运行时间可以近似用<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mn>368</mn><mo>+</mo><mn>9</mn><mo>∗</mo><mi>n</mi></mstyle></mrow><annotation encoding=application/x-tex>\small 368+9*n</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.654993em;vertical-align:-.07499700000000001em></span><span class="mord sizing reset-size6 size5">3</span><span class="mord sizing reset-size6 size5">6</span><span class="mord sizing reset-size6 size5">8</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.5799960000000001em;vertical-align:0></span><span class="mord sizing reset-size6 size5">9</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mbin sizing reset-size6 size5">∗</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.387504em;vertical-align:0></span><span class="mord mathnormal sizing reset-size6 size5">n</span></span></span></span>来表示，函数psum2的运行时间可以近似用<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mn>368</mn><mo>+</mo><mn>6</mn><mo>∗</mo><mi>n</mi></mrow><annotation encoding=application/x-tex>368+6*n</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.72777em;vertical-align:-.08333em></span><span class=mord>3</span><span class=mord>6</span><span class=mord>8</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.64444em;vertical-align:0></span><span class=mord>6</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>∗</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.43056em;vertical-align:0></span><span class="mord mathnormal">n</span></span></span></span>来表示，其中6和9被称为线性因子。从图中可以看出，当n的值较大时，运行时间主要由线性因子来决定，为了评估程序的性能，这里引入一个新的度量标准-CPE，CPE表示每个元素执行所需要的周期数，而不是每次循环所需要的周期数，针对执行重复计算的程序而言，CPE这种度量标准可以更好的理解迭代程序的性能。根据上述度量标准，psum2的CPE为6.0，psum1的CPE为9.0，所以在优化程序的性能时，应该集中精力减小计算的CPE。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/42.webp alt=""></p><hr><p>以下为一个向量的抽象数据类型，它由两个内存块来表示，分别是向量的头部和指令长度的数组，可以将向量的头部声明为一个结构体，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">long</span> len<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token class-name">data_t</span><span class="token operator">*</span> data<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span>vec_rec<span class="token punctuation">,</span><span class="token operator">*</span>vec_ptr<span class="token punctuation">;</span></pre></td></tr></table></figure><p>其中len表示向量的长度，data_t表示向量元素的数据类型。这样的声明方式，方便测试相同的程序在处理不同类型数据的性能，除此之外，还会分配一个长度为len，数据类型为data_t的数组来存放向量的元素。</p><p>首先是一个代码示例</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">void</span> <span class="token function">combine1</span><span class="token punctuation">(</span>vec_ptr v<span class="token punctuation">,</span><span class="token class-name">data_t</span><span class="token operator">*</span> dest<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token operator">*</span>dest <span class="token operator">=</span> IDENT<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token function">vec_length</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>        <span class="token class-name">data_t</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>        <span class="token function">get_vec_element</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token operator">&amp;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>        <span class="token operator">*</span>dest <span class="token operator">=</span> <span class="token operator">*</span>dest OP val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这段代码可以实现对向量的所有元素进行求和或求积的运算，可以通过define来确定程序执行哪一种运算</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>Vector sum:</pre></td></tr><tr><td data-num=2></td><td><pre>	#define IDENT <span class="token number">0</span></pre></td></tr><tr><td data-num=3></td><td><pre>	#define OP <span class="token operator">+</span></pre></td></tr></table></figure><p>当IDENT为0，OP为加法符号时，函数执行向量元素的求和运算，如果IDENT为1，OP为乘法符号时，函数执行向量元素的乘积运算，其中函数vec_length是用来获取向量的长度，函数get_vec_element是用来获取向量第i个元素的值，结果保存在变量val中。</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>Vector multiplication:</pre></td></tr><tr><td data-num=2></td><td><pre>	#define IDENT <span class="token number">1</span></pre></td></tr><tr><td data-num=3></td><td><pre>	#define OP <span class="token operator">*</span></pre></td></tr></table></figure><p>为了评估不同版本的程序性能，假设在一台<code>Intel Core i7 Haswell</code>的机器上测试这些函数的性能。</p><p>先看下函数combine1的执行效率，实验过程中，分别用整型数据和浮点数据进行了加法和乘法的运算，在没有进行任何优化的情况下，记录函数combine1的运行时间，这里用CPE来度量，CPE表示每个元素执行所需要的时钟周期数，因此，CPE越小表示程序执行的越快。对于函数combine1在编译时采用<code>-O1</code>的优化选项时，通过测试数据可以发现，在没有修改程序源代码的情况下，单纯靠编译器的优化就能够显著的提升程序的性能。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/43.webp alt=""></p><p>通过优化代码来提升程序的性能，在函数combine1中，for循环的测试条件通过调用函数vec_length来获取向量的长度，这样一来，每次循环迭代时都要调用这个函数进行求值，实际上，向量的长度并不会随着循环的进行而改变，所以可以在循环开始之前就调用函数vec_length，然后将结果赋值给局部变量length，这样一来就不用每次迭代时都执行一次函数调用，将这种优化方式称为代码移动。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">void</span> <span class="token function">combine2</span><span class="token punctuation">(</span>vec_ptr v<span class="token punctuation">,</span><span class="token class-name">data_t</span><span class="token operator">*</span> dest<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">long</span> length <span class="token operator">=</span> <span class="token function">vec_length</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token operator">*</span>dest <span class="token operator">=</span> IDENT<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>        <span class="token class-name">data_t</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>        <span class="token function">get_vec_element</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token operator">&amp;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>        <span class="token operator">*</span>dest <span class="token operator">=</span> <span class="token operator">*</span>dest OP val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>看一下经过优化后程序的执行效率，通过测试数据可以看出虽然代码改动非常简单，不过运算效率的提升还是比较明显的。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/44.webp alt=""></p><p>为什么编译器无法自动完成代码移动来提升性能呢？这是因为编译器无法判断进行代码移动后会不会产生副作用，编译器首先需要保证程序可以得到正确的结果，其次才是优化出高性能的代码，所以为了提升程序的性能，这类优化需要手动完成。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">void</span> <span class="token function">lower1</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token char">'A'</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'Z'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=7></td><td><pre>            s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token punctuation">(</span><span class="token char">'A'</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=10></td><td><pre></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token keyword">void</span> <span class="token function">lower2</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token keyword">long</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token keyword">long</span> len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre>    </pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=17></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=18></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token char">'A'</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'Z'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=19></td><td><pre>            s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token punctuation">(</span><span class="token char">'A'</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=20></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>接着再看一个例子，这个程序是将字符串中所有的大写字母转换成小写字母，除了把对函数strlen的调用移到了循环以外，这两个函数是一样的。接下来看这两个函数运行所需要的时间，下图展示了7个不同长度的字符串的运行时间，对于函数lower1来说，字符串长度每增加一倍，运行时间都会变为原来的4倍，对于一个长度为100万的字符串，lower1竟然需要运行17分钟，这个例子说明了程序开发过程中一个常见的问题，一个看上去并不重要的代码片段却能够导致严重的性能问题。既然减少函数调用的次数可以提升程序的性能。可以看到函数combine2中还有一个函数调用<code>get_vec_element(v,i,&amp;val);</code>，如果把这个函数调用也优化了，也许性能还会有一定的提升。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">void</span> <span class="token function">combine3</span><span class="token punctuation">(</span>vec_ptr v<span class="token punctuation">,</span><span class="token class-name">data_t</span><span class="token operator">*</span> dest<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">long</span> length <span class="token operator">=</span> <span class="token function">vec_length</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token class-name">data_t</span><span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">get_vec_start</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token operator">*</span>dest <span class="token operator">=</span> IDENT<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    </pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=9></td><td><pre>        <span class="token operator">*</span>dest <span class="token operator">=</span> <span class="token operator">*</span>dest OP data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>为了消除这个函数调用，这里引入一个新的函数<code>get_vec_start</code>，它可以返回数组的起始地址，经过优化之后，函数combine3的循环中没有了函数调用，取而代之的是采用直接访问数组的方式来获取向量的元素。这里对比一下函数调用与直接数据访问的性能差异，令人遗憾的是，虽然消除了循环中函数调用，但是程序的性能并没有显著的提升，甚至整数求和的性能还下降了。</p><p>因此可以推断，循环中可能存在其他的限制因素，它对性能的限制超过了函数调用，从而导致虽然消除了函数调用也于事无补，为了找出这个限制因素，来看下函数combine3的汇编代码</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">.L17:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	vmovsd (<span class="token operator">%</span><span class="token register variable">rbx</span>),<span class="token operator">%</span><span class="token register variable">xmm0</span></pre></td></tr><tr><td data-num=3></td><td><pre>	vmulsd (<span class="token operator">%</span><span class="token register variable">rdx</span>),<span class="token operator">%</span><span class="token register variable">xmm0</span>,<span class="token operator">%</span><span class="token register variable">xmm0</span></pre></td></tr><tr><td data-num=4></td><td><pre>	vmovsd <span class="token operator">%</span><span class="token register variable">xmm0</span>,(<span class="token operator">%</span><span class="token register variable">rbx</span>)</pre></td></tr><tr><td data-num=5></td><td><pre>	addq <span class="token number">$8</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=6></td><td><pre>	cmpq <span class="token operator">%</span><span class="token register variable">rax</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=7></td><td><pre>	<span class="token label function">jne:</span> .L17</pre></td></tr></table></figure><p>从这段汇编代码可以发现，每次迭代时，累积变量的数值都要从内存中读出，然后再写入内存。其中涉及到两次读内存和一次写内存的操作。实际上，这样的读写操作很浪费时间，为了消除不必要的内存引用，可以引入一个临时变量acc，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">void</span> <span class="token function">combine3</span><span class="token punctuation">(</span>vec_ptr v<span class="token punctuation">,</span><span class="token class-name">data_t</span><span class="token operator">*</span> dest<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">long</span> length <span class="token operator">=</span> <span class="token function">vec_length</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token class-name">data_t</span><span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">get_vec_start</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token operator">*</span>dest <span class="token operator">=</span> IDENT<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    </pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=9></td><td><pre>        acc <span class="token operator">=</span> acc OP data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token operator">*</span>dest <span class="token operator">=</span> acc<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>它用来记录累积的结果，直到循环结束后再把结果写回目的地址，这样一来，每一次迭代只需要一次读内存的操作。接下来，看一下消除了内存引用之后，程序的性能是否有所提升，通过测试数据可以发现程序的性能有了显著的提高，整数加法运算从每个元素需要<code>7.17</code>个时钟周期下降到了<code>1.27</code>个，浮点数的乘法也下降到了<code>5.01</code>个时钟周期。假如对函数combine3采用<code>-O2</code>的编译选项来优化，可以得到性能与函数combine4相当的效果，不过对于整数求和的情况除外。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/45.webp alt=""></p><p>综上所述，经过优化后的程序再计算每个元素时，大概需要<code>1.255</code>个时钟周期，与最开始需要<code>9~11</code>个时钟周期相比，执行效率有了相当大的提升。</p><hr><h3 id=理解现代处理器><a class=anchor href=#理解现代处理器>#</a> 理解现代处理器</h3><p>想进一步提高程序的性能，必须考虑处理器的微体系结构来进行优化，即理解现代处理器是如何执行指令的。</p><p>下面看现代处理器是如何实现多条指令并行的，它的整体设计主要分为两部分 - 指令控制单元(ICU)和执行单元(EU)，指令控制单元负责从内存中读取指令序列，然后对指令进行译码，从而产生一系列的操作。</p><p>接下来以<code>addq %rax,%rdx</code>这条加法指令为例，它的源操作数和目的操作数都是寄存器，因此这条指令会被转化成一个加法操作。当一条指令包含内存引用和算术运算时，例如<code>addq %rax,8(%rdx)</code>这条指令，会被译码成三个操作，分别为一个读操作，一个写操作以及一个加法操作。其中读操作是从内存中读取数据到处理器中；加法操作是将从内存中读到的数值与寄存器中的数值进行相加；写操作是将加法运算得到的结果写回到内存中。</p><p>以上的译码操作对指令进行分解，允许任务在一组专门的硬件单元之间进行分割，其中读操作由加载单元来执行，而写操作由存储单元来执行，然后处理器的执行单元就可以并行的执行多条指令的不同部分，与顺序流水线相比，现代处理器的每个时钟周期可以执行多个操作，而且是乱序执行的，乱序执行的意思是允许指令的执行顺序与原始程序中的顺序不一致，当执行遇到分支时，程序有两个可能的执行方向，其中一种可能是选择分支，另外一种可能是不选择分支，现代处理器采用分支预测技术来猜测是否选择分支，同时还会预测分支的目标地址，甚至在不确定分支分支预测是否正确之前就开始执行这些命令，如果之后发现分支预测错误，会将状态重新设置到分支之前的状态，开始执行另外一个方向上的指令，将这种技术称为<strong>投机执行</strong>。当采用这种技术执行命令时，执行结果暂时不会存放到寄存器文件或内存中，直到可以确认应该执行这些指令时，再把结果写回到寄存器或内存。分支操作被指令控制单元送到执行单元，这里的分支逻辑单元是用来确定分支预测是否正确，而不是确定分支该往哪里执行，如果预测错误，执行单元会丢弃分支点之后计算出来的结果，执行单元还会告诉分支单元，预测是错误的，并指出正确的分支，此时，分支逻辑单元开始在新的位置取指。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/46.webp alt=""></p><p>之前在<code>Intel Core i7 Haswell</code>的处理器上测试了不同程序的性能，在这款处理器中，一共包含8个功能单元，这里用编号<code>0~7</code>来表示，例如编号1的逻辑单元，可以执行整数运算，整数乘法以及浮点数的加法和乘法.这里的整数运算包含加法，位级操作以及移位操作，根据下图列举的功能单元，可以统计出该处理器有4个功能单元可以执行整数运算，分别是单元0，单元1，单元5以及单元6，之后可以看到这些计算资源对程序获得最大性能所带来的影响。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/47.webp alt=""></p><p>在指令执行单元中，还有一个退役单元，它包含寄存器文件，同时控制着寄存器的更新，指令在译码时，指令的相关信息被放置在一个先进先出的队列中，这些信息会一直保持在队列中，直到发生以下两种情况中的一个。当一条指令的操作完成了，而且所有引起这条指令的分支点也都被确认为预测正确，那么这条指令就可以退役了，所有对程序寄存器的更新也可以执行了；另外一个方面，如果引起该指令的某个分支点预测错误，也就是说这条指令不应该被执行，那么这条指令会被清空，丢弃所有计算出来的结果，通过这种方法，即使预测错误也不会改变程序的状态。</p><p>接着看下这款处理器的算术运算性能，如下图，表格中的数据有些是通过测试得到的，有些是从Intel的数据手册中得到，这个表格中涉及了三个名词，延迟，发射以及容量。延迟表示完成运算所需要的总时间，例如整数加法需要一个时钟周期，而整数乘法需要3个时钟周期，发射时间表示两次运算之间间隔的最小时钟周期数，例如两次整数加法之间需要间隔1个时钟周期，而触发需要间隔<code>3~30</code>个时钟周期，容量则表示执行该运算的功能单元的数量，例如，当前这款处理器可以同时执行四个加法运算，所以整数加法的容量就是4。可以发现浮点数的运算相对于整数运算，需要更多的时钟周期数，对于除法运算，无论是整数除法还是浮点数除法，它的发射时间都等于延迟，这意味着在开始一条新运算之前，触发器必须完成整个除法运算。除法运算的延迟和发射时间都是一个范围，而不是精确的时钟周期数，这是因为除法运算需要的时间还依赖于被除数和除数。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/48.webp alt=""></p><h3 id=数据流图><a class=anchor href=#数据流图>#</a> 数据流图</h3><p>分别用延迟界限和吞吐量界限的CPE值来描述这种影响，如下图，对于任何必须严格按照顺序执行的合并运算，延迟界限给出了所需要的最小的CPE的值。由于处理器只包含一个整数乘法器，它的发射时间为1个时钟周期，因此处理器不可能支持每个时钟周期大于1条乘法的速度。处理器中包含四个整数加法单元，理论上每个周期有可能执行4个整数加法的操作，由于需要从内存中读取数据，这就造成了另外一个吞吐量界限，两个加载单元限制了处理器每个时钟周期最多能够读取两个数据值，从而使得吞吐量得界限为<code>0.5</code>。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/49.webp alt=""></p><p>接下来为延迟界限和吞吐量界限对不同版本得合并函数得影响。之前讲述了如何优化函数combine，到目前为止函数combine4是运行最快得代码，通过下图表格可以看到，除了整数加法的情况下，其他的测量值与处理器的延迟界限是一样的。这表明该函数的性能是由所执行的求和或乘积计算来决定的。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/50.webp alt=""></p><p>通常在分析程序性能时，会用到程序的数据流表示，这是一种图形化的表示方法，数据流能够展示不同操作之间的数据相关是如何限制它们的执行顺序的，这些限制形成了性能关键路径。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    acc <span class="token operator">=</span> acc OP data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">.L25:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	vmulsd (<span class="token operator">%</span><span class="token register variable">rdx</span>),<span class="token operator">%</span><span class="token register variable">xmm0</span>,<span class="token operator">%</span><span class="token register variable">xmm0</span></pre></td></tr><tr><td data-num=3></td><td><pre>	addq <span class="token number">$8</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=4></td><td><pre>	cmpq <span class="token operator">%</span><span class="token register variable">rax</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=5></td><td><pre>	jne .L25</pre></td></tr></table></figure><p>之前提到的combine4的代码实现，对于长度较大的向量来说，循环的执行是决定程序性能的主要因素，这个循环编译出的代码由4条指令组成，其中寄存器rdx中存放着指向数组data第i个元素的指针，寄存器rax中存放着指向数组末尾的指针，寄存器xmm0中存放着累计值acc，每次执行乘法累积之后，运算结果会存放到寄存器xmm0中。接着为这段循环代码的图形化表示，顶部的矩形框表示循环开始寄存器的值，而底部的矩形框表示最后寄存器的值，例如，循环开始的第一条乘法指令被扩展成一个加载操作和一个乘法操作。其中加载操作表示从内存中读取源操作数，乘法操作表示执行乘法元素，运算结果保存到寄存器xmm0中。第二条加法指令对寄存器rdx执行加8的操作，加法操作的结果写回到寄存器rdx，指令cmp用来比较寄存器rdx和寄存器rax是否相等，比较的结果会更新条件码寄存器，最后指令jne根据条件码寄存器的状态决定循环是否继续，以上就是根据汇编代码所画出的数据流图。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/51.webp alt=""></p><hr><p>在这个过程中，有些操作产生的值不对应与任何寄存器，因此，基于这段循环代码，可以将访问到的寄存器分为四类。</p><p>第一类是只读寄存器(Read-only)，它可以作为数据，也可以用来计算内存地址，这些寄存器在循环中是不会被修改的，例如寄存器rax就属于只读寄存器，它始终指向数组的结束位置。</p><p>第二类是只写寄存器(Write-only)，这类寄存器作为数据传送的目的寄存器，不过在该例子中，并没有用到这类寄存器。</p><p>第三类是局部寄存器(Local)，这些寄存器在循环内部被修改和使用，两次不同的迭代之间不相关，在这个例子中，条件码就属于局部寄存器，cmp操作会修改条件码寄存器的值，然后<code>jne</code>操作会使用条件码寄存器的值，局部寄存器的相关是存在于单次迭代之内的。</p><p>第四类是循环寄存器(Loop)，这一类寄存器既要作为源操作数，又要作为目的值，也就是说一次迭代中产生的值会在另外一次迭代中用到，例如寄存器rdx和寄存器xmm0就属于循环寄存器，因此，循环寄存器之间的操作链成为了限制程序性能的关键因素。</p><hr><p>接下来对这个数据流图作进一步的改进，调整的目标是只保留影响程序执行时间的操作以及数据相关的部分。对操作符进行了重新排列，调整后的数据流更清晰的表明了数据从顶部寄存器流向底部寄存器的过程。由于比较操作和分支操作不直接影响程序的数据流，所以将这两个操作以及寄存器rax去掉，这样数据流图中只保留了循环寄存器以及关键操作，这样一来，剩下的部分可以看成一个抽象的模板。将图中的这个模板重复n次，就可以得到函数combine4内n次迭代的数据流表示。可以看到，程序有两条数据相关链，分别对应于null操作对程序值acc的修改，以及add操作对<code>data+i</code>的修改，假设浮点数乘法的延迟为5个时钟周期，而整个加法的延迟为1个时钟周期，那么左边的链会成为关键路径，需要5n个时钟周期的执行时间，而右边的链只需要n个时钟周期就可以完成，所以左边这条链是制约性能的关键路径。对函数combine4的CPE测试结果为<code>1.27</code>，然而下图中左边和右边形成相关链来预测的CPE为<code>1.0</code>，所以，实际上的测试值比预测值要慢一些，这说明了一个问题，那就是用数据流表示的关键路径所提供的只是程序执行周期数的下界，实际上还有一些其他的因素会限制程序的性能，例如可用的功能单元的数量以及功能单元之间传递数值的数量，当合并运算的操作数为整数时，虽然数据操作足够快，但是其他操作提供数据的速度不够快，如果想要准确的确定为什么程序中每个元素需要<code>1.27</code>个周期，还需要获得处理器更详细的硬件设计才行。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/52.webp alt=""></p><h3 id=循环展开loop-unrolling><a class=anchor href=#循环展开loop-unrolling>#</a> 循环展开(Loop Unrolling)</h3><p>之前提到过向量前置和的计算问题，其中函数psum2使用了循环展开，就是每次迭代可以算出两个元素的值，这样一来所需的迭代次数就可以减半了，使用循环展开可以从两个方面提升程序的性能，首先循环展开可以减少与程序结果无关操作的数量，例如，当迭代次数减半时，循环索引的计算以及条件分支这类操作都会减少。其次，循环展开提供了一些方法，能够减少整个计算中关键路径的操作数量。</p><p>接下来看一下对函数combine使用2x1的循环展开的代码实现，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">void</span> <span class="token function">combine5</span><span class="token punctuation">(</span>vec_ptr v<span class="token punctuation">,</span><span class="token class-name">data_t</span><span class="token operator">*</span> dest<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">long</span> length <span class="token operator">=</span> <span class="token function">vec_length</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">long</span> limit <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    </pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token class-name">data_t</span><span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">get_vec_start</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token class-name">data_t</span> acc <span class="token operator">=</span> IDENT<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> limit<span class="token punctuation">;</span> i<span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>        acc <span class="token operator">=</span> <span class="token punctuation">(</span>acc OP data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> OP data<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    </pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=14></td><td><pre>        acc <span class="token operator">=</span> acc OP data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token operator">*</span>dest <span class="token operator">=</span> acc<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>期中<code>2</code>表示每一次迭代处理两个数组元素，因此，每次迭代循环的索引值i需要加2，而不是加1，当向量的长度不是2的倍数时，想要使图中的代码对任意长度的向量都能得到正确的结果。需要注意下循环的界限问题，为了确保第一次循环不会超出数组的界限，对于长度为n的向量，将循环的界限设为<code>n-1</code>，然后，保证只有当循环索引值i小于<code>n-1</code>时才会执行这个循环，那么最大的数组索引值<code>i+1</code>等于n，通过这种方法可以解决循环越界的问题。</p><p>接着看下这种变换所带来的性能提升，通过测试数据可以看出，对于整数加法，CPE从<code>1.27</code>降到了<code>1.01</code>，因为减少了循环开销操作。然而对于其他情况，性能并没有提升，这是因为它们已经达到了延迟界限，简单的循环展开无法继续降低CPE。通过测试3x1循环展开的情况，可以看到程序性能的提升止步于延迟界限。</p><p>接下来看函数combine5的汇编代码，</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">.L35:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	vmulsd (<span class="token operator">%</span><span class="token register variable">rax</span>,<span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token number">8</span>),<span class="token operator">%</span><span class="token register variable">xmm0</span>,<span class="token operator">%</span><span class="token register variable">xmm0</span></pre></td></tr><tr><td data-num=3></td><td><pre>	vmulsd <span class="token number">8</span>(<span class="token operator">%</span><span class="token register variable">rax</span>,<span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token number">8</span>),<span class="token operator">%</span><span class="token register variable">xmm0</span>,<span class="token operator">%</span><span class="token register variable">xmm0</span></pre></td></tr><tr><td data-num=4></td><td><pre>	addq <span class="token number">$2</span>,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=5></td><td><pre>	cmpq <span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token operator">%</span><span class="token register variable">rbp</span></pre></td></tr><tr><td data-num=6></td><td><pre>	jg .L35</pre></td></tr></table></figure><p>2x1的循环展开会产生两条vmulsd指令，第一条指令将<code>data[i]</code>加到acc上，第二条指令将<code>data[i+1]</code>加到acc上，其中循环的索引值i放到寄存器rdx中，每次循环执行加2的操作，数组的起始地址data放在寄存器rax中，循环的界限放在寄存器rbp中。</p><p>接下来看下这段汇编代码的图形化表示，每条vmusld指令被翻译成两个操作，一个操作是从内存中加载一个数组元素，另外一个操作是把这个值乘以已有的累积值。第二条vmulsd指令所执行的操作与第一条类似，每一条vmulsd指令都对寄存器xmm0执行了读操作和写操作，因此，每一次迭代对寄存器xmm0一共执行了两次读操作和两次写操作。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/53.webp alt=""></p><p>对这张图进行简化以及重排列之后，可以得到下图的模板。对于一个长度为n的向量的计算，把这个模板复制<code>n/2</code>次，可以得到数据流表示。可以看出，虽然迭代次数减半，但是关键路径上还有n个乘法操作，因此，无论是否执行循环展开，这条关键路径都是性能制约的主要因素。</p><hr><p>接下来是通过并行性来提升程序的性能，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">void</span> <span class="token function">combine6</span><span class="token punctuation">(</span>vec_ptr v<span class="token punctuation">,</span><span class="token class-name">data_t</span><span class="token operator">*</span> dest<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">long</span> length <span class="token operator">=</span> <span class="token function">vec_length</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">long</span> limit <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token class-name">data_t</span><span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">get_vec_start</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token class-name">data_t</span> acc0 <span class="token operator">=</span> IDENT<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token class-name">data_t</span> acc1 <span class="token operator">=</span> IDENT<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> limit<span class="token punctuation">;</span>i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>        acc0 <span class="token operator">=</span> acc0 OP data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>        acc1 <span class="token operator">=</span> acc1 OP data<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=14></td><td><pre>        acc0 <span class="token operator">=</span> acc0 OP data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token operator">*</span>dest <span class="token operator">=</span> acc0 OP acc1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这段代码不仅使用了两次循环展开，而且采用了两路并行的计算方法，其中索引值为偶数的元素累积在变量acc0中，而索引值为奇数的元素累积在变量acc1中。对于向量长度不为2的倍数时，最后的循环累积剩下的数组元素，最后将acc0和acc1进行合并运算，得到最终结果，将这种代码的实现方式称为<code>2x2循环展开</code>。</p><p>接下来看采用两路并行循环展开的执行效率，与只做循环展开相比，所有的情况都有提升。整数乘法，浮点数加法以及浮点数乘法的性能有大幅度的提升，最关键的是，这种方法打破了延迟界限的限制，处理器不再需要延迟一个加法或乘法操作来等待前一个操作完成。</p><p>接着看下combine6的汇编代码，</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">.com6:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	vmulsd (<span class="token operator">%</span><span class="token register variable">rax</span>,<span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token number">8</span>),<span class="token operator">%</span><span class="token register variable">xmm0</span></pre></td></tr><tr><td data-num=3></td><td><pre>	vmulsd <span class="token number">8</span>(<span class="token operator">%</span><span class="token register variable">rax</span>,<span class="token operator">%</span><span class="token register variable">rdx</span>,<span class="token number">8</span>),<span class="token operator">%</span><span class="token register variable">xmm1</span>,<span class="token operator">%</span><span class="token register variable">xmm1</span></pre></td></tr></table></figure><p>与函数combine5相比，函数combine6的内循环也包括两个vmulsd运算，但是它不仅用到了寄存器xmm0，还使用了寄存器xmm1。</p><p>接下来看函数combine6的数据流图，通过2x2的循环展开，整个计算的关键路径变成了两条，一条对应于计算索引为偶数的元素的乘积acc0，另外一条对应于计算机索引为奇数的元素的乘积acc1，这样一来，每条关键路径只包含<code>n/2</code>个操作，因此CPE从<code>5.0</code>下降到<code>2.5</code>。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/54.webp alt=""></p><p>通过测试数据可以发现，随着k值得增大，所有得CPE都有所改进，当k增大到10，程序的性能接近吞吐量界限，与最原始的代码相比，提升了<code>10~20</code>倍。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/55.webp alt=""></p><hr><p>除此之外，还有一种方法可以使程序的性能提高到延迟界限。之前介绍过函数combine5的代码实现<code>acc = (acc OP data[i]) OP data[i];</code>，现在调整一下括号的位置<code>acc = acc OP (data[i] OP data[i]);</code>，把这种改变称为重新结合变换，这种括号顺序的改变实际上改变了向量元素与累计值acc的合并顺序。当combine7测量CPE时，虽然整数加法的性能与函数combine5相同，但是其他三种情况与使用了并行累积变量的combine6相同，这说明，仅仅通过括号的改变就突破了延迟界限的限制，</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/56.webp alt=""></p><p>接下来看下函数combine7的汇编代码，其中指令vmovsd表示从内存中加载向量元素<code>data[i]</code>到寄存器xmm0，第一条vmulsd表示从内存中加载向量元素<code>data[i+1]</code>，然后第一个mul操作对二者执行乘法操作，第二个乘法操作是将刚才的结果乘以累计值acc，与函数combine5相比，虽然加载和乘法操作的数量是相同的，但是只有一个乘法操作形成了循环寄存器间的数据相关链，</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/57.webp alt=""></p><p>将简化后的模板复制<code>n/2</code>次，可以看到关键路径上只有<code>n/2</code>个操作，每次迭代内的第一个乘法操作都不需要等待前一次迭代的累计值就可以执行，因此可以大幅度降低CPE。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/58.webp alt=""></p><h3 id=理解内存性能><a class=anchor href=#理解内存性能>#</a> 理解内存性能</h3><p>之前使用循环展开来提升程序的性能，其中多路并行循环展开的实现方法表现突出，当并行路数达到10路时，程序的CPE接近吞吐量界限，此时，如果继续增加并行路数，通过测试数据可见程序的性能并没有提升，反而有所下降。</p><p>接下来看下二者的汇编代码，</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre>10x10 unrollong:</pre></td></tr><tr><td data-num=2></td><td><pre>	...</pre></td></tr><tr><td data-num=3></td><td><pre>	vmulsd (<span class="token operator">%</span><span class="token register variable">rdx</span>),<span class="token operator">%</span><span class="token register variable">xmm0</span>,<span class="token operator">%</span><span class="token register variable">xmm0</span></pre></td></tr><tr><td data-num=4></td><td><pre>	...</pre></td></tr><tr><td data-num=5></td><td><pre>	</pre></td></tr><tr><td data-num=6></td><td><pre>20x20 unrollong:</pre></td></tr><tr><td data-num=7></td><td><pre>	...</pre></td></tr><tr><td data-num=8></td><td><pre>	vmovsd <span class="token number">40</span>(<span class="token operator">%</span><span class="token register variable">rsp</span>),<span class="token operator">%</span><span class="token register variable">xmm0</span></pre></td></tr><tr><td data-num=9></td><td><pre>	vmulsd(<span class="token operator">%</span><span class="token register variable">rdx</span>),<span class="token operator">%</span><span class="token register variable">xmm0</span>,<span class="token operator">%</span><span class="token register variable">xmm0</span></pre></td></tr><tr><td data-num=10></td><td><pre>	vmovsd <span class="token operator">%</span><span class="token register variable">xmm0</span>,<span class="token number">40</span>(<span class="token operator">%</span><span class="token register variable">rsp</span>)</pre></td></tr></table></figure><p>例如在<code>10x10</code>的循环展开中，累积变量acc0保存在寄存器xmm0中，程序只需要从内存中读取<code>data[i]</code>，然后与这个寄存器相乘，与之相比，<code>20x20</code>循环展开差异较大。可以发现，累积变量并不是保存在寄存器中，而是保存在栈内存上，因此，程序必须从内存中读取<code>data[i]</code>和累积变量这两个数值，然后再将二者相乘的结果保存回内存。因为现代处理器<code>x86-64</code>有16个寄存器来保存浮点数，一旦循环遍历的数量超过了可用的寄存器的数量，编译器就会在栈上分配一些空间来保存部分变量，与直接使用寄存器相比，一旦将变量分配到栈上，会带来额外读写内存的开销，因此，多路并行的优势会消失，这就是<code>20x20</code>比<code>10x10</code>慢的原因。大多数循环在出现寄存器溢出之前就已经达到了吞吐量界限了，当CPE达到吞吐量界限时，即使有更多的寄存器，可以实现更多路数的循环展开，也是无法突破吞吐量界限的。</p><p><font size=3><ins><strong>加载性能(Load Performance)</strong></ins></font></p><p>通过一个例子看下加载操作的延迟，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ELF</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">ELE</span><span class="token operator">*</span> next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> data<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span>list_ele<span class="token punctuation">,</span><span class="token operator">*</span>list_ptr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">long</span> <span class="token function">list_len</span><span class="token punctuation">(</span>list_ptr ls<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">long</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span>ls<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>        len<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>        ls <span class="token operator">=</span> ls<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token keyword">return</span> len<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这个函数的功能是计算一个链表的长度，在这个循环中，变量ls的值依赖于<code>ls-&gt;next</code>的值，然后通过判断变量ls是否指向链表尾部来决定是否继续执行，通过测试表明函数list_len的CPE为<code>4.0</code>。</p><p>接下来看这个while循环的汇编代码，</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">.L3:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	addq <span class="token number">$1</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=3></td><td><pre>	movq (<span class="token operator">%</span><span class="token register variable">rdi</span>),<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=4></td><td><pre>	testq <span class="token operator">%</span><span class="token register variable">rdi</span>,<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=5></td><td><pre>	jne .L3</pre></td></tr></table></figure><p>变量len存放在寄存器rax中，每次循环执行加1的操作，变量ls存放在寄存器rdi中，指令movq表示从内存中加载数据到寄存器rdi，其中<code>(%rdi)</code>表示这个加载操作的内存地址需要从寄存器rdi中读取。可以发现后面寄存器rdi的每个值都要依赖于加载操作的结果，而加载操作又以寄存器rdi中的值作为它的地址，因此，直到前一次迭代的加载操作完成，下一次迭代的加载操作才能开始，因此函数list_len的CPE等于<code>4.0</code>是由于加载操作的延迟决定的，实际上，这台测试机器的文档中给出了<code>L1 cache</code>的访问时间是4个时钟周期，这个测试结果与文档的参考数据也是一致的。</p><p><font size=3><ins><strong>存储性能(Store Performance)</strong></ins></font></p><p>迄今为止的示例所分析的大部分内存引用都是加载操作，也就是从内存读取数据到寄存器中，与加载操作对应的是存储操作，它是将一个寄存器的值写到内存，存储操作并不会影响任何寄存器的值，通常情况下，存储操作不会产生数据相关，不过，当加载操作需要从存储操作写的那个内存位置读取数据时，加载操作和存储操作之间可能会相互影响。</p><p>接下来通过一个代码示例来看一下其中的影响，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">void</span> <span class="token function">write_read</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token operator">*</span> src<span class="token punctuation">,</span><span class="token keyword">long</span><span class="token operator">*</span> dst<span class="token punctuation">,</span><span class="token keyword">long</span> n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">long</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">long</span> val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    </pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span>cnt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>        <span class="token operator">*</span>dst <span class="token operator">=</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>        val <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>src<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>        cnt<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=12></td><td><pre></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token comment">// Example A: CPE:1.3</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token function">write_read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token comment">// Example B: CPE:7.3</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token function">write_read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>当这个函数分别传入两组不同的参数时，通过性能测试表明示例A的CPE等于<code>1.3</code>，示例B的CPE却等于<code>7.3</code>，由于示例B中，参数src和dest指向了同一个内存位置，使得内存读的结果依赖于最近的内存写的操作，将这种情况称为<code>写/读</code>相关。为了探究二者的性能差异，来看一下这个循环的汇编代码，其中指令movq被翻译成两个独立的操作，一个是计算存储操作的地址s_addr，另外一个是将数据加载到内存的操作s_data，对于下一条movq指令所执行的加载操作需要从寄存器rdi处读取数据，将寄存器rsi中保存的地址为addr1，寄存器rdi中保存的地址记为addr2，如果两个地址相同，加载操作必须等待s_data操作完成之后才读取数据，否则就会取到错误的数据；如果两个地址不同，两个操作就可以独立的进行了，这就是<code>写/读</code>相关所导致的处理速度下降，综上所述，关于内存操作的实现包括许多细微之处，对于寄存器的操作，在指令被译码成具体操作的时候，处理器就能确定哪些指令之间会存在相关性，而对于内存操作，只有当加载地址和存储地址被计算出来之后，才能确定哪些指令之间会相互影响。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part2/59.webp alt=""></p><p><font size=3><ins><strong>总结下程序性能优化的基本策略</strong></ins></font></p><p><code>High-level design</code>(高级设计) - 第一针对具体的问题选择适当的算法和数据结构</p><p><code>Basic coding principles</code>(基本编码原则) - 第二遵循一些基本的编码原则，例如消除连续的函数调用以及消除不必要的内存引用</p><p><code>Low-level optimizations</code>(低级优化) - 第三是根据硬件的设计，利用循环展开等技术来提高指令级并行，不过需要注意的是避免在重写程序时引入错误，尤其是引入新的变量以及改变循环边界时，很容易犯错，需要充分测试新版本的代码，确保他们与原来的代码产生一样的结果。</p><h2 id=存储器层次结构the-memory-hierarchy><a class=anchor href=#存储器层次结构the-memory-hierarchy>#</a> 存储器层次结构(The Memory Hierarchy)</h2><p>存储器的层次结构对应用程序的性能有着巨大的影响，如果程序需要的数据存储在寄存器中，那么在指令执行时，可以立即使用这些数据，如果数据存储在cache(高速缓存)中，那么获取这些数据需要<code>4~75</code>个时钟周期，当数据存储在内存中，则需要几百个时钟周期，如果数据存储在磁盘上，就需要大约几千万个时钟周期，由于不同的存储器采用了不同的存储技术，因此，导致了访问速度以及价格方面的差异。</p><h3 id=随机访问存储器random-access-memory-ram><a class=anchor href=#随机访问存储器random-access-memory-ram>#</a> 随机访问存储器(Random Access Memory - RAM)</h3><p>RAM分为两类，<strong>静态RAM</strong>(Static RAM - SRAM)与<strong>动态RAM</strong>(Dynamic RAM - DRAM)。</p><p>由于SRAM与DRAM的结构不同，导致了二者在访问速度的差异，其中SRAM将每个bit位的信息存储在一个双稳态的存储器单元内，每个存储单元需要六个晶体管来实现。关于双稳态结构</p><div class=tags><a href=/tags/computer-basic/ rel=tag><i class="ic i-tag"></i> 计算机基础</a></div></div><footer><div class=meta><span class=item><span class=icon><i class="ic i-calendar-check"></i></span> <span class=text>更新于</span> <time title="修改时间：2025-09-19 22:24:59" itemprop=dateModified datetime=2025-09-19T22:24:59+08:00>2025-09-19</time></span><span class=item data-path=/computer-science/computer-basic/composition/ccppart2/ title=阅读次数><span class=icon><i class="ic i-eye"></i></span> <span class=text>阅读次数</span><span class=waline-pageview-count></span> <span class=text>次</span></span></div><div id=copyright><ul><li class=author><strong>本文作者：</strong> ReverseSacle <i class="ic i-at"><em>@</em></i>逆转天平</li><li class=link><strong>本文链接：</strong> <a href=https://www.reversesacle.com/computer-science/computer-basic/composition/ccppart2/ title=计算机组成原理-CSAPP-第二部分>https://www.reversesacle.com/computer-science/computer-basic/composition/ccppart2/</a></li><li class=license><strong>版权声明：</strong> 本站所有文章除特别声明外，均采用 <span class=exturl data-url=aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class=post-nav><div class="item left"><a href=/computer-science/computer-basic/composition/ccppart1/ itemprop=url rel=prev data-background-image=https:&#x2F;&#x2F;resa-imgs.oss-accelerate.aliyuncs.com&#x2F;img&#x2F;acg14.webp title=计算机组成原理-CSAPP-第一部分><span class=type>上一篇</span><span class=category><i class="ic i-flag"></i> 计算机组成原理</span><h3>计算机组成原理-CSAPP-第一部分</h3></a></div><div class="item right"><a href=/computer-science/computer-basic/composition/ccppart3/ itemprop=url rel=next data-background-image=https:&#x2F;&#x2F;resa-imgs.oss-accelerate.aliyuncs.com&#x2F;img&#x2F;acg3.webp title=计算机组成原理-CSAPP-第三部分><span class=type>下一篇</span><span class=category><i class="ic i-flag"></i> 计算机组成原理</span><h3>计算机组成原理-CSAPP-第三部分</h3></a></div></div><div class=wrap id=comments><div id=waline-comment></div></div></div><div id=sidebar><div class=inner><div class=panels><div class=inner><div class="contents panel pjax" data-title=文章目录><ol class=toc><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84processor-architecture><span class=toc-number>1.</span> <span class=toc-text>处理器体系结构(Processor Architecture)</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84instruction-set-architecture><span class=toc-number>1.1.</span> <span class=toc-text>指令系统结构(Instruction Set Architecture)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1><span class=toc-number>1.2.</span> <span class=toc-text>数字电路与处理器设计</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#y86-64%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0><span class=toc-number>1.3.</span> <span class=toc-text>Y86-64的顺序实现</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#y86-64%E5%A4%84%E7%90%86%E5%99%A8%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84><span class=toc-number>1.4.</span> <span class=toc-text>Y86-64处理器硬件结构</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E9%80%9A%E7%94%A8%E5%B1%9E%E6%80%A7%E5%92%8C%E5%8E%9F%E7%90%86><span class=toc-number>1.5.</span> <span class=toc-text>流水线的通用属性和原理</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84><span class=toc-number>1.6.</span> <span class=toc-text>流水线硬件结构</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9><span class=toc-number>1.7.</span> <span class=toc-text>数据冒险</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%8E%A7%E5%88%B6%E5%86%92%E9%99%A9><span class=toc-number>1.8.</span> <span class=toc-text>控制冒险</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#y86-64%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%AE%9E%E7%8E%B0><span class=toc-number>1.9.</span> <span class=toc-text>Y86-64的流水线实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BDoptimizing-program-performance><span class=toc-number>2.</span> <span class=toc-text>优化程序性能(Optimizing Program Performance)</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7><span class=toc-number>2.1.</span> <span class=toc-text>编译器优化程序的局限性</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%90%86%E8%A7%A3%E7%8E%B0%E4%BB%A3%E5%A4%84%E7%90%86%E5%99%A8><span class=toc-number>2.2.</span> <span class=toc-text>理解现代处理器</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE><span class=toc-number>2.3.</span> <span class=toc-text>数据流图</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80loop-unrolling><span class=toc-number>2.4.</span> <span class=toc-text>循环展开(Loop Unrolling)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E6%80%A7%E8%83%BD><span class=toc-number>2.5.</span> <span class=toc-text>理解内存性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84the-memory-hierarchy><span class=toc-number>3.</span> <span class=toc-text>存储器层次结构(The Memory Hierarchy)</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8%E5%99%A8random-access-memory-ram><span class=toc-number>3.1.</span> <span class=toc-text>随机访问存储器(Random Access Memory - RAM)</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title=系列文章><ul><li><a href=/computer-science/computer-basic/composition/ccppart1/ rel=bookmark title=计算机组成原理-CSAPP-第一部分>计算机组成原理-CSAPP-第一部分</a></li><li class=active><a href=/computer-science/computer-basic/composition/ccppart2/ rel=bookmark title=计算机组成原理-CSAPP-第二部分>计算机组成原理-CSAPP-第二部分</a></li><li><a href=/computer-science/computer-basic/composition/ccppart3/ rel=bookmark title=计算机组成原理-CSAPP-第三部分>计算机组成原理-CSAPP-第三部分</a></li><li><a href=/computer-science/computer-basic/composition/ccppart4/ rel=bookmark title=计算机组成原理-CSAPP-第四部分>计算机组成原理-CSAPP-第四部分</a></li></ul></div><div class="overview panel" data-title=站点概览><div class=author itemprop=author itemscope itemtype=http://schema.org/Person><img class=image itemprop=image alt=ReverseSacle data-src=/images/avatar.webp><p class=name itemprop=name>ReverseSacle</p><div class=description itemprop=description>知识书库 & 学习点滴</div></div><nav class=state><div class="item posts"><a href=/archives/ ><span class=count>186</span> <span class=name>文章</span></a></div><div class="item categories"><a href=/categories/ ><span class=count>52</span> <span class=name>分类</span></a></div><div class="item tags"><a href=/tags/ ><span class=count>18</span> <span class=name>标签</span></a></div></nav><div class=social><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JldmVyc2VTYWNsZQ==" title=https:&#x2F;&#x2F;github.com&#x2F;ReverseSacle><i class="ic i-github"></i></span><span class="exturl item email" data-url="bWFpbHRvOnByaXZhdGVAcmV2ZXJzZXNhY2xlLmNvbQ==" title=mailto:private@reversesacle.com><i class="ic i-envelope"></i></span></div><ul class=menu><li class=item><a href=/ rel=section><i class="ic i-home"></i> 首页</a></li><li class="item dropdown"><a href=javascript:void(0);><i class="ic i-feather"></i> 文章</a><ul class=submenu><li class=item><a href=/archives/ rel=section><i class="ic i-list-alt"></i> 归档</a></li><li class=item><a href=/categories/ rel=section><i class="ic i-th"></i> 分类</a></li><li class=item><a href=/tags/ rel=section><i class="ic i-tags"></i> 标签</a></li></ul></li><li class=item><a href=/about/ rel=section><i class="ic i-user"></i> 关于</a></li><li class=item><a href=/friend-links/ rel=section><i class="ic i-heart"></i> 友链</a></li></ul></div></div></div><ul id=quick><li class="prev pjax"><a href=/computer-science/computer-basic/composition/ccppart1/ rel=prev title=上一篇><i class="ic i-chevron-left"></i></a></li><li class=up><i class="ic i-arrow-up"></i></li><li class=down><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href=/computer-science/computer-basic/composition/ccppart3/ rel=next title=下一篇><i class="ic i-chevron-right"></i></a></li><li class=percent></li></ul></div></div><div class=dimmer></div></div></main><footer id=footer><div class=inner><div class=widgets><div class="rpost pjax"><h2>随机文章</h2><ul><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/c-basic/ title="分类于 C语言基础">C语言基础</a></div><span><a href=/computer-science/programming/c-language/basis/c/cpart1/ title=C语言基础-第一部分-C89&#x2F;C90标准>C语言基础-第一部分-C89/C90标准</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/database/ title="分类于 数据库">数据库</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/database/mysql/ title="分类于 MySQL">MySQL</a></div><span><a href=/computer-science/programming/database/mysql/mspart1/ title=MySQL数据库基础-第一部分>MySQL数据库基础-第一部分</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/reverse-engineering/ title="分类于 逆向工程">逆向工程</a></div><span><a href=/computer-science/programming/reverse-engineering/cheatengine/ title=CheatEngine基础>CheatEngine基础</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a></div><span><a href=/computer-science/programming/c-language/c-data-structure/linear-structure/dynamic-seqstring/ title=C语言-字符动态结构存储>C语言-字符动态结构存储</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/c-data-structure/ title="分类于 C语言数据结构">C语言数据结构</a></div><span><a href=/computer-science/programming/c-language/c-data-structure/compressed-sparse-matrix/ title=结构数组之稀疏矩阵的压缩>结构数组之稀疏矩阵的压缩</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a></div><span><a href=/computer-science/programming/c-language/c-data-structure/linear-structure/single-link-list/ title=C语言-单向链表>C语言-单向链表</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/seqlist/ title="分类于 顺序表">顺序表</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/seqlist/trick/ title=顺序表基础技巧>顺序表基础技巧</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a></div><span><a href=/computer-science/programming/c-language/c-data-structure/linear-structure/link-queue/ title=C语言-链队列>C语言-链队列</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/c-data-structure/ title="分类于 C语言数据结构">C语言数据结构</a></div><span><a href=/computer-science/programming/c-language/c-data-structure/stack/ title=线性表之栈>线性表之栈</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/string/ title="分类于 字符串">字符串</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/string/pattern/ title=字符串-模式>字符串-模式</a></span></li></ul></div><div><h2>最新评论</h2><ul id=waline-recent></ul></div></div><div class=status><div class=copyright>&copy; 2021 – <span itemprop=copyrightYear>2025</span><span class=with-love><i class="ic i-sakura rotate"></i></span> <span class=author itemprop=copyrightHolder>ReverseSacle @ ReverseSacle-Blog</span></div><div class=count><i class="ic i-clock" aria-hidden=true></i> <span id=time align=center>载入时间中...<script defer>var now=new Date;function createtime(){var n=new Date("2021-11-16 22:30:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("time").innerHTML="已经过 "+dnum+" 天 "+hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></span><span class=post-meta-item-icon>|&nbsp<i class="ic i-chart-area"></i></span> <span title=站点总字数>2.1m 字</span> <span class=post-meta-item-icon>|&nbsp<i class="ic i-coffee"></i></span> <span title=站点阅读时长>40:40</span></div></div></div></footer></div><script data-config>var LOCAL={path:"computer-science/computer-basic/composition/ccppart2/",favicon:{show:"ReverseSacle-Blog",hide:"ReverseSacle-Blog"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},waline:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src=https://polyfill.alicdn.com/v3/polyfill.min.js></script><script src=https://cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1.16.0/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js></script><script src=/js/app.js></script></body></html>