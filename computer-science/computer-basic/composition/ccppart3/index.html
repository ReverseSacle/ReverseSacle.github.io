<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content=#222><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=icon type=image/ico sizes=48x48 href=/images/favicon.ico><link rel=alternate type=application/rss+xml title=逆转天平 href=https://www.reversesacle.com/rss.xml><link rel=alternate type=application/atom+xml title=逆转天平 href=https://www.reversesacle.com/atom.xml><link rel=alternate type=application/json title=逆转天平 href=https://www.reversesacle.com/feed.json><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel=stylesheet href=/css/app.css><meta name=description content=计算机基础><link rel=canonical href=https://www.reversesacle.com/computer-science/computer-basic/composition/ccppart3/ ><title>计算机组成原理-CSAPP-第三部分 - 计算机组成原理 - 计算机基础 - 计算机科学 | ReverseSacle-Blog</title><meta name=generator content="Hexo 6.3.0"></head><body itemscope itemtype=http://schema.org/WebPage><div id=loading><div class=dotloader><div class=dot></div><div class=dot></div><div class=dot></div><div class=dot></div><div class=dot></div></div></div><div id=container><header id=header itemscope itemtype=http://schema.org/WPHeader><div class=inner><div id=brand><div class=pjax><h1 itemprop="name headline">计算机组成原理-CSAPP-第三部分</h1><div class=meta><span class=item title="创建时间：2023-10-09 19:43:12"><span class=icon><i class="ic i-calendar"></i></span> <span class=text>发表于</span> <time itemprop="dateCreated datePublished" datetime=2023-10-09T19:43:12+08:00>2023-10-09</time></span><span class=item title=本文字数><span class=icon><i class="ic i-pen"></i></span> <span class=text>本文字数</span> <span>33k</span> <span class=text>字</span></span><span class=item title=阅读时长><span class=icon><i class="ic i-clock"></i></span> <span class=text>阅读时长</span> <span>38 分钟</span></span></div></div></div><nav id=nav><div class=inner><div class=toggle><div class=lines role=navigation aria-label=切换导航栏><span class=line></span><span class=line></span><span class=line></span></div></div><ul class=menu><li class="item title"><a href=/ rel=start>ReverseSacle-Blog</a></li></ul><ul class=right><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id=imgs class=pjax><ul><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg9.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg18.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg10.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg15.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg5.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg8.webp></li></ul></div></header><div id=waves><svg class=waves xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink viewBox="0 24 150 28" preserveAspectRatio=none shape-rendering=auto><defs><path id=gentle-wave d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352z"/></defs><g class=parallax><use xlink:href=#gentle-wave x=48 y=0 /><use xlink:href=#gentle-wave x=48 y=3 /><use xlink:href=#gentle-wave x=48 y=5 /><use xlink:href=#gentle-wave x=48 y=7 /></g></svg></div><main><div class=inner><div id=main class=pjax><div class="article wrap"><div class=breadcrumb itemscope itemtype=https://schema.org/BreadcrumbList><i class="ic i-home"></i> <span><a href=/ >首页</a></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/ itemprop=item rel=index title="分类于 计算机科学"><span itemprop=name>计算机科学</span></a><meta itemprop=position content=1></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/computer-basic/ itemprop=item rel=index title="分类于 计算机基础"><span itemprop=name>计算机基础</span></a><meta itemprop=position content=2></span><i class="ic i-angle-right"></i> <span class=current itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/computer-basic/computer-composition-principles/ itemprop=item rel=index title="分类于 计算机组成原理"><span itemprop=name>计算机组成原理</span></a><meta itemprop=position content=3></span></div><article itemscope itemtype=http://schema.org/Article class="post block" lang=zh-CN><link itemprop=mainEntityOfPage href=https://www.reversesacle.com/computer-science/computer-basic/composition/ccppart3/ ><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content=/images/avatar.webp><meta itemprop=name content=ReverseSacle><meta itemprop=description content="所见即所得，所思即所行, 知识书库 & 学习点滴"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content=逆转天平></span><div class="body md" itemprop=articleBody><h2 id=存储器层次结构the-memory-hierarchy><a class=anchor href=#存储器层次结构the-memory-hierarchy>#</a> 存储器层次结构(The Memory Hierarchy)</h2><p>存储器的层次结构对应用程序的性能有着巨大的影响，如果程序需要的数据存储在寄存器中，那么在指令执行时，可以立即使用这些数据，如果数据存储在cache(高速缓存)中，那么获取这些数据需要<code>4~75</code>个时钟周期，当数据存储在内存中，则需要几百个时钟周期，如果数据存储在磁盘上，就需要大约几千万个时钟周期，由于不同的存储器采用了不同的存储技术，因此，导致了访问速度以及价格方面的差异。</p><h3 id=随机访问存储器random-access-memory-ram><a class=anchor href=#随机访问存储器random-access-memory-ram>#</a> 随机访问存储器(Random Access Memory - RAM)</h3><p>RAM分为两类，<strong>静态RAM</strong>(Static RAM - SRAM)与<strong>动态RAM</strong>(Dynamic RAM - DRAM)。</p><p>由于SRAM与DRAM的结构不同，导致了二者在访问速度的差异，其中SRAM将每个bit位的信息存储在一个双稳态的存储器单元内，每个存储单元需要六个晶体管来实现。关于双稳态结构，可以借助钟摆模型来理解，当钟摆倾斜到最左边或最右边时，它的状态是最稳定的，理论上，钟摆也能在垂直的位置上保持平衡。不过这个状态是不稳定的，一个细微的扰动就能使它倒下，并且倒下之后无法恢复到从前的垂直状态，正是由于SRAM的存储单元具有双稳态的特性，所以只要有电，它就能够一直保持所存储的数据。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/1.webp alt=""></p><p>与SRAM相比，DRAM存储信息的原理是电容充电，对于DRAM结构，每个bit位的存储对应一个电容和一个晶体管，这个电容是非常非常小的。</p><p>与SRAM不同，DRAM的存储单元对干扰十分敏感，当电容的电压被扰乱之后，就再也无法恢复到干扰之前，虽然SRAM的速度要比DRAM快，但是在价格方面要更贵，处理器芯片内的cache(高速缓存)采用的就是SRAM，而内存采用的是DRAM。</p><p>此外，DRAM还有另外一个缺陷，就是会有很多原因导致漏电，使得DRAM会在<code>10~100</code>毫秒内失去电荷，因此内存系统需要不断的读出数据，然后重写来刷新内存的每一位，只有通过不断的刷新才能保持数据，不过幸运的是，处理器运行的时钟周期是以纳秒来衡量的，所以相对而言这个保持时间还是比较长的。</p><p>接下来通过一个例子来看下DRAM的内部结构，下图展示了一个<code>16x8</code>的DRAM芯片，其中16表示的是超单元的个数，8表示每个超单元可以存储8bit的数据，由于存储领域从来都没有为DRAM的阵列元素确定一个标准的名字，为了避免混淆，原书中采用了<strong>超单元</strong>一词来表示DRAM的存储单元。通过下图可以看到所有的超单元被组织成一个<code>4x4</code>的阵列，每个超单元可以通过类似坐标的方式<code>(i,j)</code>进行寻址，其中i表示行，j表示列，整个DRAM芯片通过地址引脚和数据引脚与内存控制器相连，简单来讲，内存控制器主要是用来管理内存的。关于内存控制器，假如将数据比喻成书，内存就相当于是一个图书馆，而内存控制器可以看成图书管理员。例如需要从DRAM芯片中读出图中所示的超单元<code>(2,1)</code>，首先，内存控制器发送行地址2到DRAM芯片，DRAM所作出的响应就是将整个第二行的内容全部复制到内部的行缓冲区中。接下来，内存控制器发送列地址1到DRAM芯片，DRAM对应的操作是从这个行缓冲区中复制出对应的数据位，并把它们发送到内存控制器。为什么要分两次发送地址，这样不是增加了访问时间吗？这是因为DRAM芯片的设计人员将存储单元设计成了二维的阵列，而不是线性的数组，这样设计的好处是可以降低芯片上地址引脚的数量，如果将示例中128位(<code>16x8</code>)DRAM的存储单元用线性数组来表示，那么地址范围就是<code>015</code>，为了实现线性寻找就需要4个地址引脚，而二维阵列的组织方式只需要2个引脚就可以了，不过二维阵列的组织方式会增加数据访问的时间。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/2.webp alt=""></p><p>接下来，看下采用DRAM芯片封装成的内存模块，下图展示了一个内存模块的基本组成，这个模块一共用了8个DRAM芯片，分别用编号<code>0~7</code>来表示，每个DRAM芯片大小是8MX8(8MX8bit)，也就是8MB。因此，整个模块的大小为64MB。每个超单元可以存储8bit的数据，那么对于8字节(64bit)的数据就需要8个超单元来存储，不过这8个超单元并不在同一个DRAM芯片上，而是平均分布在8个DRAM芯片上，其中<code>DRAM 0</code>存储低8位，<code>DRAM 1</code>存储下一个字节，以此类推，<code>DRAM 7</code>存储最高8位，当处理器向内存控制器发起读取数据的请求时，内存控制器将地址转换成超单元的地址<code>(i,j)</code>，然后把它发送到内存模块，然后内存模块再将行地址i和列地址j广播到每个DRAM，每个DRAM都会输出它对应超单元的数据，最终内存模块将所有超单元的数据合并成一个64bit的数据返回给内存控制器，如下图，为了跟上迅速增长的处理器的速度，市场上会定期推出新的DRAM，这些新的DRAM都是基于传统的DRAM单元，然后进行一些优化。例如经常看到的DDR3，DDR4或LPDDR等，其中DDR的全称是<code>DDR SDRAM</code>(Double Data-Rate Synchronous DRAM - 双倍速率同步动态随机存储器)，SDRAM中的S表示同步而不是静态，同步DRAM比异步DRAM的速度更快。关于DDR2，DDR3以及DDR4这些缩写中的数字(2，3，4)表示不同代，例如4代的DDR要比3代的DDR读写速度要快，速度的提升主要依靠扩大预取缓冲区的位数，例如DDR4的预取缓冲区是16bit，DDR3是8bit，此外，智能手机中的内存几乎全部都是采用LPDDR，其中LP是<code>Low Power</code>的缩写，与DDR4相比，LPDDR的功耗更低，不过DDR4的延迟更小，目前市场上有许多商务笔记本也开始选用LPDDR作为内存，所以LPDDR更适合应用在功耗敏感的设备上。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/3.webp alt=""></p><h3 id=机械磁盘旋转磁盘rotating-disk><a class=anchor href=#机械磁盘旋转磁盘rotating-disk>#</a> 机械磁盘(旋转磁盘，Rotating Disk)</h3><p>在断电的情况下也能保存数据的存储介质 - 磁盘，目前市面上主流的磁盘产品有两类，分别是机械磁盘和固态硬盘。</p><p>下图为磁盘的内部结构示意图，它主要依靠盘片来存储数据，盘片的表明涂有磁性的记录材料，通常情况下，磁盘由一个或多个盘片组成，这些盘片被固定在一个还可以旋转的主轴上，主轴带动盘片以固定的旋转速率进行高速的旋转，例如图中这个磁盘包含三个盘片，一共有6个表面可以用来存储数据。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/4.webp alt=""></p><p>其中盘片的表面被划分成了一圈一圈的磁道，这里用同心圆表示，每个磁道又被划分成了多个扇区，通常情况下，每个扇区可以存储512个字节的数据，其中扇区与扇区之间会有一些间隙，这些间隙是用来存放扇区的标识信息，不能用来存储数据。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/5.webp alt=""></p><p>磁盘通过<code>读/写</code>头来读写存储在盘片表面的数据，盘片的每个表面都对应着一个独立的<code>读/写</code>头，所有的<code>读/写</code>头连接到一个传动臂上，通过传动臂在半径方向上的移动，这样<code>读/写</code>头可以读取任意磁道上的数据，把这种机械运动称为寻道。通过传动臂的移动，可以将<code>读/写</code>头定位在任意磁道上，在完成寻道之后，<code>读/写</code>头就保持不动了。如果想要完成对目标扇区的读写操作，需要通过盘片旋转来配合，<code>读/写</code>头可以读出相应的数据位，也可以修改相应数据的值，注意，所有的<code>读/写</code>头都是垂直排列，一致行动的，其中<code>读/写</code>头距离表面的高度大约是<code>0.1</code>微米，在这样狭小的间隙里，任何微小的灰尘或剧烈的震动都有可能导致<code>读/写</code>头撞向盘面，从而导致磁盘损坏。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/6.webp alt=""></p><p>通常关注最多的是磁盘的容量，也就是能存多少数据，磁盘制造商会使用GB(gigabytes)或TB(terabytes)为单位来标识磁盘的容量，但是这里的1GB等于10的9次方字节，1TB等于10的12次方字节。对于K，M，G这样的前缀，它们所表达的含义还要依赖于上下文。</p><p>对于SRAM和DRAM这一类设备，通常情况，K等于2的10次方，M等于2的20次方，但是对于像磁盘和网络这样的<code>I/O</code>设备，通常情况，K等于10的3次方，M等于10的6次方等。对于2的30次方与10的9次方之间差别不大，大约相差7%左右。</p><hr><p>除了容量之外，磁盘的读写速度也是一个非常重要的指标，对扇区的访问时间主要分为三部分，分别是寻道时间，旋转时间以及传送时间。</p><p><font size=3><ins><strong>寻道时间(Seek time)</strong></ins></font></p><p>当目标扇区所处的磁道与当前<code>读/写</code>头所在的磁道不同时，那么传动臂需要将<code>读/写</code>头移动到目标扇区所在磁道，传动臂移动所需的时间就是寻道时间，主要取决于<code>读/写</code>头的当前位置与目标位置的距离，寻道有可能发生在两个相邻的磁道之间，此时寻道时间会比较短，也有可能是从最内侧磁道移动到最外侧磁道，遇到这种情况时寻道时间就会比较长，因此，寻道时间并不是一个固定的数值，通过对随机扇区的访问测试，通常平均寻道时间在<code>3~9ms</code>左右。一旦<code>读/写</code>头移动到期望的磁道上，接下来，还需要等待目标扇区的第一个数据位旋转到<code>读/写</code>头下才能读取数据，这个过程的性能由两个因素决定，一个是当前<code>读/写</code>头所在扇区位置与目标扇区的距离，最坏的情况是，<code>读/写</code>头刚刚错过了目标扇区，所以必须等待盘片转一圈才能读取数据。</p><p><font size=3><ins><strong>旋转时间(Rotational time)</strong></ins></font></p><p>另外一个是盘片的旋转速度，例如一个磁盘的旋转速率是7200RPM(转每分)，也就是盘片一分钟可以转7200圈，那么转一圈大约需要8ms，所以在最坏的情况下的最大旋转延迟大约是8ms，对于一般情况，平均旋转时间是最大旋转延迟的一半，约为4ms。最后当<code>读/写</code>头位于目标扇区时，就可以读取(或写入)数据了。</p><p><font size=3><ins><strong>传送时间(Transfer time)</strong></ins></font></p><p>一个扇区的传送时间依赖于旋转速度以及每条磁道的扇区数目，假设每条磁道的平均扇区数是400个，转一圈需要8ms，所以转过一个扇区大约需要<code>0.02</code>ms，也就是数据传送需要<code>0.02</code>ms就可以完成，</p><hr><p>访问一个磁盘扇区所花费的时间主要是寻道时间和旋转时间。机械磁盘的内部结构，不仅包含多个盘面，而且这些盘面上还有不同的记录区，但是从操作系统的视角看，整个磁盘被抽象成了一个个的逻辑块序列，每个逻辑块的大小与磁盘扇区的容量是一致的，都是512个字节，磁盘内部有一个小二点固件设备，称为磁盘控制器，维护着逻辑块与实际磁盘扇区之间的映射关系，当操作系统执行从硬盘读取数据到内存时，操作系统会发送一个命令到磁盘控制器，这个命令就是让磁盘控制器读取特定逻辑块号的数据，根据磁盘的结构特性，可以使用(盘面，磁道，扇区)，这样的三元组来唯一标识每一个物理扇区，磁盘控制器上的固件程序的任务就是将逻辑块号翻译成对应的三元组信息。接下来，控制器会根据这个三元组的信息来执行移动<code>读/写</code>头以及旋转盘面的操作，然后<code>读/写</code>头会把读到的数据放到一个缓冲区中，最后将目标数据复制到内存里，</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/7.webp alt=""></p><h3 id=固态硬盘solid-state-disk><a class=anchor href=#固态硬盘solid-state-disk>#</a> 固态硬盘(Solid State Disk)</h3><p>固态硬盘是由一个或多个闪存芯片组成的，它使用了闪存芯片取代了传动臂加盘片这种机械式的工作方式，除此之外，固态硬盘还包含一个闪存转换层(flash translation layer - FTL)，它的功能与磁盘控制器类似，都是将操作系统对逻辑块的请求翻译成对底层物理设备的访问，不同的是闪存芯片是基于Nand Flash实现的。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/8.webp alt=""></p><p>闪存芯片的内部结构组成，每一颗闪存芯片是由一个或多个Die组成，每个Die可以分为多个plane，每个plane包含多个block，block与逻辑块是没有关系的，Block的内部又分成了多个page。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/9.webp alt=""></p><p>对于固态硬盘，数据是以page为单位读写的，与机械磁盘相比(扇区的大小总是固定的512字节)，对于不同规格的闪存芯片，其中page大小可能并不相同，在有些闪存芯片中一个page的大小是512字节，还有的是1KB或2KB，甚至更大，传统的机械磁盘包含读和写这两个基本操作。对于固态硬盘，除了这两个基本的操作之外，还多了一个擦除的操作。由于闪存编程(写入)原理的限制，只能将1改为0，而不能将0改为1，所以一个page在写入数据之前，所有的存储位都是1，对于写入操作的本质就是将某些存储位从1变为0，写入操作是以page为单位的，在写入之前页是需要擦除的，不能直接覆盖。对于擦除操作是以block为单位的，擦除操作的本质就是将所有的存储位都变为1。当一个block完成了擦除操作，那么这个block中所有包含的所有page都被擦除了，此时所有page都能够执行一次写操作，在经过一定次数的擦除之后，block就会发生磨损，一旦一个block发生损坏之后，就不能再使用了。因此，固态硬盘中的闪存翻译层会使用平均磨损算法，将擦除平均到所有的块上来最大化每个块的寿命。如果平均磨损处理的好，固态硬盘也要好多年才能磨损。比起机械硬盘，由于固态硬盘是由半导体存储器构成的，没有移动的机械部件，因此，随机访问时间要比机械磁盘要快，功耗也更低，同时也更抗摔，缺点是固态硬盘的价格要贵一些。</p><p>从上述存储技术的介绍，可得出以下几个结论</p><ul><li>不同的存储技术有不同价格和性能的折中，从存取速度上来说，SRAM最快，DRAM其次，磁盘最慢，不过速度越快，价格也就越贵</li><li>不同存储技术的价格和性能的改变速率不同</li><li>DRAM和磁盘的性能滞后于CPU的性能</li></ul><h3 id=程序的局部性><a class=anchor href=#程序的局部性>#</a> 程序的局部性</h3><p>局部性通常有两种不同的形式，分别是时间局部性(temporal locality)和空间局部性(spatial locality)。如果被引用过的内存位置很可能在不远的将来还会被多次引用，此时可以说程序具有良好的时间局部性。如果一个内存位置被引用了一次，那么程序可能在以后引用附近的一个内存位置，此时可以说程序具有良好的空间局部性。</p><p>通过以下示例来看一下程序数据引用的局部性</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">sumvec</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    </pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=6></td><td><pre>        sum <span class="token operator">+=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这段代码是对一个向量的元素求和，其中变量sum在每次循环迭代中被引用一次，因此，对于sum来说，有好的时间局部性。另一方面，由于sum是个标量，不存在空间局部性的特点。由于向量v的元素是按照顺序一个接一个来读取的，读取的顺序与存储在内存中的顺序是一致的，因此，对于变量v，函数有很好的空间局部性，不过时间局部性很差，因为每个向量元素只被访问一次。综上所述，循环体中的变量要么有好的空间局部性，要么有好的时间局部性，所以可以断定该函数具有好的局部性。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">sumarrayrows</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    </pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> M<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=6></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=7></td><td><pre>            sum <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这段代码是对一个二维数组的元素进行求和运算，其中嵌套循环是按照行优先的顺序来读取数组元素的，也就是说内层for循环先读第一行元素，读完之后，再读第二行，以此类推，由于数组在内存的顺序也是按照行优先的顺序存储的，所以该函数访问数组的顺序与内存中的存储顺序是一致的，此时可以说这个函数也具有良好的空间局部性。接着做一个改动</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">sumarrayrows</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    </pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=6></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> M<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=7></td><td><pre>            sum <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>交换i和j的循环，虽然改动不大，改动后得到的结果也是正确的，但是改动后的程序空间局部性会很差，这是因为访问顺序与存储顺序不一致了。一般而言，有良好局部性的程序比局部性差的程序运行的更快，现代计算机系统的各个层次的设计都利用了局部性的原理，例如高速缓存就是利用程序的局部性来提高CPU访存速度。</p><h3 id=缓存><a class=anchor href=#缓存>#</a> 缓存</h3><p>如下图，第k+1层的存储器被划分成16个大小固定的块，每个块都有唯一的地址，这里用编号<code>0~15</code>来表示，第k层的存储器有4个块的空间，每个块的大小与<code>k+1</code>层的块一样，数据总是以块为单元在第k层和第k+1层之间来回复制，当前第k层存储器包含了四个块的副本。对于相邻之间的块大小是固定的，然而不相邻的层次之间，块的大小是不一样的，例如寄存器与L1 Cache之间传送的块大小通常是一个字，L2 Cache与L1 Cache之间传送的块大小通常是几十个字节，内存与磁盘之间则是几百个或几千个字节。一般来说，层次结构中离CPU越远的设备访问时间就越长，为了弥补访问过程中浪费的时间，倾向于使用较大的块。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/10.webp alt=""></p><h4 id=缓存命中cache-hit与缓存不命中cache-miss><a class=anchor href=#缓存命中cache-hit与缓存不命中cache-miss>#</a> 缓存命中(Cache Hit)与缓存不命中(Cache Miss)</h4><p>当程序需要第k+1层的某个数据对象d时，它首先从第k层的数据块中检索是否包含目标数据d的副本，如果目标数据d刚好缓存在第k层中，就可将这种情况称为缓存命中。如果第k层没有缓存目标数据d，将这种情况称为缓存不命中，当发生不命中时，第k层的缓存要从第k+1层取出包含目标数据的块，如果第k层的缓存已经满了，这时包含目标数据的块就会覆盖现存的一个块，将这个过程称为替换，被替换的块有时也称为牺牲块，决定替换哪个块是由缓存的替换策略来具体决定的，常用的替换策略有随机替换以及LRU等。</p><h4 id=基于sram的高速缓存><a class=anchor href=#基于sram的高速缓存>#</a> 基于SRAM的高速缓存</h4><p>早期计算机系统的存储器层次结构只有三层，分别是寄存器文件，内存以及磁盘，由于CPU与内存之间的性能差距逐渐增大，于是系统设计者在寄存器文件和内存之间插入了一个小的基于SRAM的高速缓存，称为L1 Cache，L1 Cache的访问速度和寄存器差不多，大约需要4个时钟周期。随着CPU和内存之间的性能差距继续增大，系统设计者又在L1 Cache和内存之间插入了一个更大的高速缓存，称为L2 Cache，L2 Cache的访问时间大约需要10个时钟周期。还有些系统中包含了一个更大的L3 Cache，它位于L2cache和内存之间，为了避免歧义，之后的cache一词是指基于SRAM的高速缓存。</p><h4 id=cache的内部结构><a class=anchor href=#cache的内部结构>#</a> cache的内部结构</h4><p>整个cache被划分成一个或多个set(组)，这里用变量S表示set的个数，每个set包含一个或多个高速缓存行(cache line)，这里用变量E来表示一个set中cache line的行数，每个cache line由三部分组成，分别是有效位(valid)，标记(tag)，数据块(cache block)。</p><p>有效位的长度是一个bit，它表示当前cache line存储的信息是否有效，当valid等于1时，表示数据有效，当valid等于0时，表示数据无效，标记是用来确定目标数据是否存在于当前的cache line中。</p><p>数据块是一小部分内存数据的副本，大小用B来表示。</p><p>通常来说，cache的结构可以用元组(S，E，B，m)来描述，cache的大小是指所有数据块的和，其中有效位和标记位不包括在内，因此cache的容量可以通过<code>S * E * B</code>计算得到。</p><p>接下来看下cache是如何工作的，当CPU执行数据加载从内存地址A处读取数据时，根据存储器层次原理，CPU将地址A发送到cache，如果cache中保存着目标数据的副本，它就立即将目标数据发回给CPU。假设目标数据(地址A)的地址长度为m位，这个地址被参数S和B分成了三个字段，首先，可以通过长度为s的组索引来确定目标数据存储在哪个set中，一旦知道了目标数据属于哪个set，接下来就需要确定目标数据放在哪一行，确定具体的行是通过长度为t的标记来实现的，此时有效位必须等于1，也就是说需要有效位和标记共同来确定目标数据属于哪一行，最后根据长度为b的块偏移量来确定目标数据在数据块中的确切地址。通过以上三步，cache就能够确定是否命中。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/11.webp alt=""></p><p>为什么cache要用中间的位做组索引，而不是用高位？假设高位用做索引位，那么一些连续的内存块就会映射到相同的set中，例如图中前四个内存块映射到第一个set中，第5个至第8个内存块映射到第二个set中，以此类推，最后四个内存块映射到最后一个set中，如果一个程序具有良好的空间局部性，当需要顺序读取一个数组的多个元素时，此时，需要不断进行cache line的替换，也就是说在任何时刻，cache都只保存着一个块大小的数组内容，这样会导致cache的使用率很低。如果用中间位作为索引，相邻的内存块总是映射到不同的set中，与高位索引相比，cache的效率会大大提高。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/12.webp alt=""></p><h4 id=直接映射高速缓存direct-mapped-caches><a class=anchor href=#直接映射高速缓存direct-mapped-caches>#</a> 直接映射高速缓存(Direct-Mapped Caches)</h4><p>根据每个set所包含的cache line的行数不同，cache被分为不同的类，当每个set只有一个cache line，也就是E等于1时，将这种结构的cache称为直接映射(cache)。</p><p>接下来看直接映射的cache是如何工作的，假设有这样一个系统，它包含一个CPU，一个寄存器文件，一个L1 Cache和一个内存，当CPU执行从内存中读取数据的指令时，首先从L1 Cache中查询是否包含目标数据的副本，如果能够在L1 Cache中找到目标数据，那么cache就把目标数据直接返回给CPU，这个判断是否命中，获取目标数据的过程一共分为三步，分别是组选择(set selection)，行匹配(line matching)，字抽取(word extraction)。</p><p>首先看下组选择是如何实现的，这一步是根据索引值来确定目标数据属于哪个set，例如组索引的长度是5位，这些二进制位被解释成一个无符号数，因此，长度为5的组索引位最大可检索32个set，当s等于0时(<code>00000</code>)，此时组选择的结果是Set 0，当s等于1时(00001)，组选择的结果是Set 1，以此类推，以上就是根据组索引位进行组选择的整个过程。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/13.webp alt=""></p><p>Cache执行完组选择后，接下来开始执行行匹配。在这个例子中，每个set中只有一个cache line，而且当cache line的有效位等于1，也就是说此时cache line中的数据是有效的，然后需要比对cache line中的标记与地址中的标记位是否一致，如果一致，表示目标数据一定在当前的cache line中，另一方面，如果不一致，或者有效位等于0，表示目标数据不在当前的cache line中，因此，行匹配最终的结果无非就是命中或者不命中，一旦命中，就可以继续执行第三步的字抽取操作。这一步需要根据偏移量来确定目标数据的确切位置，通俗讲，就是从数据块的什么位置开始抽取数据，例如下图数据块的大小为8个字节，这里用编号<code>0~7</code>来表示，当块偏移等于100时，它表明目标数据的起始地址位于字节4处，这里假设目标数据的长度为四个字节，这样一来就可以获得目标数据的副本了。经过以上三步，cache就可以将目标数据返回给CPU了，上述过程是cache命中的情况。如果发生了不命中，那么cache需要从存储器层次结构的下一层取出被请求的块，由于直接映射每个set只包含一行，因此替换策略十分简单，直接用新取出的行来替换当前的行就可以了。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/14.webp alt=""></p><p>假设有一个直接映射的cache，它包含4个set，每个set有一行，每个数据块包含两个字节，其中地址m是4位，虽然上述假设不现实，但这种假设方式方便理解整个过程。由于地址是4位，整个地址空间可以用编号<code>0~15</code>来表示，标记位和索引位连起来可以唯一的标识每一个内存块，每个内存块包含两个字节，例如块0是由地址0和地址1组成的，块1是由地址2和地址3组成，以此类推，整个内存空间被分成了8个块(编号为07)，但是示例中的cache只有4个set，因此就会出现两个内存块映射到同一个set的情况，例如块0和块4都映射到了set 0，块1和块5都映射到了set1。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/15.webp alt=""></p><p>接下来，模拟一下当CPU执行一系列读的时候，cache是如何执行的，这里假设CPU每次读取的数据都是一个字节，最开始时，整个cache都是空的，即所有的cache line的有效位都等于0，图中表格的每一行代表一个cache line。第一步，当CPU读地址0的数据时，经过组选择后，发现set 0的有效位等于0，此时不命中，接下来cache会从内存中取出包含目标数据的块并把这个数据块放在set 0中，然后cache返回位于块0处的目标数据m[0]。第二步，当CPU读取地址1(0001)的字时，由于目标数据m[1]已经在cache中，这次cache是命中的，cache根据地址m进行组选择，行匹配以及字抽取之后，然后将目标数据m[1]返回给CPU，此时cache的状态没有发生变化。第三步，当CPU读地址13(1101)的字时，根据地址13的组索引位(10)进行组选择后，发现set 2的有效位等于0，所以发生不命中，这时cache把块6加载到set 2中，然后从cache line中抽取目标数据返回给CPU。第四步，当CPU读取地址8(1000)的字时，根据地址8的组索引位(00)进行组选择之后，发现set 0的有效位是1，但是进行标记对比后，发现并不匹配，此时，需要用块4来替换块0，替换之后，cache再返回目标数据到CPU。最后一步，当CPU再去读地址0的字，又会发生不命中，这是因为前面引用地址8的数据时，替换了块0，由于不同的块刚好映射到同一个set中，虽然整个cache还有空闲的空间，当发生交替引用时，还是会出现不命中的情况，把这种现象称为冲突不命中，实际上冲突不命中在真实的程序中是很常见的，它会导致一些令人困惑的性能问题。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/16.webp alt=""></p><p>接下来，通过一个代码示例来看一下冲突不命中</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">float</span> <span class="token function">dotprod</span><span class="token punctuation">(</span><span class="token keyword">float</span> x<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">float</span> y<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">float</span> sum <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    </pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=7></td><td><pre>        sum <span class="token operator">+=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>对于变量x和y来说，这个函数具有良好的局部性，因此期望cache有较高命中率。假设数组x的第一个元素位于地址0处，每个元素的长度为4个字节，因此可以得到数组x各个元素的起始地址，数组y紧跟其后，y[0]的地址从32开始，当程序开始运行时，循环在第一次迭代时引用了元素x[0]，此时发生不命中，cache把包含<code>x[0]~x[3]</code>的块加载到set0，接下来又立刻引用了数组元素y[0]，又一次不命中，这时cache把包含<code>y[0]~y[3]</code>的块加载到set0，之前set0中存储的内容数据块是<code>x[0]~x[3]</code>的数据，那么这些数据会被<code>y[0]~y[3]</code>覆盖。接下来，循环继续下一次的迭代，此时对数组元素x[1]的引用又发生了不命中，导致<code>x[0]~x[3]</code>的块加载到set0，覆盖了<code>y[0]~y[3]</code>的块，实际上后面每次对x和y的引用都会导致cache line的替换，把这种现象称为抖动。综上所述，即使程序具有良好的空间局部性，同时cache也有足够的空间来存放数组x和y的数据块，但是每次引用还是会产生冲突不命中，究其原因是这些块被映射到了同一个set中，这种抖动的出现可能会导致运行速度下降2到3倍。至于如何解决这个问题，例如，把数组x的长度由8变为12，数组y还是紧跟在x的后面，此时数组y的起始地址发生了改变，从而就避免了x和y的元素就映射到同一个set中，这样一来，通过这种数据填充的方式就可以消除抖动，从而解决冲突不命中的问题。</p><h4 id=组相联cache><a class=anchor href=#组相联cache>#</a> 组相联cache</h4><p>与直接映射不同，组相联cache的每个set允许包含多个cache line，也就是说E是大于1的，不过每个set最多不能超过C除于B个cache line。如下图，每个set包含两个cache line，将这种结构称为二路组相联cache，组相联cache确定一个请求是否命中，同样需要经过组选择，行匹配以及字抽取这三步。组相联cache的组选择过程与直接映射cache是一样的，都是通过组索引位来确定目标数据属于哪一个set。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/17.webp alt=""></p><p>在完成组选择后，接下来执行行匹配，由于组相联cache的每个set包含多个cache line，所以需要遍历这个set中的每一行来寻找一个有效位等于1并且与地址中的标记位相匹配的cache line，如果找到了符合条件的cache line，表示命中。接下来根据块偏移从这一行的数据块中抽取目标数据，字抽取的过程与直接映射cache一样。如果找不到符合条件的cache line，表示不命中，此时cache必须从内存中取出包含目标数据的块，不过一旦cache取出这个块，应该替换哪一行呢？如果存在空行，也就是valid等于0的cache line，那么这个空行就是不错的选择，但是如果这个set中没有空行，这时需要从中选择一个非空行作为被替换的对象，同时希望CPU不会很快引用这个被替换的行。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/18.webp alt=""></p><p>这里介绍几个替换策略，最简单的替换策略就是<strong>随机选择一行</strong>(Choose the line to replaced at random)，然后进行替换，其他更复杂的策略就是利用局部性原理，使得在之后引用被替换的行的概率最小。例如，<strong>最不常使用</strong>策略(Least Frequently Used - LFU)会替换在过去某个时间段内引用次数最少的那一行。<strong>最近最少使用</strong>策略(Least Recently Used - LRU)会替换最后一次访问时间最久远的那一行，所有的这些策略都需要额外的时间以及硬件实现，但是，越往存储器层次结构下面走，一次不命中的开销就越大，所以通过更好的替换策略来降低不命中的几率是非常值得的。</p><h4 id=全相连高速缓存cache><a class=anchor href=#全相连高速缓存cache>#</a> 全相连高速缓存cache</h4><p>先看下全相联cache的组织结构，整个cache只有一个set，也就说一个set包含了所有的cache line，至于具体的行数E可以通过C除于B计算得到，其中C表示cache的容量，B表示数据块的大小，由于全相联cache只有一个set，所以默认总是选择set 0，因此不再需要组索引位进行组选择了，这样一来，地址只需要划分成标记和块偏移即可。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/19.webp alt=""></p><p>关于全相联cache的行匹配和字选择与组相联cache是一样的，它们之间的主要区别就是cache line规模大小的问题，由于硬件实现以及成本的问题，全相联cache只适合做容量较小的高速缓存，例如虚拟内存系统中的TLB可以使用这种结构。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/20.webp alt=""></p><p>至此，关于不同类型cache的组织结构就此完结。</p><p>cache关于读的操作比较简单，不过写入的情况要复杂一些，当CPU需要往内存中写入数据时，需要考虑写命中(Write Hit)和写不命中(Write Miss)两种情况。</p><p>当发生写命中时，有两种策略，分别是写穿透(write-through)和写回(write-back)。写穿透是指CPU在写cache的同时写内存(更低一级cache)，这种策略的好处是内存里(更低一级cache)的数据永远都是新的，cache替换时直接扔掉旧的数据就可以了。写回策略是指CPU只写cache，不写内存(更低一级cache)，写回的好处是写cache时比较省事，不用关注是否与内存(更低一级cache)一致，只有当替换算法要驱逐这个更新的块时，再写回到内存里(更低一级cache)，不过这种策略会增加cache的复杂性，为了表明每个数据块是否被修改过，每一个cache line需要增加一个额外的修改位，以上就是写命中时，写cache的策略。</p><p>当发生写不命中时，也有两种策略，分别是写分配(write-allocate)和写不分配(no-write-allocate)。写分配就是先把目标数据所在的块从内存(更低一级cache)加载到cache中，然后再往cache中写。写不分配就是绕开cache，直接把要写的内容写到内存(更低一级cache)里。通常情况下，写分配与写回搭配使用，写不分配与写穿透搭配使用。</p><p><strong>Intel core i7处理器的高速缓存层次结构</strong></p><p>其中每个处理器芯片包含四个核心，每个核都有自己私有的L1 i-cache，L1 d-cache和L2 cache，所有的核心共享芯片内的L3 cache，所有基于SRAM的高速缓存都是在处理器芯片内部。之前的讲述中，一直假设cache只保存程序的数据，实际上cache即保存数据也保存命令，把只保存指令的高速缓存称为i-cache，只保存数据的高速缓存称为d-cache，即保存指令又保存数据的高速缓存称为统一的高速缓存，采用独立的i-cache和d-cache的好处是CPU可以同时读指令和数据，此外，还能确保数据访问不会与指令访问形成冲突不命中。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/21.webp alt=""></p><p>下图的表格列出了不同层次cache的特性以及参数，包括访问时间，容量大小以及相联的方式等。接下来分析一下不同的设计对cache性能的影响，一方面，容量较大的cache可能会提高命中率，不过使容量较大的cache运行的更快要更难一些，最终导致的结果是容量较大的cache可能会增加命中的时间，这就是为什么L1 cache比L2 cache小，L2 cache比L3 cache小的原因，数据块的大小也会影响cache的性能，较大的块能够利用程序中可能存在的空间局部性，帮助提高命中率，不过对于给定的cache大小，块越大就意味着cache的行数越少，这样一来，虽然对空间局部性好的程序是有利的，但是时间局部性好的程序的命中率就会受到损害。此外，当发生不命中时，较大的块的处罚也会增大，因为块越大，传送的时间也就越长，在Intel Core i7处理器中，L1 cache和L2 cache都是8路组相联的，L3 cache采用的是16路组相联，也就是说对于L1 cache和L2 cache，每个set中有8个cache line，L3 cache的每个set有16个cache line，每个set中cache line的数量越多，那么由于冲突不命中导致的抖动现象发生的机率就越低，不过相联度越高，实现的复杂度就越高，访问速度就很难再提高了，所以对于最终相联度的应该如何选择，需要在命中时间和不命中处罚之间做一个折中的处理，最后一个因素就是写策略的影响。一般而言，L1 cache与L2 cache之间用写穿透的多一些，越往下层，写回策略比写穿透用的更多。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/22.webp alt=""></p><h2 id=链接linking><a class=anchor href=#链接linking>#</a> 链接(Linking)</h2><h3 id=链接过程><a class=anchor href=#链接过程>#</a> 链接过程</h3><p>链接是将各种代码和数据收集并组合成一个文件的过程，最终得到的文件可以被加载到内存执行。早期的计算机系统中，链接时手动执行的，到了现代系统中，链接是由链接器自动完成的。在大型应用程序的开发过程中，不可能将所有的功能实现到放在一个源文件中，而是将它分解为更小，更容易管理的模块，当修改其中一个模块时，只需要重新编译这个修改后的模块，而其他的模块是不需要重新编译的。对于初学者，由于编写的程序规模比较小，链接通常都是链接器默默处理的，所以不会觉得链接是一个重要的问题。</p><p>当在构造大型程序时，经常会遇到由于缺少库文件或库文件的版本不兼容而导致的链接错误，解决这类问题需要理解链接器是如何使用库文件来解析引用的。</p><p>以下为一个示例，</p><figure class="highlight c"><figcaption data-lang=c><span>sum.c</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    </pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=6></td><td><pre>        s <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    </pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">return</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight c"><figcaption data-lang=c><span>main.c</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">return</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>其中main函数中初始化了一个长度为2的整数数组array，然后调用sum函数对这个数组进行求和。在linux系统中，可以通过在shell中输入指令<code>gcc -Og prog main.c sum.c</code>来得到可执行程序prog，其中<code>-Og(Optimize debugging experience)</code>表示代码优化等级，这个选项的意思是告诉编译器生成的机器代码要符合原始C代码的结构，目的是为了方便调试。在实际项目中，为了程序的性能，通常采用<code>-O1</code>或<code>-O2</code>的优化选项，<code>-o prog</code>选项是指定可执行文件的名字为<code>prog</code>，<code>-o</code>的<code>o</code>是output的首字母。如果不特别指定，默认生成的可执行文件名为<code>a.out</code>。关于编译器系统的整个工作流程，如下图。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/23.webp alt=""></p><p>此处，将整个过程进行分解，采用手动链接的方式来生成可执行程序。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/24.webp alt=""></p><p>首先是预处理阶段，使用命令<code>cpp -o main.i main.c</code>将源程序<code>main.c</code>翻译成<code>main.i</code>，其中<code>cpp</code>指的是C预处理器(C preprocessor)，此外，还可使用gcc命令<code>gcc -E -o main.i main.c</code>来完成相同的预处理任务，不过需要添加一个<code>-E</code>的选项，这个选项是用来限制gcc只进行预处理，不做编译，汇编以及链接的操作。<code>.i</code>文件是一个ASCII码的中间文件。</p><p>接下来是编译阶段，通过命令<code>cc -S -o main.s mai.i</code>，编译器将<code>main.i</code>翻译成汇编文件<code>main.s</code>，其中<code>cc</code>指的是C编译器(c compiler)，此外，还可使用gcc命令<code>gcc -S -o main.s main.i</code>来完成这一步，其中<code>-S</code>选项表示只对文件进行编译，不做汇编和链接的处理，这一步得到的汇编文件<code>main.s</code>也可通过编译器打开查看。</p><p>第三个阶段是汇编，使用命令<code>as -o main.o mai.s</code>，汇编器<code>as</code>(assembler)将<code>main.s</code>翻译成一个可重定位文件<code>main.o</code>。经过汇编阶段，可以得到可重定位文件<code>main.o</code>和<code>sum.o</code>。</p><p>最后，使用连接器<code>ld</code>来构造可执行文件，当手动调用链接器来构造可执行程序时，除了需要用到汇编阶段得到的<code>main.o</code>和<code>sum.o</code>之外，还需要<code>crt1.o</code>，<code>crti.o</code>，<code>crtbeginT.o</code>，<code>crteng.o</code>，<code>crtn.o</code>这五个文件，其中crt是<code>c runtime</code>的缩写。链接就是将这些文件打包成一个可执行文件，具体命令如下，其中ld指的是链接器，<code>-static</code>表示采用静态链接的方法，通过这条命令就可以实现手动链接的操作。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/25.webp alt=""></p><p>在shell中输入<code>./prog</code>，然后回车结束，关于可执行程序prog的运行是通过shell调用操作系统中的加载器<code>loader</code>函数来实现的，加载器将可执行文件prog中代码和数据复制到内存中，然后将CPU的控制权转移到prog的程序开头，随后程序prog开始执行。</p><h3 id=可重定位目标文件relocatable-object-files><a class=anchor href=#可重定位目标文件relocatable-object-files>#</a> 可重定位目标文件(Relocatable Object Files)</h3><p>首先，是一个代码示例，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">int</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> sum<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum is:%d\n"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=10></td><td><pre></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre>    </pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre>    <span class="token function">func</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=18></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这段代码定义了两个全局变量count和value，函数func仅仅执行一个简单打印功能，main函数内定义了两个局部静态变量a和b，这些所有的代码都在同一个源文件<code>main.c</code>中。接下来，使用gcc将这个源文件翻译成可重定位目标文件，命令为<code>gcc -c main.c</code>，其中<code>-c</code>的编译选项表示只进行编译和汇编，不执行链接操作，这样就得到了可重定位目标文件<code>main.o</code>，可以使用<code>wc</code>(Word Count)命令来看<code>main.o</code>的大小，命令为<code>wc -c main.o</code>，<code>-c</code>选项表示查看文件包含多少个字节。</p><p>每一个可重定位目标文件可以大致分为三部分，分别是ELF header，不同的section，以及描述这些section信息的表，其中ELF是可执行可链接格式的首字母缩写(Executable and Linkable Format,ELF - 可执行可链接格式)。</p><p>接下来，以<code>main.o的</code>ELF header为例，看一下ELF header中具体包含哪些内容。使用命令<code>readelf -h main.o</code>来查看<code>ELF header</code>的具体内容，其中<code>readelf</code>是linux系统中提供的一个工具，<code>-h</code>选项表示只显示header信息。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/26.webp alt=""></p><hr><p>首先看下开头的16个字节(7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00)分别代表什么含义，最开始的4个字节被称为ELF文件的魔数(ELF Magic)，分别于ASCII码中的DEL控制符，字符E，字符L，以及字符F对应。魔数就是用来确认文件类型的，操作系统在加载可执行文件的时候会确认魔数是否正确，如果不正确就会拒绝加载。接下来的一个字节用来表示该ELF文件的类型，<code>0x1</code>表示32位，<code>0x2</code>表示64位，第6个字节表示字节序，<code>0x1</code>表示小端，<code>0x2</code>表示大端，第7个字节表示ELF文件的版本号，通常都是1，最后9个字节ELF的标准中没有定义，用0填充。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/27.webp alt=""></p><p>根据<code>Type:</code>这行的信息，可以看到文件的类型是可重定位文件，除此之外，还有可执行文件和共享文件这两种文件。根据<code>Size of this header</code>这一行可以看到ELF header的长度，一共64个字节，根据这个信息可以确定section在elf文件中的起始位置就是<code>0x40</code>，关于section，有的翻译成节，有的翻译成段，这里不对section进行翻译。除此之外，ELF header中还给出了一些关于section header table的信息，它是用来描述不同section属性的表。根据<code>Start of section headers</code>这一行，可以确定这个表在elf文件中的起始地址是1064。根据<code>Number of section headers</code>这一行可知，该表一共包含13个表项，每个表项的大小是64个字节，这样一来就可以计算出整个表的大小就是832个字节。根据这个表在elf文件中起始位置以及大小，可以计算出整个elf文件的大小是1896，这个数值恰好与使用wc命令统计的字节数一致。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/28.webp alt=""></p><hr><p>使用命令<code>readelf -S main.o</code>，看一下描述不同section属性的表(section header table)，其中<code>-S</code>选项表示打印整个表的信息，除了表中的第一项，其他每一个表项都对应着一个section。根据图中的信息，可以看到整个elf文件一共包含12个section，其中offset表示每个section的起始位置，size表示section的大小，根据这两个参数信息，可以确定每个section在elf文件中的具体位置。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/29.webp alt=""></p><p>例如<code>.text section</code>的起始位置是<code>0x40</code>，大小为84个(0x54)字节。由之前的讲述，已知ELF header的大小是64个字节，所以可以确认<code>.text section</code>是紧跟在ELF header之后的，这个section中存放的是已经编译好的机器代码，对于查看已经编译好的机器代码，需要使用反汇编工具<code>objdump</code>将机器代码转换成汇编代码，命令为<code>objdump -s -d main.o</code>，内容中左边这部分是指令地址，右边这部分是具体的机器指令，其中每个字节所对应的汇编代码也可以通过反汇编得到。根据<code>.text section</code>的起始位置(0x40)以及大小，可以计算出下一个section的起始位置是<code>0x94</code>，通过查表(section header table)可以发现<code>.text</code>之后section是<code>.data</code>，<code>.data section</code>是用来存放已初始化的全局变量和静态变量的值。例如，程序中将全局变量count初始化为10，静态变量a初始化为1，使用命令<code>objdump -s -d main.o</code>来查看<code>.data section</code>中的内容，由于数据存放采用小端法，所以这里存储的字节顺序与实际数值的字节顺序相反，对于未初始化的全局变量和静态变量会存放在<code>.bss section</code>中。被初始化为0的全局变量和静态变量也存放在bss中，用bss表示未初始化的数据最早源自于<code>IBM 704</code>汇编语言(一直沿用至今)。有一个区分data和bss的简单方法，就是把bss看成更好节省空间(Better Save Space)的缩写。局部变量即不在data中，也不在bss中。当看到<code>.bss section</code>的起始位置和大小时，会发现两个奇怪的问题，一个是bss的起始地址与rodata的起始地址是一样的，另外一个就是bss的大小是4个字节，而源程序中全局变量value和静态b，加起来的大小是8个字节，二者大小并不匹配，实际上<code>bss section</code>并不占据实际的空间，它仅仅只是一个占位符，区分已初始化和未初始化的变量是为了节省空间。当程序运行时，会在内存中分配这些变量，并把初始值设为0，<code>.data section</code>之后是<code>.rodata section</code>，这里的<code>ro</code>是<code>read only</code>的缩写，这个section就是用来存放只读数据的，例如printf语句中的格式串和switch语句中的跳转表就是存放在这个区域内。这个示例中，函数func中调用了printf函数，因此，<code>.rodata</code>这个section保存了需要打印的字符串。除此之外，可重定位文件中还包含其他的section来保存与程序相关的信息。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/30.webp alt=""></p><p><strong>剩余Section的介绍</strong></p><table><thead><tr><th>Section</th><th>Introduction</th></tr></thead><tbody><tr><td>.comment</td><td>存放编译器的版本信息</td></tr><tr><td>.symtab</td><td>Symbol Table，符号表</td></tr><tr><td>.rel.text</td><td>Relocation Table，重定位表</td></tr><tr><td>.debug</td><td>调试信息</td></tr><tr><td>.line</td><td>原始C程序的行号和<code>.text section</code>中机器指令之间的映射</td></tr><tr><td>.strtab</td><td>String Table，字符串表</td></tr></tbody></table><h3 id=符号与符号表><a class=anchor href=#符号与符号表>#</a> 符号与符号表</h3><p>链接过程的本质就是把多个不同的目标文件粘合到一起，为了使不同的目标文件之间能够相互粘合，这些目标文件之间必须有固定的规则才行，可以将符号看作是链接中的粘合剂，整个链接过程是基于符号才能够正确完成。接下来，看下<code>.symtab</code>(symbol table)的详细内容，使用命令<code>readelf -s main.o</code>，</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/31.webp alt=""></p><p>可以看到整个符号表从0开始，一共包含17个符号，最后一列给出了符号的名字，以下为之前的程序示例代码。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">int</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> sum<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum is:%d\n"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=10></td><td><pre></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre>    </pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre>    <span class="token function">func</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=18></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>接下来，看一下符号表中的符号与源程序之间存在什么样的关系，先看下符号func和main，在源程序中定义了两个函数，分别是函数main和函数func，所以符号表中二者的类型是函数，由于函数main和func是全局可见的，因此这里的binding字段也是全局的。Ndx表示的是section的索引值，关于索引值与具体section的对应关系，可以查看section header table来确定，使用命令<code>readelf -S main.o</code>，</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/29.webp alt=""></p><p>例如，索引值1表示text section，3表示data section。函数main和函数func所在的位置是text section，所以，符号main和func的Ndx为1。<code>Value</code>表示函数相对于<code>.text section</code>起始位置的偏移量，<code>Size</code>表示所占字节数。由图可知，函数func是从0开始，大小是36个字节，Value的值是十六进制，所以，函数main的起始地址是<code>0x24</code>(36)，紧跟在函数func之后。字段<code>Vis</code>在C语言中并未使用，可以忽略这个字段。关于符号<code>printf</code>，虽然它也是一个函数，但是函数printf只是在main.c中被引用，由于它的定义并不在<code>main.c</code>中，所以它的Ndx是UND(undefine)的类型。</p><p>接下来，看下全局变量count和value的描述，在符号表中count和value的类型是OBJECT，这里的OBJECT表示该符号是个数据对象，例如变量和数组等在符号表中的类型都用OBJECT来表示。虽然count和value都是全局变量，但是二者的Ndx值不同，也就是说，二者处于不同的section中，导致count和value位于不同section的原因是count经过了初始化，而value没有，由于索引值3表示data section，所以从符号表中可以看出count是位于data section中，但是value却位于COMMON中。之前介绍过未初始化的全局变量放在bss中，然而符号表中给出的却是另外一个section，通过查看section header table，并没有发现COMMON的存在。实际上COMMON和bss的区别很小，二者之间主要的区别是COMMON仅用来存放未初始化的全局变量，而bss用来存放未初始化的静态变量以及初始化为0的全局或静态变量。</p><p>接下来看下局部变量a和b，与全局变量一样，二者的类型也是OBJECT，通过binding字段，可以看到局部变量与全局变量的区别，由于此处对局部静态变量a进行了初始化，所以它的Ndx值是3(data section)，它与全局变量count处于同一个section。虽然对b进行了初始化，但是这个初始化并没有什么用，所以符号b的Ndx值等于4，与符号a不同，同样也与未初始化的全局变量value不同，对于变量名从a和b变成了<code>a.2254</code>和<code>b.2255</code>，这种处理方式被称为名称修饰，主要为了放置静态变量的名字冲突，除此之外，符号表中还有一些符号名没有显式的表项，实际上他们的符号名就是它们section的名称，例如索引值为2的Ndx等于1，那么它的符号名就是<code>.text</code>。</p><p>在<code>main.c</code>中还定义了一个局部变量x，这个局部变量并没有出现在符号表中，这是因为局部变量在运行时栈中被管理，链接器对此类符号并不感兴趣，所以局部变量的信息不会出现在符号表中。</p><p>对于每一个可重定位目标文件都有一个符号表，这个符号表包含该模块定义和引用的符号信息，在链接器的上下文中，有三种不同的符号，第一种是由该模块定义，同时被其他模块引用的<strong>全局符号</strong>(Global Symbols)，例如<code>main.c</code>中定义的函数func以及全局变量count和value。第二种是被其他模块定义，同时被改模块引用的全局符号，这些符号被称为<strong>外部符号</strong>(Externals Symbols)。第三种是只能被该模块定义和引用的<strong>局部符号</strong>(Local Symbols)，区别局部符号和全局符号的关键就是static属性，带有static属性的函数以及变量是不能被其他模块引用的。对于C语言来说，static属性的功能就是隐藏模块内部的变量以及函数声明，这个功能类似CPP和Java中的public和private，任何带有static属性声明的全局变量和函数都是模块私有的，也就是说，任何不带static属性声明的全局变量和函数都是公共的，可以被其他模块访问。</p><h3 id=符号解析与静态库><a class=anchor href=#符号解析与静态库>#</a> 符号解析与静态库</h3><p><strong>符号解析</strong></p><p>先看一个代码示例，</p><figure class="highlight c"><figcaption data-lang=c><span>linkererror.c</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这段代码仅仅对函数foo做了声明，函数main中调用了函数foo。使用命令<code>gcc -c linkerror.c</code>，如果只对这个文件进行编译和汇编，而不执行链接操作。当编译器遇到一个不是在当前模块中定义的符号时，它会假设该符号是在其他某块中定义的，使用命令<code>readelf -s linkerror.c</code>看一下这个源程序所对应的符号表，虽然源程序中只是声明了函数foo，汇编器还是为它生成了相应的符号。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/33.webp alt=""></p><p>不过在链接生成可执行文件时，链接器在其他输入模块中都找不到这个被引用符号foo的定义，此时就会输出一条错误信息，并且终止链接的操作，以上为找不到符号定义的情况。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/34.webp alt=""></p><p>首先，介绍下强符号(Strong symbols)和弱符号(Weak symbols)的概念。在编译时，编译器向汇编器输出每个全局符号，或者是强或者是弱，接下来，汇编器把这个强弱信息隐含的编码在符号表中。对于函数和已初始化的全局变量被定义为强符号，未初始化的全局变量是弱符号。关于多重定义的符号名，可以分为三种情况。</p><hr><p><strong>第一种情况</strong>，多个同名的强符号一起出现，如以下示例</p><figure class="highlight c"><figcaption data-lang=c><span>foo1.c</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight c"><figcaption data-lang=c><span>bar1.c</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这两个源文件中都有函数名为main的函数，在这种情况下，链接器将生成一条错误的信息，这是因为强符号main被定义了两次。除此之外，具有相同的已初始化的全局变量名也会产生类似的错误，</p><figure class="highlight c"><figcaption data-lang=c><span>foo2.c</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">15213</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight c"><figcaption data-lang=c><span>bar2.c</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">15213</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>例如，这个示例x是已初始化全局变量，属于强符号，与刚才的情况类似，链接器也会报错。综上所述，链接器不允许有多个同名的强符号一起出现。</p><p>第二种情况，一个强符号和多个同名弱符号一起出现，如以下示例</p><figure class="highlight c"><figcaption data-lang=c><span>foo3.c</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">15231</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>	<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x = %d\n"</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight c"><figcaption data-lang=c><span>bar3.c</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    x <span class="token operator">=</span> <span class="token number">15212</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>由于bar3.c中的全局变量x并未初始化，因此x属于弱符号。那么链接器会选择在<code>foo3.c</code>中定义的强符号，此时链接器可以生成可执行文件，并不会提示错误或警告，在运行时，函数f将x的值从15213改为15212，如果这两个文件是由不同的开发人员完成的，那么main函数的作者会对这个结果感到十分意外。</p><p><strong>第三种情况</strong>，如果x都是未初始化的，那么它们都属于弱符号，此时也会发生相同的情况，</p><figure class="highlight c"><figcaption data-lang=c><span>foo4.c</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">int</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    x <span class="token operator">=</span> <span class="token number">15213</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x = %d\n"</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight c"><figcaption data-lang=c><span>bar4.c</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    x <span class="token operator">=</span> <span class="token number">15212</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>对于上述的两种情况会造成一些不易察觉的运行时的错误，尤其是当重复的符号定义是不同的类型时。接着看一个例子</p><figure class="highlight c"><figcaption data-lang=c><span>foo5.c</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">15212</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">15213</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x=0x%x y = 0x%x\n"</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight c"><figcaption data-lang=c><span>bar5.c</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">double</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    x <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">0.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>其中x在一个文件中定义为int类型，而在另外一个文件中定义为double类型，在<code>x86-64</code>的机器上，double类型占8个字节，而int类型占4个字节，在系统中，x的地址是<code>0x601020</code>，y的地址是<code>0x601024</code>。因此，这里对x的赋值将用负零的双精度浮点表示覆盖x和y的位置，这是一个很小并且很难被发现的错误，尤其是链接器只会发出一个警告，而且通常程序在执行很久以后才会表现出来。为了避免这类错误，可以在编译时添加<code>-fno-common</code>的编译选项，这个选项会告诉链接器，当遇到多重定义的全局符号时，触发一个错误。或者使用<code>-Werror</code>选项，这个选项会把所有的警告都变为错误。</p><p>以上就是链接器如何解析多重定义的全局符号的情况。</p><hr><p><strong>静态库</strong></p><p>接下来看一下链接器是如何使用静态库的，以<code>ISO c99</code>为例，它定义了标准的<code>I/O</code>，字符串操作和整数数学函数，例如函数<code>atoi</code>，<code>printf</code>，<code>scanf</code>，<code>strcpy</code>，<code>rand</code>等，这些函数都在<code>libc.a</code>的库中。</p><p>在linux系统中，静态库以一种称为archive的特殊文件格式存放在磁盘上，archive文件是一组可重定位目标文件的集合，使用命令<code>objdump -t /usr/lib/x86_64-linux-gnu/libc.a &gt; lib</code>，查看静态库都包含哪些目标文件，此处将输出的内容重定向到lib文件中。使用命令<code>grep -n printf.0 libc</code>搜索，查询到<code>printf.o</code>位于第6615行，使用命令 <code>vim libc +6622</code>，打开<code>printf.o</code>，可以看到printf函数被定义在了<code>printf.o</code>中，</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/35.webp alt=""></p><p>这里也可以使用ar将<code>libc.a</code>中所有的目标文件解压到当前目录，命令为<code>ar -x /usr/lib/x86_64-linux-gnu/libc.a</code>，可以统计出<code>lib.a</code>中一个包含1690个目标文件。</p><p>接下来通过一个简单的例子来看下静态库是如何构造的，</p><figure class="highlight c"><figcaption data-lang=c><span>addvec.c</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> addcnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">void</span> <span class="token function">addvec</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> x<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">*</span> y<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">*</span> z<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">int</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    addcnt<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    </pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=9></td><td><pre>        z<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    </pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight c"><figcaption data-lang=c><span>multvec.c</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> multcnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">void</span> <span class="token function">multvec</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> x<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">*</span> y<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">*</span> z<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">int</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    multcnt<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    </pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=9></td><td><pre>        z<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>函数addvec的功能是实现向量元素的累加，函数multvec的功能是实现向量元素的累积。使用gcc来编译这两个源文件，命令为<code>gcc -c addvec.c mulvec.c</code>，其中<code>-c</code>表示只进行编译和汇编，不执行链接的操作，之后可得到<code>addvec.o</code>和<code>multvec.o</code>可重定位目标文件。构造静态库文件需要使用ar，具体命令为<code>ar rcs libvector.a addvec.o mulvec.o</code>，之后可得到一个名为<code>libvector.a</code>的静态库。</p><p>接着演示静态库的用法，以下代码示例</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"vector.h"</span></span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">int</span> x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">int</span> y<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">int</span> z<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token function">addvec</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"z = [%d %d]\n"</span><span class="token punctuation">,</span>z<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>z<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>函数main调用了函数addvec，其中头文件<code>vector.h</code>中定义了<code>libvector.a</code>中的函数原型，为了创建可执行文件，首先执行命令<code>gcc -c main.c</code>编译源文件<code>main.c</code>，然后在链接的时候加入静态库<code>libvector.a</code>，命令为<code>gcc -static -o prog main.o ./libvector.a</code>，这样即可得到可执行文件prog。</p><p>接下来，看下具体的链接流程，当链接器运行时，它确定<code>main.o</code>中引用了<code>addvec.o</code>中定义的addvec符号，所以链接器就从<code>libvector.a</code>中复制<code>addvec.o</code>可执行文件，因为程序中没有引用<code>multvec.o</code>中定义的符号，所以链接器不会将这个模块复制到可执行文件，除此之外，链接器还会从<code>libc.a</code>复制<code>printf.o</code>模块以及其他C runtime所需的模块，最终将这些文件一起打包生成可执行文件。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/36.webp alt=""></p><h3 id=静态库的解析过程><a class=anchor href=#静态库的解析过程>#</a> 静态库的解析过程</h3><p>接下来看下链接器是如何使用静态库来解析引用的，在符号解析阶段，链接器从左到右按照命令行中出现的顺序来扫描可重定位文件和静态库文件，例如命令<code>gcc -static -o prog main.o ./libvector.a</code>，链接器先处理<code>main.o</code>，再处理<code>libvector.a</code>，最后处理<code>libc.a</code>，由于编译器驱动程序总是会把<code>libc.a</code>传给链接器，所以名字中不必显示引用<code>libc.a</code>，在扫描的过程中，链接器一共维护了三个集合，第一个是集合E，在链接器扫描的过程中发现了可重定位目标文件就会放到这个集合中，在链接即将完成的时候，这个集合中的文件最终会被合并起来形成可执行文件。第二个是集合U，链接器会把引用了但是尚未定义的符号放在这个集合里。第三个是集合D，它用来存放输入文件中已定义的符号。链接最开始时，这三个集合均为空，对于命令行上的每一个输入文件f，链接器都会判断f是一个目标文件还是一个静态库文件，如何f是一个目标文件，那么链接器把f添加到集合E中，同时修改集合U和D来反映f中的符号定义和引用，例如上面那条命令，链接器会判断<code>main.o</code>是一个目标文件，那么链接器会把<code>main.o</code>放到集合E中，使用命令<code>readelf -s main.o</code>，通过<code>main.o</code>的符号表可以看到这个目标文件中存在两个不在当前模块中定义的符号，分别是addvect和printf，接下来，链接器把符号addvec和printf放到集合U中，此时链接器假设它们在其他模块中被定义，所以并不会报错，除此之外，<code>main.o</code>中已经定义的全局符号x，y，z以及main会放到集合D中，此时集合D和U分别反映了<code>main.o</code>的符号定义以及引用，当文件<code>main.o</code>吹里完之后，然后继续处理下一个输入文件。此时发现下一个文件是一个静态库文件，那么链接器就尝试在这个静态库文件中寻找集合U中未解析的符号，例如静态库文件中<code>libvect.a</code>存在两个成员，分别为<code>addvect.o</code>和<code>multvect.o</code>，当链接器发现成员<code>addvect.o</code>中存在未定义的符号<code>addvec</code>的定义，此时就把<code>addvect.o</code>加到集合E中，然后将集合U中的符号<code>addvect</code>删除，如果<code>addvect.o</code>中还定义了其他的符号，还要添加到集合D中，所以<code>addcnt</code>也要被添加到集合D中，链接器处理完成员<code>addvect.o</code>之后，还要处理<code>multivec.o</code>，对于静态库文件中的所有成员目标文件都要依次进行上述处理过程，直到集合U和集合D不在发生变化，此时，任何不包含在集合E中的成员目标文件都被简单的丢弃，对于这个例子，<code>multivec.o</code>被丢弃，<code>addvec.o</code>被保留，最后链接器还要扫描<code>liba.c</code>文件，<code>printf.o</code>会加入集合E中，集合U中的符号printf被删除，上述操作执行完毕后，如果集合U是空的，链接器会合并集合E中的文件来生成可执行文件，如果链接器完成对命令行上所有的输入文件的扫描后，集合U是非空的，那就说明程序中使用了未定义的符号，此时链接器就会输出一个错误并终止，以上就是链接器使用静态解析引用的过程。这种算法会导致一些令人困惑的链接错误，因为命令行上目标文件和库文件的输入顺序非常重要，例如将<code>libvector.a</code>与<code>main.o</code>的输入顺序进行调换，<code>gcc -static -o prog ./libvector.a main.o</code>，那么链接就会失败，这是因为当链接器处理<code>libvector.a</code>时，集合U是空的，所以没有<code>libvector.a</code>中的成员目标文件会被添加到集合E中，接下来链接器处理<code>main.o</code>之后，<code>addvec</code>被添加到集合U中，因此对addvec的引用不会被解析到，所以链接器会产生一条错误信息并终止，所以在使用静态链接的过程中，文件的输入顺序十分重要，通常情况下，关于库的一般使用准则就是将它们放在命令行的结尾，如果各个库的成员是相互独立的，也就是说不同库的成员之间没有相互引用时，那么这些库就可以任意的顺序放置在命令行的结尾处，另一方面，如果库不是独立的，那么必须对它们进行排序。</p><p>接着看一个例子，例如<code>foo.c</code>调用<code>libx.a</code>和<code>libz.a</code>中的函数，而这两个库<code>libx.a</code>和<code>libz.a</code>又调用了<code>liby.a</code>中的函数，那么在命令行中<code>libx.a</code>和<code>libz.a</code>的输入顺序必须处于<code>liby.a</code>之前，<code>gcc foo.c libx.a libz.a liby.a</code>。</p><p>接着看另外一种情况，如果库之间需要满足依赖关系，可以在命令行上重复库，例如<code>foo.c</code>调用<code>libx.a</code>中的函数，其中<code>libx.a</code>调用了<code>liby.a</code>中的函数，然而<code>liby.a</code>又调用了<code>libx.a</code>中的函数，也就是静态库<code>libx.a</code>和静态库<code>liby.a</code>之间存在互相引用，此时<code>libx.a</code>必须在命令行上重复出现，<code>gcc foo.c libx.a liby.a libx.a</code>，不过，还有另外一种解决方法，就是把<code>libx.a</code>和<code>liby.a</code>合并成一个静态库文件。</p><h3 id=重定位relocation><a class=anchor href=#重定位relocation>#</a> 重定位(Relocation)</h3><p>当链接器把代码中的符号引用和对应的符号定义关联起来之后，链接器就可以确定要将哪些目标文件进行合并了，同时，链接器也获得了这些目标文件的代码节和数据节的大小信息。接下来，开始进行重定位的操作，在这个过程中，链接器合并输入模块，并为每个符号分配运行时地址，具体重定位的过程分为两步，第一步是重定位节和符号定义，第二步是重定位节中的符号引用，第二步是重定位节中的符号引用。接下来以为示例代码，来看重定位的第一步做了什么，</p><figure class="highlight c"><figcaption data-lang=c><span>sum.c</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    </pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=6></td><td><pre>        s <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    </pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">return</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight c"><figcaption data-lang=c><span>main.c</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">return</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>链接器将<code>main.o</code>和<code>sum.o</code>中所有相同类型的section合并为一个新的section，例如，新合成的<code>text section</code>就是可执行文件的<code>text section</code>，合成之前，<code>main.o</code>和<code>sum.o</code>中的<code>text section</code>都是从0开始的，假设合成后<code>text section</code>的起始地址是<code>0x4004d0</code>，假设原因是在64位linux系统中，ELF可执行文件默认从地址<code>0x400000</code>处开始分配，由于ELF文件的header以及<code>text section</code>之间还有一些其他的信息，所以假定<code>text section</code>是从<code>4004d0</code>开始的，这一步完成之后，程序中每条指令和全局变量都有了唯一的运行时内存地址。第二步是重定位section中的符号引用，例如函数main中调用了函数sum，下图<code>e:</code>这一行为一条call指令，所对应的就是函数sum的调用，此时call指令的目的地址是0，显然不是函数sum真正的地址，在这一步中，链接器需要修改对应符号<code>sum</code>的引用，使它指向正确的运行地址，不过要要执行这一步，链接器还要依赖于可重定位条目的数据结构。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/37.webp alt=""></p><p><strong>重定位条目(Relocation Entries)</strong></p><p>可重定位目标文件是由汇编器产生的，当汇编器在生成可重定位目标文件时，并不知道数据和代码最终放在内存的什么位置，除此之外，汇编器也不知道该模块所引用的外部定义的函数以及全局变量的位置，所以，当汇编器遇到最终位置不确定的符号引用时，它就产生一个重定位条目，这个可重定位条目的功能是，用来告诉链接器在合成可执行文件时应该如何修改这个引用，关于代码的重定位条目放在<code>.rel.text</code>中，对于已知初始化数据的重定位条目放在<code>.rel.data</code>中，下图展示了ELF重定位条目的结构体定义，每个条目由4个字段组成，其中第一个字段offset表示被修改的引用的节偏移量，链接器会根据第二个字段type来修改新的引用，第三个字段symbol表示被修改的引用是哪一个符号，最后一个addend是一个符号常数，一些类型的重定位要使用它对被修改应用的值做偏移调整，ELF中定义了多达32中不同的重定位类型，不过只需要关心其中两种最基本的重定位类型即可，分别是相对地址的重定位和绝对地址的重定位。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/38.webp alt=""></p><p>在这个例子中，汇编器产生了两个重定位条目，一个是对sum的引用，另外一个是对全局变量array的引用，如下图。接下来，看下链接器是如何使用重定位条目来进行重定位的，例如指令call的起始地址于字节偏移<code>0xe</code>的地方，<code>0xe8</code>表示指令call的操作码，在重定位之前，紧跟在操作码之后的内容被汇编器填充为0，接下来，链接器需要根据重定位条目来确定这部分的具体内容，对于函数sum的重定位条目由4个字段组成，如下图，首先，链接器需要根据重定位条目计算出引用的运行时地址，</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/39.webp alt=""></p><p>具体的计算方法是通过函数main的起始地址与重定位条目中的偏移量字段相加，函数main的起始地址在重定位的第一步可以得到，假设地址是<code>0x4004d0</code>，这样就得到了引用的运行时地址，然后更新这个符号引用，使得它在运行时指向sum函数，具体的计算方法是用函数sum的起始地址减去刚才计算得到的运行时地址，然后再加上addend字段做一下修正，假设函数sum的地址为<code>0x4004e8</code>，addend字段默认为<code>-4</code>，因此得到的结果为<code>0x5</code>，实际上这一步就是求两个地址之间的相对位置。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/40.webp alt=""></p><p>经过上述计算，在最终得到的可执行程序中，call指令的形式如下图所示，也就是说在程序运行时，指令call存放在地址<code>0x4004de</code>处，当CPU执行call指令时，此时PC的值为<code>0x4004e3</code>，至于PC的值为什么是<code>0x4004e3</code>，是因为PC的值是正在执行指令的下一条指令的地址，如下图，执行这条call指令可以分为两步，第一步CPU先把PC的值压入栈中，因为指令call要执行函数调用，接下来要发生跳转，函数执行完毕后，还要继续执行这一条add指令，所以要先把PC的值压栈保存，第二步是修改PC的值，具体的修改方式是用当前PC的值加上偏移量，根据刚才计算得到的偏移量为<code>0x5</code>，二者相加得到的地址<code>0x4004e8</code>恰好就是函数sum的第一条指令，综上所述就是重定位相对引用的具体过程。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/41.webp alt=""></p><hr><p>接下来，看下重定位绝对引用，例如下图，<code>9:</code>这一行为mov指令，把array的起始地址传给了寄存器edi，这一条mov指令的起始地址是<code>0x9</code>，bf表示mov指令的操作码，紧跟在bf之后的就是对符号array引用的绝对地址，对符号array的引用也对应一条可重定位条目，其中offset字段告诉编译器要从偏移量<code>0xa</code>开始修改，这里的类型是绝对地址引用，针对这种类型的计算比较简单，addend字段默认为0，</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/42.webp alt=""></p><p>假设链接器已经确定array所在的<code>data section</code>位于<code>0x601018</code>处，所以这里绝对地址引用就是<code>0x601018</code>，当执行完重定位之后，这一条mov指令中的源操作数由0变成了<code>0x601018</code>，由于<code>x86</code>采用小端法存储数据，所以这里要按着字节逆序进行替换，具体结果如下图，以上就是重定位绝对地址引用的计算过程。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/43.webp alt=""></p><p>经过重定位之后，可以确定目标文件的<code>text section</code>和<code>data section</code>的内容，当程序执行加载的时候，加载器会把只写section中字节直接复制到内存里，不用执行任何修改就可以执行。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/44.webp alt=""></p><h3 id=可执行目标文件executable-object-files><a class=anchor href=#可执行目标文件executable-object-files>#</a> 可执行目标文件(Executable Object Files)</h3><p>可执行文件也包含一个ELF header，它描述了该文件的总体格式，其中有一项是程序的入口，也就是程序运行时要执行的第一条指令的地址，可执行文件中的<code>.init</code>节定义了一个名为<code>_init</code>的函数，程序的初始化代码会调用这个函数进行初始化，关于<code>.text</code>，rodata以及<code>.data section</code>与可重定位目标文件中的节是类似的，不过这些节已经被重定位到最终的运行时内存地址上，因此，执行目标文件中不再需要<code>rel secction</code>，以上就是可执行文件的大致情况。程序运行时，可执行文件中的代码段和数据段需要被加载到内存中执行，不过还有一部分内容不会被加载到内存，例如符号表的调试信息等。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/45.webp alt=""></p><p><strong>程序头部表(Program Header Table)</strong></p><p>接下来，看下可执行程序prog的程序头部表，也就是段头部表的内容。程序头部表中描述了代码段，数据段与内存的映射关系。首先是只读代码段，这个<code>r-x</code>flags标志表示这个段只有读和执行的权限(r表示可读，x表示可执行，<code>-</code>表示没有写入的权限)。同样对于数据段，<code>rw-</code>flags标志表示可读可写，但是不可执行。继续看代码段，<code>off</code>表示这个段在可执行文件中的偏移量，由于代码段位于可执行文件的开始处，所以off等于0，vaddr和paddr表示这个段开始于内存地址<code>0x400000</code>处，代码段的大小是<code>0x69c</code>个字节，所以在内存中也是占<code>0x69c</code>个字节，这些内容包括ELF header，程序头部表，以及<code>.init</code>，<code>.text</code>和<code>.rodata</code>节的内容，以上就是代码段与内存的映射关系。接下来就是数据段与内存的映射关系，从下图的信息可以看出数据段的起始地址是<code>0x600df8</code>，这个段在目标文件中占<code>0x228</code>个字节，不过在内存中需要占<code>0x230</code>个字节，那么为什么加载到内存中要多占8个字节呢？这是因为多出来的8个字节用来存放<code>.bss section</code>的数据，虽然这个<code>.bss section</code>不占用可执行文件的空间，但是<code>.bss</code>中的数据在运行时需要被初始化为0，所以数据段加载到内存中要多8个字节的空间。对于任何一个段，链接器必须选择一个起始地址vaddr，使得<code>vaddr mod align</code>等于<code>off mod align</code>，off表示段在可执行文件中的相对起始位置的偏移量，align是程序头部表中指定的对齐量，例如下图的数据<code>vaddr mod align</code>之后等于<code>0xdf8</code>，<code>off mod align</code>之后也等于<code>0xdf8</code>，这种对齐要求属于优化的一种，使得程序执行时，可执行文件中的段能够高效的传送到内存中。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/46.webp alt=""></p><p>接下来看下可执行文件是如何加载运行的，如果要运行程序prog，可以在shell的命令行中输入<code>./prog</code>，当按下回车键后，shell程序通过调用加载器来运行这个程序，所有的linux程序都可以通过调用函数execve来调用加载器。接下来，加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后跳转到程序的入口来运行该程序，这个将程序从磁盘复制到内存并运行的过程叫做加载，每个linux程序都有一个运行时内存镜像，如下图，</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/47.webp alt=""></p><p>在<code>Linux x86-64</code>的系统中，代码段总是从地址<code>0x400000</code>处开始，然后是数据段，运行时堆在数据段之后，堆的增长方向是从低地址到高地址，例如C语言中的malloc函数所申请的内存空间就属于堆。堆后面的区域是为共享模块保留的，这个区域把堆和栈隔开了，用户栈的起始地址是2的48次方减1，这里是最大的合法用户地址，栈的增长方向是从高地址到低地址。再往上，从地址2的48次方开始，是为操作系统的代码和数据保留的，这部分内存空间对用户代码是不可见的，从上图可见，代码段，数据段以及堆之间都是相邻的，同时还把栈的起始位置放在了最大的合法用户地址处，实际上由于数据段有地址对齐的要求，所以代码段和数据段之间是有间隙的，同时为了放在程序受到攻击，在分配栈，共享库以及堆的运行时地址时，链接器还会使用到地址空间随机化的策略，所以每次程序运行时这些区域的地址都会改变，不过它们的相对位置是不变的，当加载器运行时，它为程序创造图中的所示的内存镜像，根据程序头部表的内容，加载器将可执行文件的<code>section</code>复制到内存相应的位置，接下来加载器跳转到程序的入口处，也就是<code>_start</code>函数的地址，这个start函数在系统目标文件<code>ctrl.o</code>中定义，对于所有的C程序都是一样的，<code>ctrl.o</code>属于C运行时库中的内容。接下来函数<code>_start</code>调用系统启动函数<code>__libc_start_main</code>，这个函数位于<code>libc.so</code>中，它的作用是初始化执行环境。然后调用用户层的main函数，接下来，开始执行可执行程序prog中的main函数，当程序prog执行完毕后，函数main的返回值还是由<code>libc.so</code>中的这个函数来处理，并且在需要的时候把控制权交还给操作系统，以上过程就是程序加载以及运行的大致过程，不过这个表述不是非常的精确，这是因为想要理解程序加载实际是如何工作的，还需要了解进程，虚拟内存以及内存映射的概念。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/48.webp alt=""></p><h3 id=动态链接共享库><a class=anchor href=#动态链接共享库>#</a> 动态链接共享库</h3><p>静态库有一些明显的缺点，静态库与所有的软件一样，需要定期维护和更新，如果软件开发人员想要使用一个库的最新版本，他们必须以某种方式来获取该库的更新情况，然后将更新后的静态库与他们编写的程序重新进行连接，这样应用程序才能用到静态库的最新版本。另外一个问题是几乎每个C程序都要使用标准的I/O函数，例如函数printf和scanf，在运行时，这些函数的代码会被复制到每个进程的代码段中，那么对于一个运行了成百上千个进程的系统，这种方式对于内存资源来说就是一种极大的浪费，为了解决静态库的缺陷，操作系统提供了一种共享库的技术。共享库(Shared Libraries)是一种特殊的可重定位目标文件，在linux系统中通常用<code>.so</code>的后缀来表示，Windows系统中也使用了大量的共享库，例如以dll结尾文件就属于共享库，共享库在运行或加载时，可以被加载到任意的内存地址，还能和一个在内存中的程序链接起来，这个过程称为动态链接，具体是由动态链接器来执行的。</p><p>对于如何创建一个共享库，具体的构造命令为</p><figure class="highlight bash"><figcaption data-lang=bash></figcaption><table><tr><td data-num=1></td><td><pre>gcc <span class="token parameter variable">-c</span> addvec.c mulvec.c</pre></td></tr><tr><td data-num=2></td><td><pre>ar rcs libvector.a addvec.o mulvec.o</pre></td></tr><tr><td data-num=3></td><td><pre>gcc <span class="token parameter variable">-shared</span> <span class="token parameter variable">-fpic</span> <span class="token parameter variable">-o</span> libvector.so addvec.c mulvec.c</pre></td></tr></table></figure><p>其中，<code>-shared</code>选项是指示编译器创建一个共享的目标文件，<code>-fpic</code>选项是告诉编译器生成位置无关的代码，这样一来共享库才能被加载到任意的内存位置，这条命令执行完毕后，就可以得到一个名为<code>libvector.so</code>的共享库。当成功构造完共享库之后，接下来可以使用这个库来构造可执行程序，具体命令为<code>gcc -o prog2 main.c ./libvector.so</code>，该命令执行完毕后可以生成一个可执行文件prog2，与静态库的链接命令相比，虽然只是将<code>libvector.a</code>变成了<code>libvector.so</code>，但是<code>libvector.so</code>中的代码和数据并没有真的被复制到可执行文件prog2中，这个操作只是复制了符号表和一些重定位信息，当可执行程序prog2被加载运行时，加载器会发现可执行程序prog2中存在一个名为<code>.interp</code>的section，这个section中包含了动态链接器的路径名，实际上这个动态链接器本身也是一个共享目标文件<code>ld-linux.so</code>。接下来，加载器会将这个动态链接器加载到内存中运行，然后由动态链接器执行重定位代码和数据的工作。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part3/49.webp alt=""></p><p>来看一下具体的过程，首先时将<code>libc.so</code>的代码和数据重定位到某个内存段，然后是重定位<code>libvector.so</code>中的代码和数据到另外一个内存段，接下来重定位prog2中由<code>libc.so</code>和<code>libvector.so</code>定义的符号引用，上述重定位的操作完成之后，动态链接器把控制权交给应用程序prog2，从这个时刻开始，共享库的位置就固定了，并且在程序执行的过程中都不会改变，然后程序prog2开始执行，以上就是动态链接的具体执行过程。</p><p>然而，应用程序还可能在它运行时要求动态链接器加载和链接某个共享库，而无需在编译时将那些库链接到应用中，动态链接是一项强大并且有用的技术，例如，许多Windows应用的开发者常常利用共享库来进行软件版本的更新，一般会发布一个共享库的新版本，然后用户下载这些新版本的共享库来代替当前的版本，下一次运行程序时，应用程序将自动链接和加载新的共享库，除此之外，动态链接还可用来构建高性能的Web服务器，例如当需要生成个性化的Web页面以及账户余额时，现代高性能的web服务器可以使用动态链接的方法来生成动态内容，具体实现的思路就是将每个生成动态内容的函数打包在共享库中，当一个来自浏览器的请求到达时，Web服务器动态的加载和链接适当的函数，然后直接调用它，由于函数会一直缓存在服务器的地址空间中，所以只需要一个简单的函数调用就可以处理随后的请求了，这对于一个繁忙的网站来说是非常高效的。除此之外，当需要添加新的函数或更新已经存在的函数时，并不需要停止正在运行的服务器就可以实现这类操作。</p><p>接下来看下如何实现运行时加载和链接共享库，示例主要代码为，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">dlopen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> filename<span class="token punctuation">,</span><span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token comment">// ............</span></pre></td></tr><tr><td data-num=3></td><td><pre>handle <span class="token operator">=</span> <span class="token function">dlopen</span><span class="token punctuation">(</span><span class="token string">"./libvector.so"</span><span class="token punctuation">,</span>RTLD_LAZY<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment">// ............</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">dlsym</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> handle<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> symbol<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment">// ............</span></pre></td></tr><tr><td data-num=7></td><td><pre>addvec <span class="token operator">=</span> <span class="token function">dlsym</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span><span class="token string">"addvec"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token comment">// ............</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token function">addvec</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token comment">// ............</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token keyword">int</span> <span class="token function">dlclose</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> handle<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token function">dlclose</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>linux系统为动态链接器提供了一个简单的接口，允许应用程序在运行时加载和链接共享库，使用函数dlopen可以动态的加载共享库<code>libvector.so</code>，标志<code>RTLD_LAZY</code>指示链接器将符号解析的操作推迟，一直推迟到共享库中的代码执行时再进行符号解析，然后调用函数dlsysm，该函数的输入有两个，一个是函数dlopen已经打开的共享库的句柄，在这个例子中<code>libvector.so</code>就是已经打开的共享库，handle就是这个库的句柄，另外一个是符号名，在这个例子中是函数名addvec，如果该符号存在，就返回符号的地址，否则返回NULL，接下来就可以正常调用函数addvec来实现需要的功能，如果没有其他共享库使用<code>libvector.so</code>，最后就可以调用函数dlclose来卸载这个共享库，以上就是如何使用接口的方式来动态链接共享库<code>libvector.so</code>的过程。</p><div class=tags><a href=/tags/computer-basic/ rel=tag><i class="ic i-tag"></i> 计算机基础</a></div></div><footer><div class=meta><span class=item><span class=icon><i class="ic i-calendar-check"></i></span> <span class=text>更新于</span> <time title="修改时间：2025-09-19 22:24:59" itemprop=dateModified datetime=2025-09-19T22:24:59+08:00>2025-09-19</time></span><span class=item data-path=/computer-science/computer-basic/composition/ccppart3/ title=阅读次数><span class=icon><i class="ic i-eye"></i></span> <span class=text>阅读次数</span><span class=waline-pageview-count></span> <span class=text>次</span></span></div><div id=copyright><ul><li class=author><strong>本文作者：</strong> ReverseSacle <i class="ic i-at"><em>@</em></i>逆转天平</li><li class=link><strong>本文链接：</strong> <a href=https://www.reversesacle.com/computer-science/computer-basic/composition/ccppart3/ title=计算机组成原理-CSAPP-第三部分>https://www.reversesacle.com/computer-science/computer-basic/composition/ccppart3/</a></li><li class=license><strong>版权声明：</strong> 本站所有文章除特别声明外，均采用 <span class=exturl data-url=aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class=post-nav><div class="item left"><a href=/computer-science/computer-basic/composition/ccppart2/ itemprop=url rel=prev data-background-image=https:&#x2F;&#x2F;resa-imgs.oss-accelerate.aliyuncs.com&#x2F;img&#x2F;acg9.webp title=计算机组成原理-CSAPP-第二部分><span class=type>上一篇</span><span class=category><i class="ic i-flag"></i> 计算机组成原理</span><h3>计算机组成原理-CSAPP-第二部分</h3></a></div><div class="item right"><a href=/computer-science/computer-basic/composition/ccppart4/ itemprop=url rel=next data-background-image=https:&#x2F;&#x2F;resa-imgs.oss-accelerate.aliyuncs.com&#x2F;img&#x2F;acg21.webp title=计算机组成原理-CSAPP-第四部分><span class=type>下一篇</span><span class=category><i class="ic i-flag"></i> 计算机组成原理</span><h3>计算机组成原理-CSAPP-第四部分</h3></a></div></div><div class=wrap id=comments><div id=waline-comment></div></div></div><div id=sidebar><div class=inner><div class=panels><div class=inner><div class="contents panel pjax" data-title=文章目录><ol class=toc><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84the-memory-hierarchy><span class=toc-number>1.</span> <span class=toc-text>存储器层次结构(The Memory Hierarchy)</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8%E5%99%A8random-access-memory-ram><span class=toc-number>1.1.</span> <span class=toc-text>随机访问存储器(Random Access Memory - RAM)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%9C%BA%E6%A2%B0%E7%A3%81%E7%9B%98%E6%97%8B%E8%BD%AC%E7%A3%81%E7%9B%98rotating-disk><span class=toc-number>1.2.</span> <span class=toc-text>机械磁盘(旋转磁盘，Rotating Disk)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98solid-state-disk><span class=toc-number>1.3.</span> <span class=toc-text>固态硬盘(Solid State Disk)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7><span class=toc-number>1.4.</span> <span class=toc-text>程序的局部性</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%BC%93%E5%AD%98><span class=toc-number>1.5.</span> <span class=toc-text>缓存</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%ADcache-hit%E4%B8%8E%E7%BC%93%E5%AD%98%E4%B8%8D%E5%91%BD%E4%B8%ADcache-miss><span class=toc-number>1.5.1.</span> <span class=toc-text>缓存命中(Cache Hit)与缓存不命中(Cache Miss)</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%9F%BA%E4%BA%8Esram%E7%9A%84%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98><span class=toc-number>1.5.2.</span> <span class=toc-text>基于SRAM的高速缓存</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#cache%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84><span class=toc-number>1.5.3.</span> <span class=toc-text>cache的内部结构</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98direct-mapped-caches><span class=toc-number>1.5.4.</span> <span class=toc-text>直接映射高速缓存(Direct-Mapped Caches)</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E7%BB%84%E7%9B%B8%E8%81%94cache><span class=toc-number>1.5.5.</span> <span class=toc-text>组相联cache</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%85%A8%E7%9B%B8%E8%BF%9E%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98cache><span class=toc-number>1.5.6.</span> <span class=toc-text>全相连高速缓存cache</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E9%93%BE%E6%8E%A5linking><span class=toc-number>2.</span> <span class=toc-text>链接(Linking)</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B><span class=toc-number>2.1.</span> <span class=toc-text>链接过程</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6relocatable-object-files><span class=toc-number>2.2.</span> <span class=toc-text>可重定位目标文件(Relocatable Object Files)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%AC%A6%E5%8F%B7%E4%B8%8E%E7%AC%A6%E5%8F%B7%E8%A1%A8><span class=toc-number>2.3.</span> <span class=toc-text>符号与符号表</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93><span class=toc-number>2.4.</span> <span class=toc-text>符号解析与静态库</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B><span class=toc-number>2.5.</span> <span class=toc-text>静态库的解析过程</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E9%87%8D%E5%AE%9A%E4%BD%8Drelocation><span class=toc-number>2.6.</span> <span class=toc-text>重定位(Relocation)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6executable-object-files><span class=toc-number>2.7.</span> <span class=toc-text>可执行目标文件(Executable Object Files)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB%E5%BA%93><span class=toc-number>2.8.</span> <span class=toc-text>动态链接共享库</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title=系列文章><ul><li><a href=/computer-science/computer-basic/composition/ccppart1/ rel=bookmark title=计算机组成原理-CSAPP-第一部分>计算机组成原理-CSAPP-第一部分</a></li><li><a href=/computer-science/computer-basic/composition/ccppart2/ rel=bookmark title=计算机组成原理-CSAPP-第二部分>计算机组成原理-CSAPP-第二部分</a></li><li class=active><a href=/computer-science/computer-basic/composition/ccppart3/ rel=bookmark title=计算机组成原理-CSAPP-第三部分>计算机组成原理-CSAPP-第三部分</a></li><li><a href=/computer-science/computer-basic/composition/ccppart4/ rel=bookmark title=计算机组成原理-CSAPP-第四部分>计算机组成原理-CSAPP-第四部分</a></li></ul></div><div class="overview panel" data-title=站点概览><div class=author itemprop=author itemscope itemtype=http://schema.org/Person><img class=image itemprop=image alt=ReverseSacle data-src=/images/avatar.webp><p class=name itemprop=name>ReverseSacle</p><div class=description itemprop=description>知识书库 & 学习点滴</div></div><nav class=state><div class="item posts"><a href=/archives/ ><span class=count>186</span> <span class=name>文章</span></a></div><div class="item categories"><a href=/categories/ ><span class=count>52</span> <span class=name>分类</span></a></div><div class="item tags"><a href=/tags/ ><span class=count>18</span> <span class=name>标签</span></a></div></nav><div class=social><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JldmVyc2VTYWNsZQ==" title=https:&#x2F;&#x2F;github.com&#x2F;ReverseSacle><i class="ic i-github"></i></span><span class="exturl item email" data-url="bWFpbHRvOnByaXZhdGVAcmV2ZXJzZXNhY2xlLmNvbQ==" title=mailto:private@reversesacle.com><i class="ic i-envelope"></i></span></div><ul class=menu><li class=item><a href=/ rel=section><i class="ic i-home"></i> 首页</a></li><li class="item dropdown"><a href=javascript:void(0);><i class="ic i-feather"></i> 文章</a><ul class=submenu><li class=item><a href=/archives/ rel=section><i class="ic i-list-alt"></i> 归档</a></li><li class=item><a href=/categories/ rel=section><i class="ic i-th"></i> 分类</a></li><li class=item><a href=/tags/ rel=section><i class="ic i-tags"></i> 标签</a></li></ul></li><li class=item><a href=/about/ rel=section><i class="ic i-user"></i> 关于</a></li><li class=item><a href=/friend-links/ rel=section><i class="ic i-heart"></i> 友链</a></li></ul></div></div></div><ul id=quick><li class="prev pjax"><a href=/computer-science/computer-basic/composition/ccppart2/ rel=prev title=上一篇><i class="ic i-chevron-left"></i></a></li><li class=up><i class="ic i-arrow-up"></i></li><li class=down><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href=/computer-science/computer-basic/composition/ccppart4/ rel=next title=下一篇><i class="ic i-chevron-right"></i></a></li><li class=percent></li></ul></div></div><div class=dimmer></div></div></main><footer id=footer><div class=inner><div class=widgets><div class="rpost pjax"><h2>随机文章</h2><ul><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/app-development/ title="分类于 应用开发">应用开发</a></div><span><a href=/computer-science/programming/app-development/qt5-newer/ title=qt5.14.2-新手教程>qt5.14.2-新手教程</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/c-basic/ title="分类于 C语言基础">C语言基础</a></div><span><a href=/computer-science/programming/c-language/basis/c/cpart2/ title=C语言基础-第二部分-C89&#x2F;C90标准>C语言基础-第二部分-C89/C90标准</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/database/ title="分类于 数据库">数据库</a></div><span><a href=/computer-science/programming/database/programming/ title=数据库编程基础>数据库编程基础</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/algorithm/ title="分类于 算法">算法</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/algorithm/sort/ title="分类于 序列重组">序列重组</a></div><span><a href=/computer-science/programming/algorithm/sort/counting-sort/ title=计数排序>计数排序</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/c-data-structure/ title="分类于 C语言数据结构">C语言数据结构</a></div><span><a href=/computer-science/programming/c-language/c-data-structure/binary-tree/ title=非线性结构之二叉树(二叉链表)>非线性结构之二叉树(二叉链表)</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/c-algorithm/ title="分类于 C版算法">C版算法</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/two-pointer/ title=双指针>双指针</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/rust/ title="分类于 Rust">Rust</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/rust/rust-basic/ title="分类于 Rust基础">Rust基础</a></div><span><a href=/computer-science/programming/rust/rust-basic/rustpart2/ title=Rust语言-基础-第二部分>Rust语言-基础-第二部分</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/shoka-theme/ title="分类于 Shoka主题">Shoka主题</a></div><span><a href=/computer-science/shoka-theme/image/ title=主要图片及图床配置>主要图片及图床配置</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/dynamic-program/ title="分类于 动态规划">动态规划</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/dynamic-program/pattern/house-robber/ title=房屋盗贼>房屋盗贼</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/c-basic/ title="分类于 C语言基础">C语言基础</a></div><span><a href=/computer-science/programming/c-language/basis/c/cpart3/ title=C语言基础-第三部分-C99标准>C语言基础-第三部分-C99标准</a></span></li></ul></div><div><h2>最新评论</h2><ul id=waline-recent></ul></div></div><div class=status><div class=copyright>&copy; 2021 – <span itemprop=copyrightYear>2025</span><span class=with-love><i class="ic i-sakura rotate"></i></span> <span class=author itemprop=copyrightHolder>ReverseSacle @ ReverseSacle-Blog</span></div><div class=count><i class="ic i-clock" aria-hidden=true></i> <span id=time align=center>载入时间中...<script defer>var now=new Date;function createtime(){var n=new Date("2021-11-16 22:30:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("time").innerHTML="已经过 "+dnum+" 天 "+hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></span><span class=post-meta-item-icon>|&nbsp<i class="ic i-chart-area"></i></span> <span title=站点总字数>2.1m 字</span> <span class=post-meta-item-icon>|&nbsp<i class="ic i-coffee"></i></span> <span title=站点阅读时长>40:40</span></div></div></div></footer></div><script data-config>var LOCAL={path:"computer-science/computer-basic/composition/ccppart3/",favicon:{show:"ReverseSacle-Blog",hide:"ReverseSacle-Blog"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},waline:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src=https://polyfill.alicdn.com/v3/polyfill.min.js></script><script src=https://cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1.16.0/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js></script><script src=/js/app.js></script></body></html>