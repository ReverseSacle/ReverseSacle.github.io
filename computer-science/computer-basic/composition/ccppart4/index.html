<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content=#222><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=icon type=image/ico sizes=48x48 href=/images/favicon.ico><link rel=alternate type=application/rss+xml title=逆转天平 href=https://www.reversesacle.com/rss.xml><link rel=alternate type=application/atom+xml title=逆转天平 href=https://www.reversesacle.com/atom.xml><link rel=alternate type=application/json title=逆转天平 href=https://www.reversesacle.com/feed.json><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel=stylesheet href=/css/app.css><meta name=description content=计算机基础><link rel=canonical href=https://www.reversesacle.com/computer-science/computer-basic/composition/ccppart4/ ><title>计算机组成原理-CSAPP-第四部分 - 计算机组成原理 - 计算机基础 - 计算机科学 | ReverseSacle-Blog</title><meta name=generator content="Hexo 6.3.0"></head><body itemscope itemtype=http://schema.org/WebPage><div id=loading><div class=dotloader><div class=dot></div><div class=dot></div><div class=dot></div><div class=dot></div><div class=dot></div></div></div><div id=container><header id=header itemscope itemtype=http://schema.org/WPHeader><div class=inner><div id=brand><div class=pjax><h1 itemprop="name headline">计算机组成原理-CSAPP-第四部分</h1><div class=meta><span class=item title="创建时间：2023-10-09 20:43:12"><span class=icon><i class="ic i-calendar"></i></span> <span class=text>发表于</span> <time itemprop="dateCreated datePublished" datetime=2023-10-09T20:43:12+08:00>2023-10-09</time></span><span class=item title=本文字数><span class=icon><i class="ic i-pen"></i></span> <span class=text>本文字数</span> <span>13k</span> <span class=text>字</span></span><span class=item title=阅读时长><span class=icon><i class="ic i-clock"></i></span> <span class=text>阅读时长</span> <span>15 分钟</span></span></div></div></div><nav id=nav><div class=inner><div class=toggle><div class=lines role=navigation aria-label=切换导航栏><span class=line></span><span class=line></span><span class=line></span></div></div><ul class=menu><li class="item title"><a href=/ rel=start>ReverseSacle-Blog</a></li></ul><ul class=right><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id=imgs class=pjax><ul><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg20.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg4.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg9.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg15.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg19.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg5.webp></li></ul></div></header><div id=waves><svg class=waves xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink viewBox="0 24 150 28" preserveAspectRatio=none shape-rendering=auto><defs><path id=gentle-wave d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352z"/></defs><g class=parallax><use xlink:href=#gentle-wave x=48 y=0 /><use xlink:href=#gentle-wave x=48 y=3 /><use xlink:href=#gentle-wave x=48 y=5 /><use xlink:href=#gentle-wave x=48 y=7 /></g></svg></div><main><div class=inner><div id=main class=pjax><div class="article wrap"><div class=breadcrumb itemscope itemtype=https://schema.org/BreadcrumbList><i class="ic i-home"></i> <span><a href=/ >首页</a></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/ itemprop=item rel=index title="分类于 计算机科学"><span itemprop=name>计算机科学</span></a><meta itemprop=position content=1></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/computer-basic/ itemprop=item rel=index title="分类于 计算机基础"><span itemprop=name>计算机基础</span></a><meta itemprop=position content=2></span><i class="ic i-angle-right"></i> <span class=current itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/computer-basic/computer-composition-principles/ itemprop=item rel=index title="分类于 计算机组成原理"><span itemprop=name>计算机组成原理</span></a><meta itemprop=position content=3></span></div><article itemscope itemtype=http://schema.org/Article class="post block" lang=zh-CN><link itemprop=mainEntityOfPage href=https://www.reversesacle.com/computer-science/computer-basic/composition/ccppart4/ ><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content=/images/avatar.webp><meta itemprop=name content=ReverseSacle><meta itemprop=description content="所见即所得，所思即所行, 知识书库 & 学习点滴"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content=逆转天平></span><div class="body md" itemprop=articleBody><h2 id=异常控制流exceptional-control-flow><a class=anchor href=#异常控制流exceptional-control-flow>#</a> 异常控制流(Exceptional Control Flow)</h2><p>什么是控制流，从处理器开始上电运行，一直到断电关机的这段时间内，假设程序计数器中的值是下图中的这个序列，其中<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding=application/x-tex>a_k</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.58056em;vertical-align:-.15em></span><span class=mord><span class="mord mathnormal">a</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.33610799999999996em><span style=top:-2.5500000000000003em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style=margin-right:.03148em>k</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span>表示某一条指令<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>I</mi><mi>k</mi></msub></mrow><annotation encoding=application/x-tex>I_k</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.83333em;vertical-align:-.15em></span><span class=mord><span class="mord mathnormal" style=margin-right:.07847em>I</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.33610799999999996em><span style=top:-2.5500000000000003em;margin-left:-.07847em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style=margin-right:.03148em>k</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span>的地址，把每一次从<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding=application/x-tex>a_k</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.58056em;vertical-align:-.15em></span><span class=mord><span class="mord mathnormal">a</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.33610799999999996em><span style=top:-2.5500000000000003em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style=margin-right:.03148em>k</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span>到<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>a</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=application/x-tex>a_{k+1}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.638891em;vertical-align:-.208331em></span><span class=mord><span class="mord mathnormal">a</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.3361079999999999em><span style=top:-2.5500000000000003em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style=margin-right:.03148em>k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.208331em><span></span></span></span></span></span></span></span></span></span>的过渡称为控制转移，最简单的控制流是一个平滑的序列，这里的平滑所表示的含义是<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>I</mi><mi>k</mi></msub></mrow><annotation encoding=application/x-tex>I_k</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.83333em;vertical-align:-.15em></span><span class=mord><span class="mord mathnormal" style=margin-right:.07847em>I</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.33610799999999996em><span style=top:-2.5500000000000003em;margin-left:-.07847em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style=margin-right:.03148em>k</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span>和<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>I</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=application/x-tex>I_{k+1}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.891661em;vertical-align:-.208331em></span><span class=mord><span class="mord mathnormal" style=margin-right:.07847em>I</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.3361079999999999em><span style=top:-2.5500000000000003em;margin-left:-.07847em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style=margin-right:.03148em>k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.208331em><span></span></span></span></span></span></span></span></span></span>在内存中是相邻的，如果平滑的控制流发生了突变，也就是说<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>I</mi><mi>k</mi></msub></mrow><annotation encoding=application/x-tex>I_k</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.83333em;vertical-align:-.15em></span><span class=mord><span class="mord mathnormal" style=margin-right:.07847em>I</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.33610799999999996em><span style=top:-2.5500000000000003em;margin-left:-.07847em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style=margin-right:.03148em>k</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span>和<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>I</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=application/x-tex>I_{k+1}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.891661em;vertical-align:-.208331em></span><span class=mord><span class="mord mathnormal" style=margin-right:.07847em>I</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.3361079999999999em><span style=top:-2.5500000000000003em;margin-left:-.07847em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style=margin-right:.03148em>k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.208331em><span></span></span></span></span></span></span></span></span></span>在内存中是不相邻的，这种情况通常是由跳转，函数调用和返回这类指令造成，这类指令所导致的突变属于必要的机制，不过，系统在运行的过程中，需要对系统状态的变化做出反应，例如从网络中传输的数据包到达网络适配器之后，需要将数据放到内存中，接下来，处理器需要处理这类情况，通常把这类突变称为异常控制流。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/1.webp alt=""></p><p>理解控制流有助于理解重要的系统概念，异常控制流是操作系统用来实现I/O，进程以及虚拟内存的基本机制，在做之前，需要先理解异常控制流；有助于理解应用程序是如何与操作系统交换的，例如当需要向磁盘写入数据，或创建一个新的进程，这类操作都是应用程序通过系统调用来实现的；有助于理解这些服务是如何提供给应用程序的；有助于编写一些有趣的应用程序，例如，Unix shell和Web服务器这类应用；有助于理解并发，异常控制流是计算机系统中实现并发的基本机制；有助于理解软件异常是如何工作的，在cpp和Java中，都提供<code>try-catch-throw</code>语句来捕获软件异常，软件异常允许程序进行非本地跳转来响应错误，关于非本地跳转指的是违反通常的调用/返回栈规则的跳转，它是一种应用层的异常控制流，在C语言中通过函数setjmp和longjmp实现的，理解这些底层的函数有助于理解高级软件异常时如何实现的。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/2.webp alt=""></p><h3 id=异常><a class=anchor href=#异常>#</a> 异常</h3><p>当处理器正在执行应用程序中某一条指令时，此时系统发生了一个事件，这个事件可能和当前指令的执行直接相关，也可能无关，例如当前指令执行的是除以0的操作，那么此时异常的发生就与当前指令有关，如果事件是一个I/O请求的完成，那么就与当前指令的执行无关，在任何情况下，当处理器检测到有事件发生时，接下来，处理器从执行应用程序切换到异常处理程序，当异常处理程序完成后，根据引起异常的事件类型选择是否返回。处理异常需要硬件和软件紧密配合，系统为每种类型的异常都分配了唯一的异常编号，其中一些号码是由处理器的设计者分配的，例如，被零除，缺页以及算术运算溢出等等，其他号码是由操作系统内核的设计者分配的，例如，系统调用以及来自外部I/O设备的信号，当处理器检测到异常事件的发送，并确定了相应的异常编号k，然后根据异常编号从异常表中检索对应的异常处理程序来处理异常。异常表是在系统启动时，操作系统分配和初始化的一个跳转表，其中异常号就是这个跳转表的索引号，异常表的起始地址是保存在CPU中的一个特殊的寄存器中，这样一来，通过异常表基址寄存器与异常号可以确定对应的异常表项，异常表项中的内容是对应的异常处理程序的起始地址，综上所述，异常的处理类似执行一个间接的函数调用。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/3.webp alt=""></p><p>不过二者之间还有一些重要的不同之处，当发生函数调用时，在跳转到目的函数之前，处理器首先将返回地址压入栈中，然而根据异常的类型，返回地址要么是当前指令，要么是下一条指令，处理器在处理异常时，会把处理器额外的一些状态压到栈中，当重新开始执行被中断的程序时，需要这些状态，例如<code>x86-64</code>系统会将包含当前条件码的EFLAGS寄存器压入栈中。如果控制是从应用程序转移到系统内核，那么所有的这些内容都被压倒内核栈中，而不是用户栈中。最后一点，异常处理程序是运行在内核态的，所以它们对所有的系统资源都有访问权限，以上就是异常与函数调用的区别。</p><p>一旦硬件触发了异常，剩下的工作就是由异常处理程序在软件中完成，当异常处理程序处理完事件后，根据引起异常的事件类型，会发生以下3种情况的一种</p><ul><li>异常处理程序将控制交还给之前正在执行的指令，也就是CPU继续执行当前事件发生时正在执行的指令</li><li>异常处理程序将控制返回给下一条指令，这里下一条指令指的是如果没有发生异常将会执行的下一条指令</li><li>异常处理程序会终止之前CPU正在执行的程序</li></ul><p>CSAPP中异常被分成了四类，分别是中断，陷阱，故障和终止，与其他三种异常不同，中断是异步的，这里异步的含义是中断是由处理器外部的I/o设备产生的，而其他三种异常是同步的，是CPU执行当前指令产生的结果，所以这里异步和同步的主要区别是异常产生的原因来自CPU外部还是内部。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/4.webp alt=""></p><p>首先，看下中断的具体处理过程，键盘是一个I/O设备，当敲击键盘时，此时键盘控制器会向处理器的中断引脚发送信号来触发中断，同时会将异常号放到系统总线上，这个异常号标识了引起中断的设备，CPU在执行完当前指令后，发现中断引脚的电压变高了，于是从系统总线上读取异常号，判断是哪个设备发起的中断，然后调用相应的中断处理程序来处理中断，中断处理完毕后，CPU继续执行下一条指令，这里的下一条指令指的是如果没有发生中断，之前控制流中正常执行的指令，CPU返回之后，程序继续执行，好像中断从未发生过一样，以上就是中断的相关内容。</p><p>接下来，看下什么是陷阱，陷阱是一种故意触发异常，它是执行一条指令的结果，陷阱最重要的用途是为用户程序和操作系统内核之间提供一个类似函数的接口，当应用程序需要读取文件或创建新的进程时，此时需要向内核请求服务，处理器提供了一条特殊的指令-<code>syscall</code>，执行syscall指令会导致一个陷阱，接下来陷阱处理程序接卸参数，并调用适当的内核程序提供系统级的服务，陷阱处理程序执行完毕后，返回到指令syscall之后的指令继续执行，以上就是系统调用的大致过程。</p><p>接下来，看下什么是故障，故障是由错误情况引起的，不过故障是有可能被故障处理程序修复的，假设当前的指令导致了故障的发生，处理器会将控制转移给故障处理程序，接下来故障处理程序运行，如果能够修正这个错误的情况，她就将控制返回到引起故障的指令，然后重新执行引发故障的这条指令，如果处理程序无法修正这个错误，就会终止引起故障的应用程序，一个经典的故障示例就是缺页异常，假如当前指令中引用了一个虚拟地址，不过与该地址对应的物理页面不在内存中，这个时候需要从磁盘读取数据到内存，此时当前指令就会引发故障，之后的缺页处理程序会从磁盘加载对应的页面到内存，然后将控制返回给引起故障的指令，此时继续执行的指令是引起故障的指令，当这条指令再次执行时，相应的物理页面已经在内存里了，所以这一次执行就不会引发故障，从而可以继续执行了。</p><p>最后一种异常就是终止，终止是由不可恢复的致命错误导致的，通常是一些硬件错误，例如DRAM或者SRAM的存储位被损坏时，会导致奇偶校验出错，对于这类的硬件错误，终止处理程序从不将控制返回给应用程序，而是直接终止这个应用程序，以上就是不同异常的产生原因以及返回结果的具体情况，在<code>x86-64</code>系统中一共定义了256种异常类型，其中<code>0~31</code>号异常是由Intel的架构师定义的，因此对于任意的<code>x86-64</code>系统都是一样的，编号<code>32~255</code>所对应的异常是由操作系统定义，下图为几个异常的示例，</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/5.webp alt=""></p><p>当一条指令试图进行除以0的操作，就会发生除法错误，此时异常处理程序不会试图恢复这个错误，而是选择终止程序，Linux Shell通常会把除法错误报告为浮点异常。</p><p>接下来，看下异常号为13的异常，该异常通常是由于程序引用了一个未定义的虚拟内存区域导致的，或者是程序试图去写一个只读的文本段，对于这类异常，系统并不会尝试去恢复，Linux Shell通常会把这种一般保护故障报告为段错误，异常号为18的异常称为机器检查，该异常是硬件发生错误时导致的，机器检查处理程序会终止引发异常的应用程序，以上这几个异常示例是由芯片架构师定义的。</p><p>接下来，看下操作系统定义的异常，Linux系统提供了几百种的系统调用，例如下图，</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/6.webp alt=""></p><p>列出了一些常用的系统调用，例如读文件，写文件等，每个系统调用都有一个唯一的整数号，这个整数对应的是内核中跳转表的偏移量，这里的跳转表和异常表并不是同一个，接下来是一个代码示例，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token function">write</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"hello,world"</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>用系统级函数write来实现相同的功能，其中第一个参数1表示将输出发送到标准输出stdout，第二个参数是要输出的具体内容，第三个参数13表示输出字符串的长度，在<code>x86-64</code>系统中，系统调用是通过陷阱指令syscall来实现的。</p><p>接下来，看下使用汇编代码编写一个程序来实现系统级函数write的调用，</p><figure class="highlight nasm"><figcaption data-lang="NASM-X86/X86-64 Assembly"></figcaption><table><tr><td data-num=1></td><td><pre><span class="token label function">main:</span></pre></td></tr><tr><td data-num=2></td><td><pre>	movq <span class="token number">$1</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=3></td><td><pre>	movq <span class="token number">$1</span>,<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=4></td><td><pre>	movq <span class="token operator">$</span>string,<span class="token operator">%</span><span class="token register variable">rsi</span></pre></td></tr><tr><td data-num=5></td><td><pre>	movq <span class="token operator">$</span>len,<span class="token operator">%</span><span class="token register variable">rdx</span></pre></td></tr><tr><td data-num=6></td><td><pre>	syscall</pre></td></tr><tr><td data-num=7></td><td><pre>	</pre></td></tr><tr><td data-num=8></td><td><pre>	movq <span class="token number">$60</span>,<span class="token operator">%</span><span class="token register variable">rax</span></pre></td></tr><tr><td data-num=9></td><td><pre>	movq <span class="token number">$0</span>,<span class="token operator">%</span><span class="token register variable">rdi</span></pre></td></tr><tr><td data-num=10></td><td><pre>	syscall</pre></td></tr></table></figure><p>其中<code>9~13</code>行是调用函数write，第一条mov指令将立即数1传送到寄存器rax，linux系统调用的参数都是通过寄存器来传递的，按照惯例，寄存器rax用来传递系统调用号，由于函数write的编号为1，所以这里将立即数1传给rax，接下来调用函数exit时，需要将函数exit的编号60传给rax。之后的三条mov指令，寄存器rdi用来传递第一个参数，rsi传递第二个参数，rdx传递第三个参数，随后的指令syscall执行函数调用，以上就是调用函数write的汇编实现。函数exit的实现与函数write的实现类似，需要注意函数exit的编号是60。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/7.webp alt=""></p><h3 id=进程processes><a class=anchor href=#进程processes>#</a> 进程(Processes)</h3><p>进程就是一个正在执行的程序实例，当在shell中输入一个可执行程序的名字后，然后按下回车键，此时shell就会创建一个新的进程，然后处理器运行这个可执行程序。</p><p>在现代操作系统上运行一个程序时，会得到一个假象，好像是程序独占了整个处理器，处理器在不间断的执行程序指令。还有一个假象，就是程序中的代码和数据好像是系统内存中唯一的对象，这些假象都是通过进程的方式提供给程序的。</p><p><strong>逻辑控制流(Logical Control Flow)</strong></p><p>假如用调用器来控制程序单步执行，会看到一系列的程序计数器的数值，这些数值与可执行程序中的指令是一一对应的，把这个PC值得序列叫做逻辑控制流，简称逻辑流。</p><p>假设系统中运行着三个进程，分别是进程A，进程B以及进程C，对于一个单核处理器，它在某一时间段内只能执行一个进程，因此，处理器得物理控制流被分成了三个逻辑流，每个进程有一个，每个竖直的线表示一个进程的逻辑控制流的一部分，在这个例子中，三个进程的执行是交错进行的，进程A执行一会儿，然后进程B开始执行，一直到结束，接下来进程C开始执行，运行一段时间后，进程A开始执行，一直到结束，最后进程C运行到结束，下图描述了不同进程之间轮流使用处理器的情况，每个进程执行逻辑流的一部分，把一个逻辑流的执行在时间上另一个流重叠的情况，称为并发流，两个流的执行被称为并发运行，例如进程A和进程B是并发运行的，同样A和C也是，不过进程B和进程C并不是并发运行的，这是因为，进程C开始运行之前进程B执行结束了，所以二者不能称为并发。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/8.webp alt=""></p><p>初学者会把并发和并行两个概念混淆，并行是两个进程在不同的处理器核上同时运行，因此，对于二者的区别是，并发是交替运行的，而并行是同时运行的。除此之外，进程也为每个程序提供了另外一种假象，好像程序本身独占整个系统的地址空间，下图展示了一个<code>x86-64 Linux</code>进程的地址空间分布，</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/9.webp alt=""></p><p>地址空间的低地址部分是预留给应用程序的，包括代码段，数据段，堆和栈，代码段总是从地址<code>0小00000</code>处开始，地址空间的高地址部分是预留给操作系统内核的，属于用户代码不可见的内存区域。在Linux系统的根目录下有一个<code>/proc</code>的文件夹，这个文件夹下的文件是用户程序可以读取的，这些文件记录的是内核相关的数据结构，例如可以使用<code>cat cpuinfo</code>命令查看CPU的信息，因此通过这种方式用户模式下的进程也能访问内核数据结构的内容，以上就是地址空间的相关内容。</p><p>为了限制应用程序执行某些特殊的指令以及限制可以访问的地址空间范围，通常处理器通过控制寄存器的模式位来实现这些限制功能，该寄存器描述了进程当前的权限，也就是说当设置了控制寄存器的模式位后，进程就运行在内核模式，有的地方把内核模式也叫做超级用户模式，对于一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中任意的内存位置，如果没有设置模式位，进程就运行在用户模式，处于用户模式的进程不允许执行特权指令，特权指令可以停止处理器，改变模式位以及发起一个I/O操作等，除此之外，用户模式的进程也不能直接引用内核区域的代码和数据，如果用户程序试图访问内核区域，就会导致保护故障，然后该用户程序将被终止运行，不过用户程序可以通过系统调用间接的来访问内核的代码和数据，通常情况下，应用程序在一开始是运行在用户模式下，进行从用户模式切换到内核模式需要通过中断，故障或系统调用的方式，当这类异常发生时，执行异常处理程序处理异常，处理器的模式就会从用户模式变为内核模式，当返回到应用程序进行执行时，会从内核模式改回到用户模式，以上就是用户模式以及内核模式的相关内容。</p><h3 id=上下文context><a class=anchor href=#上下文context>#</a> 上下文(Context)</h3><p>内核为每一个进程维持了一个上下文，上下文就是内容重新启动一个被抢占的进程所需的状态，它是由一些对象的值组成，这些对象包括通用目的寄存器，浮点寄存器，程序计数器，用户栈，状态寄存器，内核栈和各种内核数据结构，其中内核数据结构包括描述地址空间的页表，包含有关当前进程信息的进程表以及包含进程已打开文件的信息表，在进程执行的默写时刻，内核可以决定抢占当前进程，然后重新开始执行先前被抢占的进程，这种决策被称为进程调度，是由内核中的调度器来执行的，当内核选择一个新的进程运行时，就说明内核调度了这个进程，当内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转到新的进程，上下文切换主要分为三步。第一，保存当前进程的上下文。第二，恢复某个先前被抢占的进程的上下文。第三，将控制传递给这个新恢复的进程。当内核代表用户程序执行系统调用时，可能会发生上下文的切换，中断也可能引起上下文的切换，下图展示进程A和进程B之间上下文切换的示例，最开始进程A运行在用户模式下，当进程A需要从磁盘中读取数据时，它会执行系统调用函数read陷入到内核中，然后陷阱处理程序向磁盘控制器发起一个DMA的请求，并且安排磁盘控制器完成从磁盘到内存的数据传输之后，磁盘需要向处理器发送中断，磁盘读取数据需要一段较长的时间，一般为几十毫秒，对于处理器来说，几十毫秒的时间是非常长的，所以内核执行从进程A到进程B的上下文切换，而不是处于等待，随后，进程B在用户模式下运行，直到磁盘发出一个中断的信号，表示数据已经从磁盘传送到了内存，内核判定进程B已经运行了足够长的时间，就执行一个从进程B到进程A的上下文切换，将控制返回给进程A中紧跟在系统调用read之后的那条指令，然后进程A继续执行，直到下一次异常发生，以上就是进程A和B进行上下文切换的具体过程。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/10.webp alt=""></p><h3 id=fork><a class=anchor href=#fork>#</a> fork</h3><p>当在shell中运行hello程序时，把shell看成父进程，可执行程序hello看成子进程，在这个过程中，父进程通过调用fork函数来创建一个新的可以运行的子进程。程序是一段代码和数据，例如hello程序在执行之前是以文件的形式存储在磁盘上，在执行的过程中，程序是以段的形式存在于内存的地址空间中，然而对于进程，它是正在执行中程序的一个具体的实例。可以认为进程的状态总共由三种，分别是运行(Running)，暂停(Stopped)，终止(Terminated)。</p><p>程序的运行状态是指进程要么在CPU上执行，要么等待被执行，这里等待的意思是进程最终会被内核调度执行的，关于暂停状态是指进程被挂起，它不会被调度执行，当进程收到<code>SIGSTOP SIGTSTP SIGTTIN SIGTTOU</code>这几个信号时，进程就会进入到暂停状态，并且会一直保持该状态，一直到进程收到一个SIGCONT的信号，此时进程再次开始运行，关于信号是一个软件中断的形式。</p><p>对于进程的终止状态，指的是进程永远不会再运行了，进程终止的原因有三个，第一种是进程收到了一个信号，该信号的默认行为就是终止进程。第二种是进程从主程序返回。第三种是调用了exit函数。</p><p>接下来，看下如何创建一个进程，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token class-name">pid_t</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>函数fork的定义如图所示，在Linux系统上，返回值的类型pid_t在文件<code>types.h</code>中被定义为int类型，通常调用一个函数只会返回一次，然而函数fork被调用一次，却会返回两次，一次是返回到父进程，另外一次是返回到新创建的子进程。接下来，通过一个代码示例来解释下，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    </pre></td></tr><tr><td data-num=6></td><td><pre>    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child: x=%d\n"</span><span class="token punctuation">,</span><span class="token operator">++</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    </pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"parent:x=%d\n"</span><span class="token punctuation">,</span><span class="token operator">--</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=15></td><td><pre></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token comment"> * 结果为</span></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token comment"> * parent: x=0</span></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token comment"> * child: x=2</span></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><p><code>pid = fork()</code>这一行代码调用了fork函数，返回值存放在pid中，在父进程中，函数fork的返回值的是子进程的PID，在子进程中，函数fork的返回值的是0，由于子进程的进程号总是大于0的，所以可以利用返回值的不同来区分程序究竟是在父进程中执行，还是在子进程中执行。接着看到结果，程序最开始时，父进程将变量x设置为1，当父进程调用函数fork时会创建一个子进程，由于函数fork返回到父进程与子进程的返回值不同，根据程序的逻辑，二者执行的代码也会发生变化。在子进程中，fork返回0，因此，对于子进程来说将会执行if内的printf，打印2之后退出。对于父进程来说，fork返回子进程的进程号，因此执行if外面的printf语句，打印0之后退出。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/11.webp alt=""></p><p>通过这个代码示例，可以看到函数fork确实只调用了一次，但是却返回了两次，对于多次调用fork的程序会令人困惑。虽然子进程是父进程创建的但是二者是独立并发执行的，也就是说，在一个计算机系统上父进程先执行printf打印，然后是子进程执行，然而在其他的系统上运行相同的程序时，很可能会得到相反的结果，所以究竟是父进程先执行打印，还是子进程先执行打印，对于不同的系统很可能是不同的。当父进程调用fork函数创建子进程后，如果立即暂停程序继续执行，也就是说不等到函数fork返回到父进程和子进程之前就执行一个暂停的操作，此时父进程与子进程的地址空间中的内容是相同的，二者具有相同的用户栈，本地变量值，堆，全局变量值以及代码，对于刚才的代码示例，函数fork返回后，本地变量x在父进程和子进程中都是1，然而父进程和子进程是独立的进程，它们都有自己的私有地址空间，后面父进程和子进程对变量x所做的任何改变都是独立的，不会反映到另外一个进程的内存中，这就是为什么父进程和子进程在打印变量x时会得到不同的值，综上所述，子进程虽然复制了父进程所有的地址空间中内容，但是二者具有独立的地址空间，执行时互不干扰，当运行这个示例程序时，父进程和子进程都把它们的输出显示到了屏幕上，原因是子进程继承了父进程所有打开的文件，当父进程调用fork函数时，标准输出文件是打开的，并指向屏幕，子进程继承了这个文件，所以它的输出也是指向屏幕的。</p><p>接着看一个代码示例，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这个程序调用了两次fork函数，父进程首次执行fork后，此时创建了一个新的子进程，之后的父进程与子进程继续执行。接下来第二次执行fork，父进程和子进程都会执行这一条fork语句，然后二者分别创建了各自的子进程，接下来继续执行printf语句，最终得到4次hello的输出，因外有4个进程执行了printf语句，由于这四个进程是并发的，所以这4个hello的输出是任意顺序的。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/12.webp alt=""></p><h3 id=execv函数与waitpid函数><a class=anchor href=#execv函数与waitpid函数>#</a> execv函数与waitpid函数</h3><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">int</span> <span class="token function">execve</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> filename<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>与fork函数不同的是，函数execve调用之后，不会返回。调用execve函数需要传入三个参数，第一个参数filename表示可执行程序的文件名，第二个参数argv表示执行程序需要输入的参数列表，第三个参数envp表示环境变量列表。当在Linux shell中输入这条命令<code>ls -lt /home/csapp</code>，其中ls表示应用程序的名字，紧跟其后的<code>-lt</code>和路径就是可执行程序ls的参数列表，可以画出参数列表argv的数据结构图。</p><p>指针argv指向一个指针数组，这个指针数组中的每一个元素都指向一个字符串，这个字符串就对应输入的参数，按照惯例，argv[0]是可执行程序的名字，在这个例子中argv[0]就是ls，argv[1]表示第一个参数，也就是<code>-lt</code>，图中的argc表示参数的个数，在刚才的例子中有三个参数，因此argc就等于3，那么argv[2]指向的参数就是路径，最后这个指针数组是以NULL结尾的，以上就是参数列表argv的相关内容。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/13.webp alt=""></p><p>接着，再看下环境变量列表envp，与参数列表argv类似，envp也是指向一个指针数组，其中每一个指针指向一个环境变量的字符串，例如环境变量包括当前的工作目录PWD，用户名等信息。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/14.webp alt=""></p><p>之间简述了加载器加载可执行程序的具体过程，函数execve的作用就是调用加载器，在执行可执行程序的main函数之前，启动代码需要设置用户栈，并将控制传递给新程序的主函数，该主函数的形式具体为，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>函数main有三个参数，分别argc，argv以及envp，第一个参数argc表示数组argv中非空指针的数量。第二个参数argv指向数组argv中的第一个元素，第三个参数envp指向数组envp数组中的第一个元素，当main函数开始执行时，用户栈的组织结果如下图，其中包含参数列表以及环境变量字符串，栈顶是系统启动函数<code>libc_start_main</code>的栈帧，由于main函数是<code>libc_start_main</code>调用的，所以<code>libc_start_main</code>的栈帧在高地址处，main函数的栈帧在低地址处，以上就是函数execve的大致内容。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/15.webp alt=""></p><p><strong>僵死进程(zombie)</strong></p><p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除，此时，进程被保持在一种已终止状态中，直到它的父进程被回收，把一个终止运行但是还未被回收的进程称为僵死进程，一个僵死进程虽然没有在运行，但是仍旧在消耗系统的内存资源，例如shell中运行了某个应用程序，该应用程序出现了某种问题被终止运行了，那么shell应该对这个僵死进程进行回收。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/wait.h></span></span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token class-name">pid_t</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">*</span> statusp<span class="token punctuation">,</span><span class="token keyword">int</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在Linux系统中父进程可以通过函数waitpid来等待它的子进程终止或停止，如果函数第一个参数pid的值大于0，表示等待的进程是一个单独的子进程，那么这个子进程的ID就是这个pid的值，如果参数pid的值等于<code>-1</code>，表示等待的进程是由父进程创建的所有子进程组合的集合。第二个参数statusp是非空的，那么函数waitpidJ就会在status中放上导致返回的子进程的状态信息，这个status就是statusp所指向的值，在<code>wait.h</code>的头文件中定义了解释status参数的几个宏，如下图，假如子进程是通过函数exit或者一个return正常终止，那么这个宏WIFEXITED的结果就是true；假如子进程是因为一个未捕获的信号终止的，那么这个宏WIFSIGNALED就返回true。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/16.webp alt=""></p><p>接下来，看一个代码示例，</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/17.webp alt=""></p><p>图中这段代码，父进程通过循环创建了N个子进程，可以确定每个子进程都会执行函数exit，因此，每个子进程会以唯一的退出状态退出。接下来，父进程用函数waitpid作为while循环的测试条件，等待它所有的子进程终止，这里waitpid有三个参数，其中参数<code>-1</code>表示父进程所等待的进程集合都是该父进程创建的子进程，接下来检查子进程的退出状态，如果子进程是正常终止的，也就是说子进程是调用函数exit终止的，这个宏WIFEXIED的返回值就是true，那么父进程就会将这个子进程的信息打印出来，程序不会按照特定的顺序回收子进程，也就是说，每次运行该程序时，两个子进程都可能以相反的顺序被回收，为了消除这种不确定性，对这段代码进行改进，改进后的代码可以按照父进程创建子进程的相同顺序来回收这些子进程，这里父进程用一个数组pid[N]来存储所有子进程的PID，然后通过PID的值作为第一个参数来调用函数waitpid，这样一来，父进程就可以按照子进程的顺序来等待每个子进程的结束，同样，还可以根据宏WIFEXIED的返回值来判断子进程是否正常退出，如果解释结果是true，打印子进程的相关信息，否则输出非正常终止的信息，以上就是关于进程回收的相关内容。</p><h3 id=信号linux-signal><a class=anchor href=#信号linux-signal>#</a> 信号(Linux Signal)</h3><p>更高层次的软件形式的异常 - Linux信号，它允许内核和进程中断其他的进程，下图列举了部分Linux系统上所支持的信号，</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/18.webp alt=""></p><p>每种不同的信号对于某种系统事件，正常情况下，底层硬件的异常是由于内核异常处理程序处理的，对于用户程序而言是不可见的，信号提供了一种机制，用来通知进程发生了哪些异常情况，当一个进程试图执行除以0的操作时，那么内核会发送给该进程一个SIGFPG的信号，这个信号对应的是浮点异常的事件，如果一个进程执行了一条非法指令，那么内核会发给该进程一个SIGILL的信号，该信号对应的事件是非法指令，如果一个进程正在Linux shell中运行，此时按下<code>Ctrl + C</code>键，那么内核就会发送一个中断信号给当前的进程，终止它的运行，以上就是几种信号所引发事件。</p><p>接下来看下，信号传送的过程，Linux系统提供了几种向进程发送信号的机制。先看下进程组(Process Groups)的概念，每个进程都只属于一个进程组，每个进程组都有自己的ID值来唯一标识，这个ID是一个整数，可以使用</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token class-name">pid_t</span> <span class="token function">getpgrp</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>函数getgrp来获取当前进程所属的进程组ID值，默认情况下，一个子进程和它的父进程属于一个进程组，不过进程可以通过图中这个函数来改变自己或者其他进程的进程组，如下</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token class-name">pid_t</span> <span class="token function">setpgrp</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span><span class="token class-name">pid_t</span> pgid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>其中参数pid标识进程原来的进程组的ID，pgid表示更改后的进程组的ID，如果参数pid的值为0，那么就使用当前进程的PID值，如果参数pgid是0，那么就用pid指定的进程PID作为进程组的ID值。例如，如果在进程号为15213的进程中调用了函数setpgid，其他参数pid和pgid都为0，那么这个函数执行完毕后，就会创建一个新的进程组，这个新进程组的ID值为15213，然后把进程15213加入到这个新的进程组中，执行完毕后，进程组的ID值和进程的pid都是15213，介绍完了进程组的概念，来看下发送信号的几种方式。第一种，可以通过<code>/bin</code>目录中的kill程序可以向其他的进程发送任意的信号，<code>/bin/kill -9 15213</code>这条命令是向进程号为15213的进程发送信号9，信号9表示杀死进程，这条命令执行完毕后，该进程终止运行。<code>/bin/kill -9 -15213</code>这条命令，其中<code>-15213</code>表示向进程组15213发送信号，这个信号9将会发送到该进程组中的每一个进程中，这样一来，该进程组中的所有进程都将终止运行，这里用了程序kill的完整路径，是因为有些shell中内置了命令kill，以上就是通过程序kill向进程发送信号的具体用法。</p><p>接下来，看下如何从键盘发送信号，当在键盘上输入<code>ctrl + c</code>键会导致内容发送一个中断信号到前台进程中的所有进程中。例如，当在shell中输入<code>ls | sort</code>命令时，Shell会创建一个前台作业，这个前台作业是有两个进程组成的，其中程序ls可以看成一个进程，程序sort可以看成另外一个进程，这两个进程是通过管道连接起来的，程序ls的输出结果将会作为程序sort的输入。Shell为每个作业创建一个独立的进程组，例如下图展示了有一个前台作业和两个后台作业的shell，前台作业中的父进程PID为20，进程组的ID也为20，父进程创建的两个子进程的PID分别为21和22，这两个进程的进程组ID都是20，在任何时刻，最多有一个前台作业和0个或多个后台作业，当键盘上输入<code>ctrl + c</code>时，默认是终止前台作业，类似的输入<code>ctrl + z</code>会挂起前台作业，以上是通过键盘发送信号的具体用法，刚才介绍了通过程序kill发送信号。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/19.webp alt=""></p><p>除此之外，进程可以通过调用函数kill发送信号给其他进程，当然也包括给自己发送信号，函数kill的定义如下，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;signal.h></span></span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">int</span> <span class="token function">kill</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>如果参数pid的值大于0，那么函数kill发送信号sig给进程pid，如果参数pid等于0，那么函数kill发送信号sig给调用进程所在进程组中的所有进程，当然也包括调用进程自己，如果pid的值小于0，函数kill发送信号sig给进程组中的每个进程，注意这里的进程组ID是pid的绝对值。最后一种是使用函数alarm发送信号，</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre>usigned <span class="token keyword">int</span> <span class="token function">alarm</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> secs<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>进程可以使用函数alram向它自己发送信号(SIGALRM)，其中参数secs表示函数alarm安排内核在secs秒后发送给一个SIGALRM信号给调用进程，如果secs等于0，就不会调度新的闹钟了，以上就是信号发送的几种方式。</p><p>接下来看下接收信号，当内核把进程P从内核模式切换到用户模式时，此时会检查进程P的未阻塞的待处理的信号集合，如果这个集合为空，那么内核将控制传递到进程P的逻辑控制流中的下一条指令；如果集合是非空的，那么内核选择集合中一个信号k，强制进程p接受信号k，接收信号会触发控制转移到信号处理程序，在信号处理程序完成处理之后，它将控制返回给被中断的程序，每一个信号类型都有一个预定义的默认行为。第一种行为是进程终止，例如收到信号SIGKILL之后，接收进程终止运行。第二种行为是进程终止并转储内存(dumping core)，关于转储内存的意思是把代码和数据的内存镜像写道磁盘上。第三种是进程挂起，不过被挂起的进程还能够被SIGCONT信号重启。最后一种是进程可以直接忽略的信号，例如信号SIGCHILD就是可以忽略的，刚刚的图中，</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/20.webp alt=""></p><p>也展示了每个信号类型相关联的默认行为，信号接收以及处理的方式与异常的处理有许多相似之处，例如下图给出了信号处理程序捕获信号的基本思想，一个发出而没有被接受的信号叫做待处理信号，在任何时刻，一种类型的信号最多只会有一个待处理信号，也就是说一个进程有一个类型为k的待处理信号，那么任何接下来发送到这个进程的类型为k的信号都不会排队等待，它们只是被简单的丢弃，所以一个待处理信号最多只能被接受一次，信号处理程序可以被其他信号处理程序中断。</p><p>接下来看一个例子，当主程序接收到信号s时，该信号会中断主程序的执行，将控制转移到处理程序S，当处理程序S运行时，程序又接收到了信号t，该信号会中断处理程序S，控制转移到处理程序T，当T返回时，程序S从它被中断的地方继续执行，S执行完毕后返回，控制传送回主程序，主程序从它被中断的地方继续执行，以上就是信号的相关内容。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/composition/csapp/part4/21.webp alt=""></p><div class=tags><a href=/tags/computer-basic/ rel=tag><i class="ic i-tag"></i> 计算机基础</a></div></div><footer><div class=meta><span class=item><span class=icon><i class="ic i-calendar-check"></i></span> <span class=text>更新于</span> <time title="修改时间：2025-09-19 22:24:59" itemprop=dateModified datetime=2025-09-19T22:24:59+08:00>2025-09-19</time></span><span class=item data-path=/computer-science/computer-basic/composition/ccppart4/ title=阅读次数><span class=icon><i class="ic i-eye"></i></span> <span class=text>阅读次数</span><span class=waline-pageview-count></span> <span class=text>次</span></span></div><div id=copyright><ul><li class=author><strong>本文作者：</strong> ReverseSacle <i class="ic i-at"><em>@</em></i>逆转天平</li><li class=link><strong>本文链接：</strong> <a href=https://www.reversesacle.com/computer-science/computer-basic/composition/ccppart4/ title=计算机组成原理-CSAPP-第四部分>https://www.reversesacle.com/computer-science/computer-basic/composition/ccppart4/</a></li><li class=license><strong>版权声明：</strong> 本站所有文章除特别声明外，均采用 <span class=exturl data-url=aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class=post-nav><div class="item left"><a href=/computer-science/computer-basic/composition/ccppart3/ itemprop=url rel=prev data-background-image=https:&#x2F;&#x2F;resa-imgs.oss-accelerate.aliyuncs.com&#x2F;img&#x2F;acg3.webp title=计算机组成原理-CSAPP-第三部分><span class=type>上一篇</span><span class=category><i class="ic i-flag"></i> 计算机组成原理</span><h3>计算机组成原理-CSAPP-第三部分</h3></a></div><div class="item right"><a href=/computer-science/programming/rust/rust-basic/rustpart1/ itemprop=url rel=next data-background-image=https:&#x2F;&#x2F;resa-imgs.oss-accelerate.aliyuncs.com&#x2F;img&#x2F;acg14.webp title=Rust语言-基础-第一部分><span class=type>下一篇</span><span class=category><i class="ic i-flag"></i> Rust基础</span><h3>Rust语言-基础-第一部分</h3></a></div></div><div class=wrap id=comments><div id=waline-comment></div></div></div><div id=sidebar><div class=inner><div class=panels><div class=inner><div class="contents panel pjax" data-title=文章目录><ol class=toc><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81exceptional-control-flow><span class=toc-number>1.</span> <span class=toc-text>异常控制流(Exceptional Control Flow)</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%BC%82%E5%B8%B8><span class=toc-number>1.1.</span> <span class=toc-text>异常</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%BF%9B%E7%A8%8Bprocesses><span class=toc-number>1.2.</span> <span class=toc-text>进程(Processes)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%B8%8A%E4%B8%8B%E6%96%87context><span class=toc-number>1.3.</span> <span class=toc-text>上下文(Context)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#fork><span class=toc-number>1.4.</span> <span class=toc-text>fork</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#execv%E5%87%BD%E6%95%B0%E4%B8%8Ewaitpid%E5%87%BD%E6%95%B0><span class=toc-number>1.5.</span> <span class=toc-text>execv函数与waitpid函数</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%BF%A1%E5%8F%B7linux-signal><span class=toc-number>1.6.</span> <span class=toc-text>信号(Linux Signal)</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title=系列文章><ul><li><a href=/computer-science/computer-basic/composition/ccppart1/ rel=bookmark title=计算机组成原理-CSAPP-第一部分>计算机组成原理-CSAPP-第一部分</a></li><li><a href=/computer-science/computer-basic/composition/ccppart2/ rel=bookmark title=计算机组成原理-CSAPP-第二部分>计算机组成原理-CSAPP-第二部分</a></li><li><a href=/computer-science/computer-basic/composition/ccppart3/ rel=bookmark title=计算机组成原理-CSAPP-第三部分>计算机组成原理-CSAPP-第三部分</a></li><li class=active><a href=/computer-science/computer-basic/composition/ccppart4/ rel=bookmark title=计算机组成原理-CSAPP-第四部分>计算机组成原理-CSAPP-第四部分</a></li></ul></div><div class="overview panel" data-title=站点概览><div class=author itemprop=author itemscope itemtype=http://schema.org/Person><img class=image itemprop=image alt=ReverseSacle data-src=/images/avatar.webp><p class=name itemprop=name>ReverseSacle</p><div class=description itemprop=description>知识书库 & 学习点滴</div></div><nav class=state><div class="item posts"><a href=/archives/ ><span class=count>186</span> <span class=name>文章</span></a></div><div class="item categories"><a href=/categories/ ><span class=count>52</span> <span class=name>分类</span></a></div><div class="item tags"><a href=/tags/ ><span class=count>18</span> <span class=name>标签</span></a></div></nav><div class=social><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JldmVyc2VTYWNsZQ==" title=https:&#x2F;&#x2F;github.com&#x2F;ReverseSacle><i class="ic i-github"></i></span><span class="exturl item email" data-url="bWFpbHRvOnByaXZhdGVAcmV2ZXJzZXNhY2xlLmNvbQ==" title=mailto:private@reversesacle.com><i class="ic i-envelope"></i></span></div><ul class=menu><li class=item><a href=/ rel=section><i class="ic i-home"></i> 首页</a></li><li class="item dropdown"><a href=javascript:void(0);><i class="ic i-feather"></i> 文章</a><ul class=submenu><li class=item><a href=/archives/ rel=section><i class="ic i-list-alt"></i> 归档</a></li><li class=item><a href=/categories/ rel=section><i class="ic i-th"></i> 分类</a></li><li class=item><a href=/tags/ rel=section><i class="ic i-tags"></i> 标签</a></li></ul></li><li class=item><a href=/about/ rel=section><i class="ic i-user"></i> 关于</a></li><li class=item><a href=/friend-links/ rel=section><i class="ic i-heart"></i> 友链</a></li></ul></div></div></div><ul id=quick><li class="prev pjax"><a href=/computer-science/computer-basic/composition/ccppart3/ rel=prev title=上一篇><i class="ic i-chevron-left"></i></a></li><li class=up><i class="ic i-arrow-up"></i></li><li class=down><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href=/computer-science/programming/rust/rust-basic/rustpart1/ rel=next title=下一篇><i class="ic i-chevron-right"></i></a></li><li class=percent></li></ul></div></div><div class=dimmer></div></div></main><footer id=footer><div class=inner><div class=widgets><div class="rpost pjax"><h2>随机文章</h2><ul><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/network-programming/ title="分类于 网络编程">网络编程</a></div><span><a href=/computer-science/programming/network-programming/ubuntu-obs-server/ title="Ubuntu服务器OBS Studio配置">Ubuntu服务器OBS Studio配置</a></span></li><li class=item><div class=breadcrumb><a href=/categories/general-science-and-technology/ title="分类于 通用科学技术">通用科学技术</a><i class="ic i-angle-right"></i> <a href=/categories/general-science-and-technology/pc/ title="分类于 通用技术之PC端">通用技术之PC端</a><i class="ic i-angle-right"></i> <a href=/categories/general-science-and-technology/pc/external-device/ title="分类于 外接设备">外接设备</a></div><span><a href=/general-science-and-technology/pc/external-device/external-screen-guidance/ title=外接显示屏DIY指南>外接显示屏DIY指南</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/algorithm/ title="分类于 算法">算法</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/algorithm/sort/ title="分类于 序列重组">序列重组</a></div><span><a href=/computer-science/programming/algorithm/sort/swap-sort/ title=交换排序>交换排序</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/computer-basic/ title="分类于 计算机基础">计算机基础</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/computer-basic/computer-composition-principles/ title="分类于 计算机组成原理">计算机组成原理</a></div><span><a href=/computer-science/computer-basic/composition/ccppart1/ title=计算机组成原理-CSAPP-第一部分>计算机组成原理-CSAPP-第一部分</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/c-data-structure/ title="分类于 C语言数据结构">C语言数据结构</a></div><span><a href=/computer-science/programming/c-language/c-data-structure/linklist/ title=线性表之链表>线性表之链表</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a></div><span><a href=/computer-science/programming/c-language/c-data-structure/linear-structure/static-link-list/ title=C语言-静态单向链表>C语言-静态单向链表</a></span></li><li class=item><div class=breadcrumb><a href=/categories/general-science-and-technology/ title="分类于 通用科学技术">通用科学技术</a><i class="ic i-angle-right"></i> <a href=/categories/general-science-and-technology/pc/ title="分类于 通用技术之PC端">通用技术之PC端</a><i class="ic i-angle-right"></i> <a href=/categories/general-science-and-technology/pc/laptop/ title="分类于 笔记本">笔记本</a></div><span><a href=/general-science-and-technology/pc/laptop/laptop-clean/ title=笔记本的清洁>笔记本的清洁</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/backtracking/ title="分类于 回溯">回溯</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/backtracking/permutation/ title=回溯-排列>回溯-排列</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/database/ title="分类于 数据库">数据库</a></div><span><a href=/computer-science/programming/database/sql/ title=关系数据库标准语言SQL>关系数据库标准语言SQL</a></span></li><li class=item><div class=breadcrumb><a href=/categories/general-science-and-technology/ title="分类于 通用科学技术">通用科学技术</a><i class="ic i-angle-right"></i> <a href=/categories/general-science-and-technology/pc/ title="分类于 通用技术之PC端">通用技术之PC端</a><i class="ic i-angle-right"></i> <a href=/categories/general-science-and-technology/pc/external-device/ title="分类于 外接设备">外接设备</a></div><span><a href=/general-science-and-technology/pc/external-device/lenovo-external-display/ title=解决联想外接显示屏问题>解决联想外接显示屏问题</a></span></li></ul></div><div><h2>最新评论</h2><ul id=waline-recent></ul></div></div><div class=status><div class=copyright>&copy; 2021 – <span itemprop=copyrightYear>2025</span><span class=with-love><i class="ic i-sakura rotate"></i></span> <span class=author itemprop=copyrightHolder>ReverseSacle @ ReverseSacle-Blog</span></div><div class=count><i class="ic i-clock" aria-hidden=true></i> <span id=time align=center>载入时间中...<script defer>var now=new Date;function createtime(){var n=new Date("2021-11-16 22:30:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("time").innerHTML="已经过 "+dnum+" 天 "+hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></span><span class=post-meta-item-icon>|&nbsp<i class="ic i-chart-area"></i></span> <span title=站点总字数>2.1m 字</span> <span class=post-meta-item-icon>|&nbsp<i class="ic i-coffee"></i></span> <span title=站点阅读时长>40:40</span></div></div></div></footer></div><script data-config>var LOCAL={path:"computer-science/computer-basic/composition/ccppart4/",favicon:{show:"ReverseSacle-Blog",hide:"ReverseSacle-Blog"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},waline:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src=https://polyfill.alicdn.com/v3/polyfill.min.js></script><script src=https://cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1.16.0/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js></script><script src=/js/app.js></script></body></html>