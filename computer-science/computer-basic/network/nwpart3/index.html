<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content=#222><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=icon type=image/ico sizes=48x48 href=/images/favicon.ico><link rel=alternate type=application/rss+xml title=逆转天平 href=https://www.reversesacle.com/rss.xml><link rel=alternate type=application/atom+xml title=逆转天平 href=https://www.reversesacle.com/atom.xml><link rel=alternate type=application/json title=逆转天平 href=https://www.reversesacle.com/feed.json><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel=stylesheet href=/css/app.css><meta name=description content=计算机基础><link rel=canonical href=https://www.reversesacle.com/computer-science/computer-basic/network/nwpart3/ ><title>计算机网络-第三部分 - 计算机网络 - 计算机基础 - 计算机科学 | ReverseSacle-Blog</title><meta name=generator content="Hexo 6.3.0"></head><body itemscope itemtype=http://schema.org/WebPage><div id=loading><div class=dotloader><div class=dot></div><div class=dot></div><div class=dot></div><div class=dot></div><div class=dot></div></div></div><div id=container><header id=header itemscope itemtype=http://schema.org/WPHeader><div class=inner><div id=brand><div class=pjax><h1 itemprop="name headline">计算机网络-第三部分</h1><div class=meta><span class=item title="创建时间：2023-07-26 20:35:06"><span class=icon><i class="ic i-calendar"></i></span> <span class=text>发表于</span> <time itemprop="dateCreated datePublished" datetime=2023-07-26T20:35:06+08:00>2023-07-26</time></span><span class=item title=本文字数><span class=icon><i class="ic i-pen"></i></span> <span class=text>本文字数</span> <span>36k</span> <span class=text>字</span></span><span class=item title=阅读时长><span class=icon><i class="ic i-clock"></i></span> <span class=text>阅读时长</span> <span>42 分钟</span></span></div></div></div><nav id=nav><div class=inner><div class=toggle><div class=lines role=navigation aria-label=切换导航栏><span class=line></span><span class=line></span><span class=line></span></div></div><ul class=menu><li class="item title"><a href=/ rel=start>ReverseSacle-Blog</a></li></ul><ul class=right><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id=imgs class=pjax><ul><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg21.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg6.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg10.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg4.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg12.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg18.webp></li></ul></div></header><div id=waves><svg class=waves xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink viewBox="0 24 150 28" preserveAspectRatio=none shape-rendering=auto><defs><path id=gentle-wave d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352z"/></defs><g class=parallax><use xlink:href=#gentle-wave x=48 y=0 /><use xlink:href=#gentle-wave x=48 y=3 /><use xlink:href=#gentle-wave x=48 y=5 /><use xlink:href=#gentle-wave x=48 y=7 /></g></svg></div><main><div class=inner><div id=main class=pjax><div class="article wrap"><div class=breadcrumb itemscope itemtype=https://schema.org/BreadcrumbList><i class="ic i-home"></i> <span><a href=/ >首页</a></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/ itemprop=item rel=index title="分类于 计算机科学"><span itemprop=name>计算机科学</span></a><meta itemprop=position content=1></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/computer-basic/ itemprop=item rel=index title="分类于 计算机基础"><span itemprop=name>计算机基础</span></a><meta itemprop=position content=2></span><i class="ic i-angle-right"></i> <span class=current itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/computer-basic/computer-network/ itemprop=item rel=index title="分类于 计算机网络"><span itemprop=name>计算机网络</span></a><meta itemprop=position content=3></span></div><article itemscope itemtype=http://schema.org/Article class="post block" lang=zh-CN><link itemprop=mainEntityOfPage href=https://www.reversesacle.com/computer-science/computer-basic/network/nwpart3/ ><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content=/images/avatar.webp><meta itemprop=name content=ReverseSacle><meta itemprop=description content="所见即所得，所思即所行, 知识书库 & 学习点滴"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content=逆转天平></span><div class="body md" itemprop=articleBody><h2 id=运输层传输层transport-layer><a class=anchor href=#运输层传输层transport-layer>#</a> 运输层/传输层(Transport layer)</h2><h3 id=概述><a class=anchor href=#概述>#</a> 概述</h3><p>运输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。<strong>通用的</strong> - 意思是并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p><ul><li>物理层，数据链路层和网络层共同解决了主机通过异构网络互联起来面临的问题，实现了主机到主机的通信</li><li>实际计算机网络中进行通信的<strong>真正实体</strong>是位于通信两端主机中的<strong>进程(AP)</strong></li><li>运输层的任务 - 为运行在不同主机上的应用进程提供直接的通信服务</li><li>运输层协议也称为<strong>端到端协议</strong>(即应用进程到应用进程)</li><li>因特网的运输层为应用层提供了两种协议<ul><li>面向连接的TCP</li><li>无连接的UDP</li></ul></li></ul><h3 id=运输层端口复用与分用><a class=anchor href=#运输层端口复用与分用>#</a> ! 运输层端口，复用与分用</h3><ul><li><p>应用进程使用<strong>进程标识符PID</strong>作为标志，不同操作系统使用不同格式的进程标识符，为了使不同操作系统的进程之间能够进行网络通信，就必须使用统一的方法对TCP/IP体系的应用进程进行标识</p></li><li><p>TCP/IP体系的运输层使用<strong>端口号</strong>来区分应用层的不同应用进程</p><ul><li>端口号使用16比特表示，取值范围<code>0 ~ 65535</code><ul><li>熟知端口号(0 ~1023) - IANA将这些端口号指派给TCP/IP体系中最重要的一些应用协议(例如，FTP使用21/20，HTTP使用80，HTTPS使用443，DNS使用53)</li><li>登记端口号(1024 ~ 49151) - 被没有熟知端口号的应用程序使用。使用这类端口号必须在IANA按照规定的手续登记，以防止重复(例如，Mircrosoft RDP 微软远程桌面使用的端口是3389)</li><li>短暂端口号(49152 ~ 65535) - 留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用</li></ul></li><li>端口号只具有本地意义，即端口号只是为了标识本计算机应用层中的各进程，在因特网中，不同计算机中的相同端口号是没有联系的</li></ul></li><li><p>发送方的复用</p><ul><li>UDP复用 - 进程发送的报文在运输层使用UDP协议进行封装，成UDP用户数据报</li><li>TCP复用 - 进程发送的报文在运输层使用TCP协议进行封装，成TCP报文段</li><li>运输层使用端口号来区分进程</li><li>IP复用 - UDP用户数据报和TCP报文段在网络层都需要使用IP协议封装成IP数据报<ul><li>IP数据报首部中，协议字段的值用于表名数据封装的是哪种协议数据单元</li><li><code>6</code> - TCP报文段</li><li><code>17</code> - UDP用户数据报</li></ul></li></ul></li><li><p>接收方的分用</p><ul><li>接收方的网络层收到IP数据报后进行IP分用<ul><li>若IP数据报协议字段为<code>17</code>就把数据载荷部分的UDP用户数据报上交运输层的UDP</li><li>若IP数据报协议字段为<code>6</code>就把数据载荷部分的TCP报文段上交运输层的TCP</li></ul></li><li>运输层对UDP用户数据报进行UDP分用，运输层对TCP报文段进行TCP分用，即根据端口号交付给上层相应的应用进程</li></ul></li><li><p>TCP/IP体系的应用层常用协议所使用的运输层数值端口号</p><ul><li>UDP<ul><li>520 - RIP</li><li>53 - DNS</li><li>69 - TFTP</li><li>161 - SNMP</li><li>67/68 - DHCP</li></ul></li><li>TCP<ul><li>25 - SMTP</li><li>20/21 - FTP</li><li>179 - BGP</li><li>80 - HTTP</li><li>443 - HTTPS</li></ul></li></ul></li><li><p>端口号作用案例(域名请求详情)</p><ul><li>假如有DNS服务器(192.168.0.2)，Web服务器(192.168.0.3)与用户PC(192.168.0.1)通过交换机进行互联并处于同一个以太网中</li><li>假如Web服务器的域名为<code>www.portest.com</code>，DNS服务器中记录有该域名所对应的IP地址</li><li>当在用户PC中使用浏览器并在地址栏输入Web服务器的域名，用户PC中的DNS客户端进程会发送一个DNS查询请求报文，其内容为<code>域名www.portest.com所对应的IP地址是什么?</code>，DNS查询请求报文会使用运输层的UDP协议将其封装成UDP用户数据报<ul><li>该UDP数据报中的源端口会在短暂端口号(49151~65535)中挑选一个未被占用的，用来表示DNS客户端进程，例如49152</li><li>目的端口设置的值为53，这是DNS服务器端进程所使用的熟知端口号</li></ul></li><li>之后，将UDP数据报封装在IP数据报中，通过以太网发送给DNS服务器。DNS服务器收到数据报后，从中解封出UDP用户数据报。UDP首部中的目的端口号为53，这表明应将该UDP数据报的数据载荷部分(即DNS查询请求报文)交付给本服务器中的DNS服务器端进程</li><li>DNS服务器端进程解析DNS查询请求报文的内容并按其要求查到对应的IP地址，之后会给用户PC发送DNS响应报文，其内容为<code>域名www.portest.com所对应的IP地址是192.168.0.3</code>。DNS响应报文会使用UDP协议封装成UDP用户数据报<ul><li>该UDP数据报中的源端口字段的值设置为熟知端口号53，表明这是DNS服务器端进程所发出的UDP用户数据报</li><li>目的字段的值设置为49152，这是之前用户PC中发送DNS查询请求报文的DNS客户端进程所使用的短暂端口号</li></ul></li><li>之后，将UDP用户数据报封装在IP数据报中，通过以太网发送给用户PC，用户PC收到数据报后，从中解封出UDP用户数据报。UDP首部中的目的端口号为49152，这表明应将该UDP数据报的数据载荷部分(即DNS响应报文)交付给用户PC中的DNS客户端进程。</li><li>DNS客户端进程解析DNS响应报文的内容，就可知道自己之前请求的Web服务器的域名所对应的IP地址为<code>192.168.0.3</code></li><li>用户PC中的HTTP客户端进程，向Web服务器发送HTTP请求报文，其内容为<code>首页内容是什么？</code>。HTTP请求报文使用运输层的TCP协议封装成TCP报文段<ul><li>该TCP报文段的源端口字段的值会在短暂端口号(49151~65535)中挑选一个未被占用的，用来表示HTTP客户端进程，例如仍然使用之前的49152</li><li>目的字段的值设置为80，这是HTTP端进程所使用的熟知端口号</li></ul></li><li>之后，将TCP报文段封装在IP数据报中，通过以太网发送给Web服务器，Web服务器收到数据报后，从中解封出TCP报文段。TCP首部中的目的端口号为80，这表明应将该TCP报文段的数据载荷部分(即HTTP请求报文)交付给本服务器中的HTTP服务器端进程。</li><li>HTTP服务器端进程解析HTTP请求报文的内容并按其要求查找首页内容，之后，会给用户PC发送HTTP响应报文，其内容是HTTP客户端所请求的首页内容。HTTP响应报文会使用运输层的TCP协议封装成TCP报文段<ul><li>该TCP报文段首部中的源端口字段的值设置为熟知端口号80，表明这是HTTP服务器端进程所发送的TCP报文段</li><li>目的端口字段的值设置为49152，这是之前用户PC中发送HTTP请求报文的HTTP客户端进程所使用的短暂端口号</li></ul></li><li>之后，将TCP报文段封装在IP数据报中，通过以太网发送给用户PC，用户PC收到该数据报后，从中解封出TCP报文段。TCP首部中的目的端口号为49152，这表明将该TCP报文段的数据载荷部分(即HTTP响应报文)交付给用户PC中的HTTP客户端进程</li><li>HTTP客户端进程解析HTTP响应报文的内容，并在网页浏览器中进行显示</li></ul></li></ul><h3 id=udp和tcp的对比><a class=anchor href=#udp和tcp的对比>#</a> ! UDP和TCP的对比</h3><ul><li><p>用户数据报协议UDP - User Datagram Protocol</p><ul><li>使用UDP协议的通信双方，可以随时发送数据</li><li>UDP支持单播，多播和广播，即UDP支持一对一，一对多和一对全的通信</li><li>UDP对应用进程交下来的报文既不合并也不拆分，而是保留这些报文的边界</li><li>UDP是面向报文的</li><li>UDP适用于实时应用</li></ul></li><li><p>传输控制协议TCP - Transmission Control Protocol</p><ul><li><p>使用TCP协议的通信双方，在进行数据传输之前，必须使用<strong>三报文握手</strong>来建立TCP连接，建立成功后才能进行数据传输。数据传输结束后，必须使用<strong>四报文挥手</strong>来释放TCP连接</p></li><li><p>TCP只支持单播，即一对一的通信</p></li><li><p>TCP会将应用进程交付下来的数据块看成一连串，无结构的字节流</p></li><li><p>TCP不保证接收方应用进程所收到的数据块与发送方应用进程所发出的数据块具有对应大小关系</p></li><li><p>TCP是面向字节流的</p></li><li><p>TCP适用于要求可靠传输的应用(文件传输)</p></li></ul></li></ul><details class=info><summary>TCP与UDP的区别？</summary><div><ul><li><p><strong>是否面向连接</strong> - UDP在传送数据之前不需要先建立连接。而TCP提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接</p></li><li><p><strong>是否是可靠传输</strong> - 远地主机在收到UDP报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达</p></li><li><p><strong>是否有状态</strong> - 这个和上面的是否可靠传输相对应。TCP传输是有状态的，这个有状态说的是TCP会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP需要维持复杂的连接状态表。而UDP是无状态服务，简单来说就是不管发出去之后的事情了</p></li><li><p><strong>传输效率</strong> - 由于使用TCP进行传输的时候多了连接、确认、重传等机制，所以TCP的传输效率要比UDP低很多</p></li><li><p><strong>传输形式</strong> - TCP是面向字节流的，UDP是面向报文的</p></li><li><p><strong>首部开销</strong> - TCP首部开销(20 ～ 60 字节)比UDP首部开销(8 字节)要大</p></li><li><p><strong>是否提供广播或多播服务</strong> - TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多</p></li></ul></div></details><details class=info><summary>什么时候选择TCP，什么时候选UDP？</summary><div><ul><li><p>UDP - 一般用于即时通信，比如，语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大</p></li><li><p>TCP - 用于对传输准确性要求特别高的场景，比如文件传输、发送和接收邮件、远程登录等等</p></li></ul></div></details><details class=info><summary>使用TCP的协议有哪些？使用UDP的协议有哪些？</summary><div><p><strong>运行于TCP协议之上的协议</strong></p><ul><li>HTTP(HTTP/3.0之前)/HTTPS协议</li><li>FTP协议</li><li>SMTP协议</li><li>POP3/IMAP协议</li><li>Telnet协议</li><li>SSH协议</li></ul><p><strong>运行于UDP协议之上的协议</strong></p><ul><li>DHCP协议</li><li>DNS</li></ul></div></details><details class=info><summary>TCP协议的主要特点有哪些？</summary><div><ul><li><p>TCP是面向连接的运输层协议</p></li><li><p>每一条TCP连接只能有两个端点，只能是点对点、一对一的</p></li><li><p>此处的端点是指套接字(socket)或插口，而根据RFC 793的定义，端口号拼接到IP地址即构成套接字</p></li><li><p>TCP提供全双工通信，连接的两端都可以临时存放双向通信的数据</p></li><li><p>TCP提供可靠交付的服务，传送的数据保证无差错、不丢失、不重复，并且按序到达</p></li><li><p>TCP面向字节流，将应用程序交下来的数据仅看成是一连串无结构的字节流，写入缓存后根据对方的窗口值和当前网络拥塞的程度来决定一个报文段应该包含多少个字节</p></li></ul></div></details><details class=info><summary>UDP协议的主要特点有哪些？</summary><div><ul><li><p>UDP是无连接的运输层协议</p></li><li><p>UDP支持一对一、一对多、多对一和多对多的交互通信</p></li><li><p>UDP使用尽最大努力交付，即不提供可靠交付的服务</p></li><li><p>UDP面向报文，将应用程序交下来的数据，既不合并也不拆分，保留报文的边界，添加首部后就向下交付到IP层；因此，应用程序必须选择合适大小的报文</p></li><li><p>UDP的首部开销较小，只有8个字节，相比于TCP的首部有至少20个字节</p></li></ul></div></details><details class=info><summary>UDP报文段的首部格式是什么？</summary><div><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/network/part3/17.webp alt=""></p><p>各字段的意义如下</p><ul><li><p>源端口 - 在需要对方回信时选用</p></li><li><p>目的端口 - 在终点交付报文时使用</p></li><li><p>长度 - UDP用户数据报的长度</p></li><li><p>检验和 - 检测UDP用户数据报在传输中是否有错，有错则丢弃</p></li></ul></div></details><details class=info><summary>UDP如何计算检验和？</summary><div><ul><li>在计算检验和时，需要在UDP用户数据报之前增加12个字节的伪首部，不向下传送也不向上递交，仅用于计算校验和</li><li>在发送方，把全零放入检验和字段，再把伪首部和UDP用户数据报看成是由许多16位字，使用全零补齐字节后，按照二进制反码计算这些16位字的和，将此和的二进制反码写入校验和字段，然后发送</li><li>在接收方，把伪首部、收到的UDP用户数据报以及可能的补齐字节后，按照二进制反码求这些16位字的和，无差错时其结果应为全1，否则出现差错</li></ul></div></details><details class=info><summary>TCP的发送缓存和接收缓存分别用于存放什么？</summary><div><p>发送缓存用于存放</p><ul><li>发送应用程序传送给发送方TCP准备发送的数据</li><li>已发送出但尚未收到确认的数据</li></ul><p>接收缓存用于存放</p><ul><li>按序到达的但尚未被接收应用程序读取的数据</li><li>未按序到达的数据</li></ul></div></details><h3 id=tcp流量控制><a class=anchor href=#tcp流量控制>#</a> ! TCP流量控制</h3><ul><li>流量控制(flow control) - 让发送方的发送速率不要太快，要让接收方来得及接收</li><li>利用滑动窗口机制可在TCP连接上实现对发送方的流量控制<ul><li>TCP接收方利用自己的接收窗口的大小来限制发送方发送窗口的大小</li><li>TCP发送方收到接收方的零窗口通知后，应启动持续计时器。持续计时器超时后，向接收方发送零窗口探测报文</li></ul></li><li><span class=exturl data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWM0NDExZDdqYj90PTQ0LjImYW1wO3A9NjA=">→滑动窗口演示</span></li></ul><details class=info><summary>TCP如何实现流量控制？</summary><div><p>TCP通过滑动窗口实现流量控制，即发送方的发送窗口不能超过接收方给出的接收窗口的数值，使得发送方的发送速率不要太快，要让接收方来得及接收。</p><p>但是出现的问题：接收方向发送方发送了零窗口的报文段后不久，接收方的接收缓存又有了一些存储空间，于是向发送方返回非零窗口的报文段，但这个报文段在传送过程中丢失了，双方都在等待，形成死锁，如何解决？</p><p>想要解决这个问题，可以：设置一个持续计时器，发送方只要收到零窗口通知，就启动持续计时器；若持续计时器设置的时间到期，就发送一个零窗口探测的报文段，仅携带1字节的数据，而接收方就在确认这个探测报文段时给出了现在的窗口值；如果此时窗口依然是零，那么发送方重置持续计时器。</p></div></details><h3 id=tcp拥塞控制><a class=anchor href=#tcp拥塞控制>#</a> ! TCP拥塞控制</h3><ul><li>拥塞(congestion) - 在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏</li><li>若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降</li></ul><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/network/part3/1.webp alt=""></p><ul><li><p>TCP的拥塞控制方法</p><ul><li><p>慢开始(slow-start)</p></li><li><p>拥塞避免(congestion avoidance)</p></li><li><p>快重传(fast retransmit)</p></li><li><p>快恢复(fast recovery)</p></li></ul></li><li><p><a target=_blank rel=noopener href="https://www.bilibili.com/video/BV1c4411d7jb?t=177.4&amp;p=61"><strong>→</strong>TCP的拥塞控制方法演示</a></p></li></ul><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/network/part3/2.webp alt=""></p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/network/part3/19.webp alt=""></p><p>注意，cwnd为拥塞窗口大小，ssthresh为慢开始门限；如果收到3个重复的ACK，说明此时发生网络丢包，而不是网络堵塞，应当立即进行重传，即快重传，但是不需要启动慢开始，而是执行快恢复算法。</p><details class=info><summary>TCP如何实现拥塞控制？</summary><div><p>TCP进行拥塞控制的算法共有四种：慢开始、拥塞避免、快重传、快恢复。</p><p>发送方维持拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便发送更多的分组，从而提高网络利用率；但是只要网络出现拥塞或可能出现拥塞，则必须把拥塞窗口减小，以便缓解网络拥塞。</p><p>发送方判断网络拥塞的依据是：出现了超时。</p></div></details><h3 id=tcp超时重传时间的选择><a class=anchor href=#tcp超时重传时间的选择>#</a> ! TCP超时重传时间的选择</h3><ul><li>不能直接适用某次测量得到的RTT样本来计算超时重传时间RTO</li><li>利用每次测量得到的RTT样本，计算加权平均往返时间<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding=application/x-tex>RTT_s</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.83333em;vertical-align:-.15em></span><span class="mord mathnormal" style=margin-right:.00773em>R</span><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=mord><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.151392em><span style=top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span>(又称为平滑的往返时间)<ul><li><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub><mo>=</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mn>1</mn></msub></mstyle></mrow><annotation encoding=application/x-tex>\small RTT_s = RTT_1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.749997em;vertical-align:-.135em></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.00773em>R</span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.13889em>T</span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.13703999999999997em><span style=top:-2.45em;margin-left:-.13889em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mrel sizing reset-size6 size5">=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.749997em;vertical-align:-.135em></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.00773em>R</span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.13889em>T</span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.2796266666666667em><span style=top:-2.45em;margin-left:-.13889em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span>，新的<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mstyle></mrow><annotation encoding=application/x-tex>\small RTT_s</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.749997em;vertical-align:-.135em></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.00773em>R</span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.13889em>T</span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.13703999999999997em><span style=top:-2.45em;margin-left:-.13889em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span> = (1 - α) x 旧的<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mstyle></mrow><annotation encoding=application/x-tex>\small RTT_s</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.749997em;vertical-align:-.135em></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.00773em>R</span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.13889em>T</span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.13703999999999997em><span style=top:-2.45em;margin-left:-.13889em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span> + α x 新的RTT样本</li><li>在上式中，0 ≤ α ＜ 1<ul><li>若α很接近0，则新的RTT样本对<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding=application/x-tex>RTT_s</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.83333em;vertical-align:-.15em></span><span class="mord mathnormal" style=margin-right:.00773em>R</span><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=mord><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.151392em><span style=top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span>的影响不大</li><li>若α很接近1，则新的RTT样本对<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding=application/x-tex>RTT_s</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.83333em;vertical-align:-.15em></span><span class="mord mathnormal" style=margin-right:.00773em>R</span><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=mord><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.151392em><span style=top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span>的影响较大</li></ul></li><li>已成为建议标准的RFC6298推荐的α值为<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mfrac><mn>1</mn><mn>8</mn></mfrac></mstyle></mrow><annotation encoding=application/x-tex>\small \frac{1}{8}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1.051764em;vertical-align:-.3105em></span><span class="mord sizing reset-size6 size5"><span class="mopen nulldelimiter sizing reset-size5 size6"></span><span class=mfrac><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.8236266666666667em><span style=top:-2.6550000000000002em><span class=pstrut style=height:3em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style=top:-3.23em><span class=pstrut style=height:3em></span><span class=frac-line style=border-bottom-width:.04em></span></span><span style=top:-3.394em><span class=pstrut style=height:3em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.345em><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size5 size6"></span></span></span></span></span>，即<code>0.125</code></li></ul></li><li>利用这种方法得出的加权平均往返时间<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mstyle></mrow><annotation encoding=application/x-tex>\small RTT_s</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.749997em;vertical-align:-.135em></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.00773em>R</span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.13889em>T</span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.13703999999999997em><span style=top:-2.45em;margin-left:-.13889em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span>就比测量出RTT值更加平滑</li><li>超时重传时间RTO应略大于<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mstyle></mrow><annotation encoding=application/x-tex>\small RTT_s</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.749997em;vertical-align:-.135em></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.00773em>R</span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.13889em>T</span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.13703999999999997em><span style=top:-2.45em;margin-left:-.13889em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span> (加权平均往返时间)</li><li>RFC6298建议使用下面的方式计算超时重传时间RTO<ul><li>RTO =<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mstyle></mrow><annotation encoding=application/x-tex>\small RTT_s</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.749997em;vertical-align:-.135em></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.00773em>R</span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.13889em>T</span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.13703999999999997em><span style=top:-2.45em;margin-left:-.13889em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span> + 4 x<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub></mstyle></mrow><annotation encoding=application/x-tex>\small RTT_D</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.749997em;vertical-align:-.135em></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.00773em>R</span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.13889em>T</span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.30555333333333334em><span style=top:-2.45em;margin-left:-.13889em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mathnormal mtight" style=margin-right:.02778em>D</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span>，其中<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub></mstyle></mrow><annotation encoding=application/x-tex>\small RTT_D</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.749997em;vertical-align:-.135em></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.00773em>R</span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.13889em>T</span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.30555333333333334em><span style=top:-2.45em;margin-left:-.13889em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mathnormal mtight" style=margin-right:.02778em>D</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span>的计算方法为<ul><li><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>R</mi><mi>T</mi><msub><mi>T</mi><mrow><mi>D</mi><mn>1</mn></mrow></msub></mstyle></mrow><annotation encoding=application/x-tex>\small RTT_{D1}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.749997em;vertical-align:-.135em></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.00773em>R</span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.13889em>T</span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.30555333333333334em><span style=top:-2.45em;margin-left:-.13889em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style=margin-right:.02778em>D</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span> =<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>R</mi><mi>T</mi><msub><mi>T</mi><mn>1</mn></msub></mstyle></mrow><annotation encoding=application/x-tex>\small RTT_1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.749997em;vertical-align:-.135em></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.00773em>R</span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.13889em>T</span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.2796266666666667em><span style=top:-2.45em;margin-left:-.13889em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span> ÷ 2</li><li>新的<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub></mstyle></mrow><annotation encoding=application/x-tex>\small RTT_D</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.749997em;vertical-align:-.135em></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.00773em>R</span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.13889em>T</span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.30555333333333334em><span style=top:-2.45em;margin-left:-.13889em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mathnormal mtight" style=margin-right:.02778em>D</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span> = (1 - β) x 旧的<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub></mstyle></mrow><annotation encoding=application/x-tex>\small RTT_D</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.749997em;vertical-align:-.135em></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.00773em>R</span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.13889em>T</span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.30555333333333334em><span style=top:-2.45em;margin-left:-.13889em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mathnormal mtight" style=margin-right:.02778em>D</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span> ＋ β x |<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mstyle></mrow><annotation encoding=application/x-tex>\small RTT_s</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.749997em;vertical-align:-.135em></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.00773em>R</span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.13889em>T</span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.13703999999999997em><span style=top:-2.45em;margin-left:-.13889em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span> - 新的RTT样本|</li><li>0 ≤ β ＜ 1</li></ul></li><li>已成为建议标准的RFC6298推荐的α值为<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mfrac><mn>1</mn><mn>4</mn></mfrac></mstyle></mrow><annotation encoding=application/x-tex>\small \frac{1}{4}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1.051764em;vertical-align:-.3105em></span><span class="mord sizing reset-size6 size5"><span class="mopen nulldelimiter sizing reset-size5 size6"></span><span class=mfrac><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.8236266666666667em><span style=top:-2.6550000000000002em><span class=pstrut style=height:3em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style=top:-3.23em><span class=pstrut style=height:3em></span><span class=frac-line style=border-bottom-width:.04em></span></span><span style=top:-3.394em><span class=pstrut style=height:3em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.345em><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size5 size6"></span></span></span></span></span>，即<code>0.25</code></li></ul></li><li>针对出现超时重传时无法测准往返时间RTT的问题，Karn提出了一个算法<ul><li>在计算加权平均往返时间<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mstyle></mrow><annotation encoding=application/x-tex>\small RTT_s</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.749997em;vertical-align:-.135em></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.00773em>R</span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.13889em>T</span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.13703999999999997em><span style=top:-2.45em;margin-left:-.13889em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span>时，只要报文段重传了，就不采用其往返时间RTT样本。也就是出现重传时，不重新计算<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mstyle></mrow><annotation encoding=application/x-tex>\small RTT_s</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.749997em;vertical-align:-.135em></span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.00773em>R</span><span class="mord mathnormal sizing reset-size6 size5" style=margin-right:.13889em>T</span><span class="mord sizing reset-size6 size5"><span class="mord mathnormal" style=margin-right:.13889em>T</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.13703999999999997em><span style=top:-2.45em;margin-left:-.13889em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span>，进而超时重传时间RTO也不会重新计算</li></ul></li><li>由于Karn算法在一定情况下会出现超时重传时间无法更新，为此要对Karn算法进行修正，方法为<ul><li>报文段每重传一次，就把超时重传时间RTO增大一些(典型做法就是将新RTO的值取为旧RTO值的2倍)</li></ul></li></ul><h3 id=tcp可靠传输的实现><a class=anchor href=#tcp可靠传输的实现>#</a> TCP可靠传输的实现</h3><ul><li>TCP基于以字节为单位的滑动窗口来实现可靠传输<ul><li>发送方在未收到接收方的确认时，可将发送窗口内还未发送的数据全部发送出去</li><li>接收方只接收序号落入发送窗口内的数据</li></ul></li><li>虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，发送方的发送窗口并不总是和接收方的接收窗口一样大<ul><li>网络传送窗口值需要经历一定的时间滞后，并且这个时间还是不确定的</li><li>发送方还可能根据网络当前时的拥塞情况适当减小自己的发送窗口尺寸</li></ul></li><li>对于不按序到达的数据的处理，TCP并无明确规定<ul><li>如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样对网络资源的利用不利，因为发送方会重复传送较多的数据</li><li>TCP通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程</li></ul></li><li>TCP要求接收双方必须有累积确认和捎带确认机制，这样可以减少传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息捎带上<ul><li>接收方不应过分推迟发送确认，否则会导致发送方不必要的超时重传，这反而浪费了网络资源<ul><li>(RFC 1122)TCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认</li></ul></li><li>捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据</li></ul></li><li>TCP的通信是全双工通信，通信中的每一方都在发送和接收报文段，因此，每一方都有自己的发送窗口和接收窗口</li><li><span class=exturl data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWM0NDExZDdqYj90PTE4LjUmYW1wO3A9NjM=">→以字节为单位的滑动窗口演示</span></li></ul><h3 id=tcp的运输连接管理><a class=anchor href=#tcp的运输连接管理>#</a> ! TCP的运输连接管理</h3><h4 id=tcp的连接建立三报文握手><a class=anchor href=#tcp的连接建立三报文握手>#</a> TCP的连接建立(三报文握手)</h4><ul><li>TCP的建立要解决以下三个问题<ul><li>使TCP双方能够感知对方的存在</li><li>使TCP双方能够协商一些参数</li><li>使TCP双方能够对运输实体资源进行分配</li></ul></li><li>TCP使用<strong>三报文握手</strong>建立连接<ul><li>两台要基于TCP进行通信的主机，其中一台主机中的某个应用进程<strong>主动</strong>发起TCP连接建立，称为<strong>TCP客户</strong>；另一台主机中<strong>被动</strong>等待TCP连接建立的应用进程，称为<strong>TCP服务器</strong></li><li>将TCP建立连接的过程比喻为<strong>握手</strong>，握手需要在TCP客户和服务器之间交换三个TCP报文段</li><li>最初，两端的TCP进程都处于关闭状态</li><li>(<strong>TCP服务器</strong>)首先，TCP服务器进程创建传输控制块，用来存储TCP连接中的一些重要信息<ul><li>TCP连接表</li><li>指向发送和接收缓存的指针</li><li>指向重传队列的指针</li><li>当前的发送和接收序列号等</li></ul></li><li>之后，就准备接受TCP客户进程的连接请求。此时，TCP服务器进程就进入监听状态，等待TCP客户进程的连接请求<ul><li>TCP服务器是被动等待来自TCP客户进程的连接请求，而不是主动发起，因此称为被动打开连接</li></ul></li><li>(<strong>TCP客户进程</strong>)首先，TCP客户进程也是先创建传输控制块，然后在打算建立TCP连接时，向TCP服务器进程发送TCP连接请求报文段并进入同步已发送状态<ul><li>SYN(Synchronize) - 同步</li><li>TCP连接请求报文段首部中的同步位SYN被设置为1，表明这是一个TCP连接请求报文段</li><li>序号seq被设置了一个初始值x，作为TCP客户进程所选择的初始序号</li><li>TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号</li><li>由于TCP连接建立是由TCP客户主动发起的，因此称为主动打开连接</li></ul></li><li>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段并进入同步已发送状态<ul><li>ACK(Acknowledgment) - 确认</li><li>SYN-ACK - 同步应答</li><li>该报文段首部中的同步位SYN和确认位ACK都设置为1，表明这是一个TCP连接请求确认报文段</li><li>序号seq被设置了一个初始值，作为TCP服务器进程所选择的初始序号</li><li>确认号字段ack的值被设置成了x+1，这是对TCP客户进程所选择的初始序号的确认</li><li>这个报文段也不能携带数据(SYN=1)</li></ul></li><li>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段并进入连接已建立状态<ul><li>该报文段首部中的确认位ACK被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，并且不携带数据</li><li>TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号</li><li>确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认</li></ul></li><li>TCP服务器进程收到该确认报文段后也进入连接已建立状态</li><li>最后，TCP双方都进入了连接已建立状态，可以基于已建立好的TCP连接进行可靠的数据传输了</li></ul></li></ul><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/network/part3/3.webp alt=""></p><p>SYN同步序列编号(Synchronize Sequence Numbers)是TCP/IP建立连接时使用的握手信号。</p><details class=info><summary>为什么要三次握手？</summary><div><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p></div></details><details class=info><summary>TCP客户进程最后还要发送一个普通的TCP确认报文段，是否多余？(是否可以简化为两报文握手)</summary><div><p><strong>不同的问法 - 第2次握手传回了ACK，为什么还要传回SYN？</strong></p><p>不多余，这是为了防止已失效的连接请求报文段突然又传送到了TCP服务器而导致错误。</p></div></details><h4 id=tcp连接的释放四报文挥手><a class=anchor href=#tcp连接的释放四报文挥手>#</a> TCP连接的释放(四报文挥手)</h4><p><strong>TCP通过四报文挥手来释放连接</strong></p><ul><li><p>两台已基于TCP进行通信的主机，数据传输结束后，TCP通信双方都可以释放连接</p></li><li><p>假设使用TCP客户进程的应用进程通知其主动关闭TCP连接</p></li><li><p>TCP客户进程会发送TCP连接释放报文段并进入终止等待1状态</p><ul><li>FIN(Finish) - 终止</li><li>该报文段首部中的终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li><li>序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1</li><li>TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</li><li>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的数据的最后一个字节的序号加1</li></ul></li><li><p>TCP服务器收到TCP连接释放报文后，会发送一个普通的TCP确认报文段并进入关闭等待状态</p><ul><li>该报文段首部中的确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号seq字段的值设置为v，它等于TCP服务器之前已传送数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配</li><li>确认号字段的值设置为u+1，这是对TCP连接释放报文段的确认</li></ul></li><li><p>这时，TCP服务进程通知高层应用进程TCP客户进程要断开与字节的TCP连接。此时，从TCP客户进程到TCP服务器进程这个方向的连接就释放了</p></li><li><p>这时的TCP连接属于半关闭状态，也就是TCP客户进程已经没有数据要发送了，但TCP服务器进程如果还有数据要发送，TCP客户进程仍要接收，也就是说从TCP服务器进程到TCP客户进程这个方向的连接并未关闭，这个状态可能会持续一段时间</p></li><li><p>TCP客户进程收到TCP确认报文段后就进入终止等待2状态，等待TCP服务器进程发出TCP连接释放报文段。若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接。</p><ul><li>由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器对TCP连接的释放称为被动关闭连接</li></ul></li><li><p>TCP服务器进程向TCP客户发送TCP连接释放报文段并进入最后确认状态</p><ul><li>该报文段首部中的终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li><li>假定序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送了一些数据</li><li>确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认</li></ul></li><li><p>TCP客户进程收到TCP连接释放报文后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态</p><ul><li>该报文段首部中的确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号</li><li>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认</li></ul></li><li><p>TCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要经过2MSL后才能进入关闭状态。也就是说TCP客户进程进入时间等待状态后，还要经过4分钟才能进入关闭状态</p><ul><li>MSL - 最长报文段寿命，RFC文档中建议为2分钟</li><li>TCP允许不同的实现可更具具体情况使用更小的MSL值</li></ul></li><li><p>那么，TCP客户进程在发送完最后一个确认报文段后，为什么不直接进入关闭状态，而是要进入时间等待状态，2MSL后才进入关闭状态？</p><ul><li>TCP服务器发送TCP连接释放报文段后进入最后确认状态，TCP客户进程收到该报文段后，发送普通的TCP确认报文段并进入关闭状态而不是等待状态</li><li>然而，该TCP确认报文段丢失了，这必然会造成TCP服务器进程对之前所发送的TCP连接释放报文段的超时重传并仍处于最后的确认状态</li><li>重传的TCP连接释放报文段到达TCP客户进程，由于TCP客户进程处于关闭状态，因此不理睬该报文段，这必然会造成TCP服务器进程反复重传TCP连接释放报文段，并一直处于最后确认状态而无法进入关闭状态</li><li>因此，时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态。另外，TCP客户进程在发送完最后一个TCP确认报文段后，再经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接的报文段</li></ul></li></ul><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/network/part3/4.webp alt=""></p><p>只要四次挥手没有结束，客户端和服务端就可以继续传输数据。</p><p><strong>MSL(Maximum Segment Lifetime)</strong> - 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p><p><strong>TIME_WAIT</strong></p><p><code>TIME_WAIT</code>状态发生在四次挥手过程的最后阶段。当一方(如客户端)收到另一方发送的具有FIN标志的TCP包，它会发送一个带有ACK标志的TCP包作为确认，并进入<code>TIME_WAIT</code>状态。之所以存在这个状态，主要有以下原因</p><ul><li><p>确保对方收到最后一个带有ACK标志的TCP包。如果对方没有收到这个包，它会重新发送FIN包。在<code>TIME_WAIT</code>状态期间，如果收到重发的FIN包，可以再次发送ACK包进行确认</p></li><li><p>避免老的数据包干扰新连接。由于网络延迟等原因，已结束连接的数据包可能在网络上滞留一段时间。<code>TIME_WAIT</code>状态能够阻止新连接在短时间内使用相同的源和目标IP地址及端口号，从而避免旧数据包干扰新连接</p></li></ul><p><code>TIME_WAIT</code>状态默认持续2倍Maximum Segment Lifetime(MSL)，通常为1-4分钟。经过这段时间后，连接被彻底关闭。</p><p><strong>CLOSE_WAIT</strong></p><p><code>CLOSE_WAIT</code>状态出现在接收到对方发送的带有FIN标志的TCP包时。当一方(如服务器)收到请求关闭连接的FIN包后，它会发送一个带有ACK标志的TCP包进行确认，并进入<code>CLOSE_WAIT</code>状态。然后，这一方需要等待应用程序关闭套接字，之后才能发送自己的FIN包并进入<code>LAST_ACK</code>状态。</p><p>如果某个连接长时间停留在<code>CLOSE_WAIT</code>状态，通常表示应用程序没有正确关闭socket。这可能导致资源泄漏和性能问题。为解决这个问题，需要检查应用程序逻辑确保套接字被正确关闭。</p><p><strong>滑动窗口</strong></p><p>滑动窗口是TCP和其他网络协议中用于控制数据传输的一种技术。它的主要目的是防止发送方发送过多数据，从而导致接收方无法处理。</p><p>在TCP中，滑动窗口由发送窗口和接收窗口组成，它们分别代表了发送方可以发出的数据量和接收方可以接受的数据量。每次数据传输后，窗口会滑动以适应新的数据流。滑动窗口的大小根据网络拥塞情况、接收方处理能力等因素动态调整，从而实现TCP的流量控制和拥塞控制。</p><p><strong>超时重传</strong></p><p>超时重传是TCP中用于保证数据可靠传输的一种机制。当发送方发出一个数据包后，它会启动一个定时器等待接收方的确认。如果在定时器超时之前接收到确认，则表示数据包已成功传送；否则发送方会认为该数据包在网络中丢失，需要进行重传。</p><p>超时重传能够确保即使在网络环境不理想的情况下，数据也能最终被接收到。这是TCP提供可靠传输服务的关键机制之一。然而，由于超时重传可能增加网络拥塞，所以TCP还配备了拥塞控制机制来避免过度重传。</p><p>需要注意的是，TCP的超时时间并非固定，而是根据Round-Trip Time(往返时间)动态调整。这样可以更好地适应不同的网络条件，提高效率。</p><details class=info><summary>为什么要四次挥手？</summary><div><p>TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p></div></details><details class=info><summary>为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手？</summary><div><p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。</p></div></details><details class=info><summary>如果第二次挥手时服务器的ACK没有送达客户端，会怎样？</summary><div><p>客户端没有收到ACK确认，会重新发送FIN请求。</p></div></details><details class=info><summary>为什么第四次挥手客户端需要等待2MSL(报文段最长寿命)时间后才进入CLOSED状态？</summary><div><p>第四次挥手时，客户端发送给服务器的ACK有可能丢失，如果服务端因为某些原因而没有收到ACK的话，服务端就会重发FIN，如果客户端在2MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。</p></div></details><details class=info><summary>TCP接收方为什么必须有累计确认的功能？</summary><div><p>累计确认的功能可以减少传输开销，接收方可以在合适的时候发送确认，接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网络资源；TCP标准规定，确认推迟的时间不应超过0.5秒，若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认。</p></div></details><h4 id=tcp保活计时器><a class=anchor href=#tcp保活计时器>#</a> TCP保活计时器</h4><ul><li>TCP双方已经建立的连接，之后TCP客户进程所在的主机突然出现了故障。TCP服务器进程以后就不能再收到TCP客户进程发来的数据。因此，应当有措施使TCP服务器进程不要再白白等待下去，方法就是使用保活计时器</li><li>TCP服务器进程每收到一次TCP客户进程的数据，就重新设置并启动保活计时器(2小时定时)</li><li>若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器进程就向TCP客户进程发送一个探测报文段，以后则每隔75秒发送一次。若一连发送了10各探测报文后仍无TCP客户进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，接着就关闭这个连接</li></ul><h3 id=tcp报文段的首部格式><a class=anchor href=#tcp报文段的首部格式>#</a> ! TCP报文段的首部格式</h3><p>为了实现可靠传输，TCP采用了面向字节流的方式。</p><p>TCP在发送数据时，是从发送缓存取出一部分或全部字节并给其添加一个首部使之成为TCP报文段后进行发送。</p><ul><li>一个TCP报文段由首部和数据载荷两部分构成</li><li>TCP的全部功能都体现在它首部中各字段的作用</li></ul><p><strong>首部格式</strong></p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/network/part3/5.webp alt=""></p><ul><li><p>源端口 - 占16比特，写入源端口号，用来标识发送该TCP报文段的应用进程</p></li><li><p>目的端口 - 占16比特，写入目的端口号，用来标识接收该TCP报文段的应用进程</p></li><li><p>序号</p><ul><li>占32比特，取值范围[0,<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><msup><mn>2</mn><mn>32</mn></msup></mstyle></mrow><annotation encoding=application/x-tex>\small 2^{32}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.713364em;vertical-align:0></span><span class="mord sizing reset-size6 size5"><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.7926266666666666em><span style=top:-2.963em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> - 1]，序号增加到最后一个，之后下一个序号就又回到0</li><li>用于指出本TCP报文段数据载荷的第一个字节的序号</li></ul></li><li><p>确认号</p><ul><li>占32比特，取值范围[0,<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><msup><mn>2</mn><mn>32</mn></msup></mstyle></mrow><annotation encoding=application/x-tex>\small 2^{32}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.713364em;vertical-align:0></span><span class="mord sizing reset-size6 size5"><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.7926266666666666em><span style=top:-2.963em;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> - 1]，序号增加到最后一个，之后下一个序号就又回到0</li><li>用于指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认</li><li>若确认号等于n，则表明到序号n-1为止的所有数据都已正确接收，期望接收序号为n的数据</li></ul></li><li><p>确认标志位ACK</p><ul><li>取值为1时确认号字段才有效</li><li>取值为0时确认号字段无效</li><li>TCP规定，在连接建立后所有传送的TCP报文段都必须把ACK置1</li></ul></li><li><p>数据偏移</p><ul><li>占4比特，并以4字节为单位</li><li>用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远</li><li>这个字节实际上是指出了TCP报文段的首部长度<ul><li>首部固定长度为20字节，因此数据偏移字段的最小值为<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mo stretchy=false>(</mo><mn>0101</mn><msub><mo stretchy=false>)</mo><mn>2</mn></msub></mstyle></mrow><annotation encoding=application/x-tex>\small (0101)_2</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.9em;vertical-align:-.225em></span><span class="mopen sizing reset-size6 size5">(</span><span class="mord sizing reset-size6 size5">0</span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5">0</span><span class="mord sizing reset-size6 size5">1</span><span class="mclose sizing reset-size6 size5"><span class=mclose>)</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.2796266666666667em><span style=top:-2.45em;margin-left:0;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span></li><li>首部最大长度为60字节，因此数据偏移字段的最大值为<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mstyle mathsize=0.9em><mo stretchy=false>(</mo><mn>1111</mn><msub><mo stretchy=false>)</mo><mn>2</mn></msub></mstyle></mrow><annotation encoding=application/x-tex>\small (1111)_2</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.9em;vertical-align:-.225em></span><span class="mopen sizing reset-size6 size5">(</span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5">1</span><span class="mord sizing reset-size6 size5">1</span><span class="mclose sizing reset-size6 size5"><span class=mclose>)</span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.2796266666666667em><span style=top:-2.45em;margin-left:0;margin-right:.05555555555555556em><span class=pstrut style=height:2.6em></span><span class="sizing reset-size5 size2 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span></li></ul></li></ul></li><li><p>保留 - 占6比特，保留为今后使用，但目前应置为0</p></li><li><p>窗口</p><ul><li>占16比特，以字节为单位。指出发送本报文段的一方的接收窗口</li><li>窗口值作为接收方让发送方设置其发送窗口的依据</li><li>这是以接收放的接收能力来控制发送方的发送能力，称为流量控制</li></ul></li><li><p>校验和</p><ul><li>占16比特，检查范围包括TCP报文段的首部和数据载荷两部分</li><li>在计算校验和时，要在TCP报文段的前面加上12字节的伪首部</li></ul></li><li><p>同步标志位SYN - 在TCP连接建立时用来同步序号</p></li><li><p>终止标志位FIN - 用来释放TCP连接</p></li><li><p>复位标志位RST</p><ul><li>用来复位TCP连接</li><li>当RST等于1时，表明TCP连接出现了异常，必须释放连接，然后再重新建立连接</li><li>RST置1还用来拒绝一个非法的报文段或拒绝打开一个TCP连接</li></ul></li><li><p>推送标志位PSH</p><ul><li>接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等待接收缓存填满后再向上交付</li></ul></li><li><p>紧急标志位URG</p><ul><li>取值为1时紧急指针字段有效</li><li>取值为0时紧急指针字段无效</li></ul></li><li><p>紧急指针</p><ul><li>占16比特</li><li>以字节为单位，用来指明紧急数据的长度</li><li>当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立刻封装到一个TCP报文段中进行发送。紧急指针指出本报文段数据载荷部分包含了多长的紧急数据，紧急数据之后是普通数据</li></ul></li><li><p>选项部分</p><ul><li>增加选项可以增加TCP的功能，有以下选项<ul><li>最大报文段长度MSS选项 - 用于指出TCP报文段数据载荷部分的最大长度</li><li>窗口扩大选项 - 用来扩大窗口，提高吞吐率</li><li>时间戳选项 - 用来计算往返时间RTT和处理序号超范围的情况(又被称为防止序号绕回PAED)</li><li>选择确认选项 - 用来实现选择确认功能</li></ul></li></ul></li><li><p>填充 - 由于选项的长度可变，因此使用填充来确保报文段首部能被4整除</p></li></ul><details class=info><summary>列举所知道的tcp选项？</summary><div><p>TCP选项是TCP首部中的一部分，用来指定一些可选的协议参数或功能。除了常见的大小和头部信息，以下是一些常见的功能性TCP选项</p><ul><li><p><strong>MSS</strong> - 这个选项用于指定TCP数据段的最大长度。它在建立连接时由双方协商确定，以适应网络环境并避免IP包的分片。</p></li><li><p><strong>窗口缩放</strong> - 窗口缩放选项使得TCP可以使用更大的接收窗口，从而提高数据传输效率。它通过指定一个缩放因子，该因子用于将16位的窗口字段左移以得到实际的接收窗口大小</p></li><li><p><strong>时间戳</strong> - 时间戳选项为每个TCP包添加发送和接收的时间信息，用于RTT(往返时延)测量和PAWS(防止旧分片)等功能</p></li><li><p><strong>选择性确认</strong> - SACK选项允许接收方只确认收到的非连续数据段，而不是确认收到的最后一个连续数据段。这样可以减少网络拥塞情况下不必要的重传</p></li><li><p><strong>NOP</strong> - NOP选项没有任何操作，主要用于填充空间，确保其他选项可以在32位边界上对齐</p></li><li><p><strong>结束</strong> - 这个选项表示TCP选项列表的结束，通常用于当选项列表未能填充满整个TCP首部时的填充</p></li></ul></div></details><h2 id=应用层application-layer><a class=anchor href=#应用层application-layer>#</a> 应用层(Application layer)</h2><h3 id=概述-2><a class=anchor href=#概述-2>#</a> 概述</h3><p>应用层位于传输层之上，是计算机网络体系结构的最顶层，是设计和建立计算机网络的最终目的。主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。应用层交互的数据单元称为报文。</p><p>应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如支持Web应用的HTTP协议，支持电子邮件的SMTP协议等等。</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/network/part3/16.webp alt=""></p><details class=info><summary>应用层有哪些常见的协议？</summary><div><ul><li><p><strong>HTTP(Hypertext Transfer Protocol - 超文本传输协议)</strong> - 基于TCP协议，是一种用于传输超文本和多媒体内容的协议，主要是为Web浏览器与Web服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过HTTP请求进行加载的</p></li><li><p><strong>SMTP(Simple Mail Transfer Protocol - 简单邮件发送协议)</strong> - 基于TCP协议，是一种用于发送电子邮件的协议。SMTP协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用POP3或IMAP协议</p></li><li><p><strong>POP3/IMAP(邮件接收协议)</strong> - 基于TCP协议，两者都是负责邮件接收的协议。IMAP协议是比POP3更新的协议，它在功能和性能上都更加强大。IMAP支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持IMAP</p></li><li><p><strong>FTP(File Transfer Protocol - 文件传输协议)</strong> - 基于TCP协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。FTP是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如SFTP</p></li><li><p><strong>Telnet(远程登陆协议)</strong> - 基于TCP协议，用于通过一个终端登陆到其他服务器。Telnet协议的最大缺点之一是所有数据(包括用户名和密码)均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用Telnet，而是使用一种称为SSH的非常安全的网络传输协议的主要原因</p></li><li><p><strong>SSH(Secure Shell Protocol - 安全的网络传输协议)</strong> - 基于TCP协议，通过加密和认证机制实现安全的访问和文件传输等业务</p></li><li><p><strong>RTP(Real-time Transport Protocol - 实时传输协议)</strong> - 通常基于UDP协议，但也支持TCP协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由WebRTC实现</p></li><li><p><strong>DNS(Domain Name System- 域名管理系统)</strong> - 基于UDP协议，用于解决域名和IP地址的映射问题</p></li></ul></div></details><h3 id=客户服务器方式和对等方式><a class=anchor href=#客户服务器方式和对等方式>#</a> 客户/服务器方式和对等方式</h3><p>开发一种新的网络应用首先要考虑的问题是网络应用程序在各端系统上的组织方式和它们之间的关系，目前主流的有以下两种</p><ul><li>客户/服务器(Client/Server，C/S)方式</li><li>对等(Peer-to-Peer，P2P)方式</li></ul><h4 id=客户服务器clientservercs方式><a class=anchor href=#客户服务器clientservercs方式>#</a> ! 客户/服务器(Client/Server,C/S)方式</h4><ul><li><p>客户和服务器是指通信中所涉及的两个应用进程</p></li><li><p>客户/服务器所描述的是进程之间服务和被服务的关系</p></li><li><p>正在运行的客户程序称为客户进程，也可简称为客户，运行客户进程的主机应称为客户计算机，但有时也简称为客户</p></li><li><p>正在运行的服务器程序称为服务器进程，也可简称为服务器，运行服务器进程的主机应称为服务器计算机，但有时也简称为服务器</p></li><li><p>客户是请求方，服务器是服务提供方</p></li><li><p>服务器总是处于运行状态，并等待客户的服务请求，服务器具有固定端口号，而运行服务器的主机也具有固定的IP地址</p></li><li><p>C/S方式是因特网上传统的，同时也是最成熟的方式，很多网络应用采用的都是C/S方式，包括万维网www，电子邮件，文件传输FTP等</p></li><li><p>基于C/S方式的应用服务通常是服务集中型的，即应用服务集中在网络中比客户计算机少得多的服务器计算机上</p><ul><li>由于一台服务器计算机要为多个客户机提供服务，在C/S应用中，常会出现服务器计算机跟不上众多客户机请求的情况</li><li>为此，在C/S应用中，常用计算机群集(或服务器场)构建一个强大的虚拟服务器</li></ul></li></ul><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/network/part3/6.webp alt=""></p><h4 id=对等peer-to-peerp2p方式><a class=anchor href=#对等peer-to-peerp2p方式>#</a> 对等(Peer-to-Peer,P2P)方式</h4><ul><li>在P2P方式中，没有固定的服务请求者和服务提供者，分布在网络边缘各系统中的应用进程是对等的，被称为对等方。对等方相互之间直接通信，每个对等方即是服务的请求者，又是服务的提供者</li><li>基于P2P的应用是服务分散型的，因为服务不是集中在少数几个服务器计算机中，而是分散在大量对等计算机中，这些计算机并不为服务提供商所有，而是为个人控制的桌面计算机和笔记本电脑，它们通常位于住宅，校园或办公室中</li><li>P2P方式的最突出特性之一就是它的可扩展性。因为系统每增加一个对等方，不仅增加的是服务的请求者，同时也增加了服务的提供者，系统性能不会因规模的增大而降低</li><li>P2P方式具有成本上的优势，因为它通常不需要庞大的服务器设施和服务器带宽</li></ul><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/network/part3/7.webp alt=""></p><h3 id=动态主机配置协议dhcp><a class=anchor href=#动态主机配置协议dhcp>#</a> ! 动态主机配置协议DHCP</h3><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/network/part3/8.webp alt=""></p><h4 id=dhcp的工作过程><a class=anchor href=#dhcp的工作过程>#</a> DHCP的工作过程</h4><ul><li>假如网络中有两台DHCP服务器和多台用户主机</li><li>DHCP使用客户/服务器方式，在DHCP服务器上运行DHCP服务器进程，可简称为DHCP服务器</li><li>在用户主机上运行DHCP客户进程，也可简称为DHCP客户</li><li>DHCP是TCP/IP协议体系应用层中的协议，使用运输层的UDP所提供的服务，DHCP报文在运输层会被封装成为UDP用户数据报<ul><li>DHCP服务器使用的UDP端口是67</li><li>DHCP客户使用的UDP端口是68</li><li>这两个端口都是熟知端口</li></ul></li><li>封装有DHCP报文的UDP用户数据报，在网络层会被封装成IP数据报，然后再根据所使用的网络接口，封装成响应的数据链路层的帧进行发送</li><li>DHCP客户与DHCP服务器的交互过程<ul><li>当启用主机的DHCP后，DHCP客户将广播发送DHCP发现报文<ul><li>封装该报文的IP数据报的源IP地址为<code>0.0.0.0</code>，这是因为主机目前还未分配到IP地址，因此使用该地址来代替</li><li>目的IP地址为广播地址<code>255.255.255.255</code></li></ul></li><li>之所以进行广播发送，是因为主机现在并不知道网络中有哪几个DHCP服务器，它们的IP地址各是什么</li><li>由于是广播的数据报，网络中的所有设备都会收到该IP数据报，并对其层层解封，解封出封装有DHCP发现报文的UDP用户数据报<ul><li>对于DHCP客户，其应用层没有监听该UDP用户数据报目的端口67的进程，也就是DHCP服务器进程，因此无法交付DHCP发现报文，只能丢弃</li><li>对于DHCP服务器，其应用层始终运行着DHCP服务器进程，因此会接受该DHCP发现报文并作出响应</li><li>DHCP报文的格式比较复杂，对于DHCP发现报文，只需知道其内部封装有事物ID和DHCP客户端的MAC地址即可</li></ul></li><li>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库，看是否有针对该MAC地址的配置信息。<ul><li>如果有，则使用这些配置信息来构建并发送DHCP提供报文</li><li>如果没有，则采用默认配置信息来构建并发送DHCP提供报文</li></ul></li><li>封装该报文的IP数据报的源IP地址为DHCP服务器IP地址，目的地址为广播地址<ul><li>仍然使用广播地址的原因是主机目前还没有配置IP地址，为了使主机可以收到，只能发送广播</li></ul></li><li>这样一来网络中的所有设备都会收到该IP数据报，并对其层层解封，解封出封装有DHCP提供报文的UDP用户数据报<ul><li>对于DHCP服务器，其应用层没有监听该UDP用户数据报目的端口68的进程，也就是DHCP客户进程，因此无法交付DHCP提供报文，只能将其丢弃</li><li>对于DHCP客户，其应用层运行着DHCP客户进程，因此会接受该DHCP提供报文并作出相应处理，DHCP客户会根据DHCP提供报文中的事物ID来判断该报文是否是自己所请求的报文<ul><li>如果该事物ID与自己之前发送的DHCP发现报文中封装的事物ID相等就表明这是自己所请求的报文，就可以接受该报文，否则就丢弃该报文</li></ul></li></ul></li><li>DHCP提供报文中还封装有配置信息，例如IP地址，子网掩码，地址租期，默认网关，DNS服务器等<ul><li>DHCP服务器从自己的IP地址池中挑选待租用给主机的IP地址时，会使用ARP来确保所选IP地址未被网络中其他主机占用</li></ul></li><li>本例子中，DHCP客户会收到两个DHCP服务器发来的DHCP提供报文，DHCP客户从中选一个，一般来说选择先到的那个，并向所选择的DHCP服务器发送DHCP请求报文<ul><li>封装该报文的IP数据报的源IP地址为<code>0.0.0.0</code>，因为此时的DHCP客户才从多个DHCP服务器中挑选一个作为自己的DHCP服务器，它首先需要征得该服务器的同意，之后才能正式使用该DHCP服务器租用的IP地址</li><li>目的IP地址仍为广播地址，这样做的目的是不用向网络中的每一个DHCP服务器单播发送DHCP请求报文，来告知它们是否请求它们作为自己的DHCP服务器</li></ul></li><li>DHCP请求报文中封装有事物ID，DHCP客户端的MAC地址，接受的租约中的IP地址，提供此租约的DHCP服务器端的IP地址等信息</li><li>本例中，假设DHCP客户选择DHCP服务器1作为自己的DHCP服务器，并且DHCP服务器1接受该请求</li><li>于是DHCP服务器1给DHCP客户发送DHCP确认报文<ul><li>封装该报文的IP数据报的源IP地址为DHCP服务器1的IP地址</li><li>目的地址仍为广播地址</li></ul></li><li>DHCP客户收到该确认报文后，就可以使用所租用到的IP地址了<ul><li>再使用租用到的IP地址之前，主机还会使用ARP检测该IP地址是否已被网络中其他主机占用</li><li>若被占用，给DHCP服务器发送<code>DHCP DECLINE</code>报文(DHCP谢绝报文)撤销IP地址租约，并重新发送<code>DHCP DISCOVER</code>报文</li><li>若未被占用，可以使用租约中的IP地址与网络中其他主机通信了</li></ul></li><li>当租用期过了一半时，DHCP客户会向DHCP服务器发送DHCP请求报文，来请求更新租用期<ul><li>封装该报文的源IP地址为DHCP客户之前租用到的IP地址</li><li>目的IP地址为DHCP服务器1的地址</li></ul></li><li>(<strong>情况1</strong>)DHCP服务器若同意，则发回DHCP确认报文，这样DHCP客户就得到了新的租用期</li><li>(<strong>情况2</strong>)DHCP服务器若不同意，则发回DHCP否认报文。这时，DHCP客户必须立即停止使用之前租用的IP地址并重新发送DHCP发现报文来重新申请IP地址</li><li>(<strong>情况3</strong>)DHCP服务器若未作出响应，则在租用期过了87.5%时，DHCP客户必须重新发送DHCP请求报文，然后继续等待DHCP服务器可能做出的反应<ul><li>若DHCP服务器未作出响应，则当租用期过期后，DHCP客户必须立即停止使用之前租用的IP地址，并重新发送DHCP发现报文来重新申请IP地址</li></ul></li><li>DHCP客户可以随时终止DHCP服务器所提供的租用期，这时只需要向DHCP服务器发送DHCP释放报文段即可</li></ul></li><li>DHCP服务器在给DHCP客户挑选IP地址时，使用ARP来确保所挑选的IP地址未被网络中其他主机占用，而DHCP客户在使用所租用的IP地址之前也会使用ARP来检测该IP地址是否已经被网络中其他主机占用</li></ul><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/network/part3/9.webp alt=""></p><h4 id=dhcp中继代理><a class=anchor href=#dhcp中继代理>#</a> DHCP中继代理</h4><ul><li>在每一个网络上都设置一个DHCP服务器会使DHCP服务器的数量太多。因此现在是使每一个网络至少有一个DHCP中继代理(通常是一台路由器)，它配置了DHCP服务器的IP地址信息，作为各网络中计算机与DHCP服务器的桥梁</li></ul><h3 id=域名系统dnsdomain-name-system><a class=anchor href=#域名系统dnsdomain-name-system>#</a> ! 域名系统DNS(Domain Name System)</h3><h4 id=概述-3><a class=anchor href=#概述-3>#</a> 概述</h4><ul><li>早在1983年，因特网就开始采用层次结构命名树作为主机的名字(即域名)，并使用分布式的域名管理系统DNS</li><li>DNS使大多数域名都在本地解析，仅少量解析需要在因特网上通信，因此系统效率很高</li><li>因特网采用层次树状机构的域名结构</li><li>域名的结构由若干个分量组成，各分量之间用点隔开，分别代表不同级别的域名<ul><li><code>...x.三级域名.二级域名.顶级域名</code></li><li>每一级的域名都由英文字母和数字组成，不超过63个字符，不区分大小写字母</li><li>级别最低的域名写在最左边，而级别最高的定级域名写在最右边</li><li>完整的域名不超过255个字符</li></ul></li><li>域名系统不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思</li><li>各级域名由其上一级的域名管理机构管理，而最高的顶级域名则由因特网名称与数字地址分配机构ICANN进行管理</li><li>目前DNS的设计采用的是分布式、层次数据库结构，DNS是应用层协议，它可以在UDP或TCP协议之上运行，端口为53。它将人类可读的域名(如<code>www.example.com</code>)转换为机器可读的IP地址(如 192.0.2.1)，使得用户能够通过域名访问网站而无需记住复杂的IP地址</li><li>当你输入一个网址时，你的设备会使用DNS来查找对应的IP地址，从而能够连接到正确的服务器</li><li>DNS查询通常在用户感知不到的情况下在后台进行，并且大多使用UDP协议进行通信，因为它比TCP更快，而DNS查询需要速度</li></ul><details class=info><summary>DNS的作用是什么？</summary><div><p>DNS域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS要解决的是<strong>域名和IP地址的映射问题</strong>，在一台电脑上，可能存在浏览器DNS缓存，操作系统DNS缓存，路由器DNS缓存。</p><p>浏览器在本地会维护一个<code>hosts</code>列表，一般来说浏览器要先查看要访问的域名是否在<code>hosts</code>列表中，如果有的话，直接提取对应的IP地址记录，就好了。如果本地<code>hosts</code>列表内没有<code>域名-IP</code>对应记录的话，那么就会使用DNS了。</p></div></details><h4 id=顶级域名tldtop-level-domain><a class=anchor href=#顶级域名tldtop-level-domain>#</a> 顶级域名TLD(Top Level Domain)</h4><p>分为以下三类</p><ul><li>国家顶级域名nTLD<ul><li>采用ISO 3166规定</li><li>cn - 中国</li><li>us - 美国</li><li>uk - 英国</li></ul></li><li>通用顶级域名gTLD<ul><li>最常见的通用顶级域名有七个</li><li>com - 公司企业</li><li>net - 网络服务机构</li><li>org - 非盈利性组织</li><li>int - 国际组织</li><li>edu - 美国教育机构</li><li>gov - 美国政府部分</li><li>mil - 美国军事部门</li></ul></li><li>反向域arpa<ul><li>用于反向域名解析，即IP地址反向解析为域名</li></ul></li></ul><p>在国际顶级域名下注册的二级域名均由该国家自行确定。例如，顶级域名为jp的日本，将其教育和企业机构的二级域名定为ac和co，而不是edu和com。</p><p>我国则将二级域名划分为以下两类</p><ul><li>类别域名，共七个<ul><li>ac - 科研机构</li><li>com - 工，商，金融等企业</li><li>edu - 教育机构</li><li>gov - 政府部分</li><li>net - 提供网络服务的机构</li><li>mil - 军事机构</li><li>org - 非盈利性组织</li></ul></li><li>行政区域名，共34个，适用于我国的各省，自治区，直辖市，例如<ul><li>bj - 北京市</li><li>sh - 上海市</li></ul></li></ul><p>域名和IP地址的映射关系必须保存在域名服务器中，供所有其他应用查询。显然不能将所有信息都存储在一台域名服务器中。</p><p>DNS使用分布在各地的域名服务器来实现域名到IP地址的转换。</p><h4 id=域名dns服务器><a class=anchor href=#域名dns服务器>#</a> 域名(DNS)服务器</h4><p>可以划分为以下四种不同的类型</p><ul><li>根域名服务器<ul><li>根域名服务器是最高层次的域名服务器。每个根域名服务器都知道所有的顶级域名服务器的域名及其IP地址。因特网上共有13个不同IP地址的根域名服务器。尽管我们将这13个根域名服务器中的每一个都视为单个的服务器，但每台服务器实际上是由许多分布在世界各地的计算机构成的服务器集群。当本地域名服务器向根域名服务器发出查询请求时，路由器就把查询请求报文转发到离这个DNS客户最近的一个根域名服务器。这就加快了DNS的查询过程，同时也更合理地利用了因特网的资源。根域名服务器通常并不直接对域名进行解析，而是返回该域名所属顶级域名服务器的IP地址</li></ul></li><li>顶级域名服务器<ul><li>这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到DNS查询请求时就给出相应的回答(可能是最后的结果，也可能是下一级权限域名服务器的IP地址)</li></ul></li><li>权限域名服务器<ul><li>这些域名服务器负责管理某个区的域名。每一个主机的域名都必须在某个权限域名服务器处等级。因此权限域名服务器知道其管辖的域名与IP地址的映射关系。另外，权限域名服务器还知道其下级域名服务器的地址</li></ul></li><li>本地域名服务器<ul><li>本地域名服务器不属于上述的域名服务器的等级结构。当一个主机发出DNS请求报文时，这个报文就首先被送往该主机的本地域名服务器。本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中。每一个因特网服务提供者ISP，一个大学，甚至一个大学里的学院，都可以拥有一个本地域名服务器，他有时也称默认域名服务器。本地域名服务器离用户较近，一般不超过几个路由器的距离，也有可能在同一个局域网中。本地域名服务器的IP地址需要直接配置在需要域名解析的主机中</li></ul></li></ul><h4 id=域名解析的过程><a class=anchor href=#域名解析的过程>#</a> 域名解析的过程</h4><ul><li><p>递归查询 与 迭代查询</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/network/part3/10.webp alt=""></p></li><li><p>为了提高DNS的查询效率，并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛地使用了高速缓存</p><ul><li>高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录</li></ul></li><li><p>由于域名到IP地址的映射关系并不是永久不变，为了保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并删除超过合理时间的项</p></li><li><p>不但在本地域名服务器中需要高速缓存，在用户主机中也很需要。许多用户主机在启动时从本地域名服务器下载域名和IP地址的全部数据块，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到域名时才向域名服务器查询。同理，主机也需要保持高速缓存中内容的正确性</p></li></ul><p><span class=exturl data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vY3MtYmFzaWNzL25ldHdvcmsvZG5zLmh0bWw=">DNS域名系统详解</span></p><details class=info><summary>DNS劫持是什么？</summary><div><p>DNS劫持是一种网络攻击，它通过修改DNS服务器的解析结果，使用户访问的域名指向错误的IP地址，从而导致用户无法访问正常的网站，或者被引导到恶意的网站。DNS劫持有时也被称为DNS重定向、DNS欺骗或DNS污染。</p></div></details><h3 id=文件传送协议ftpfile-transfer-protocol><a class=anchor href=#文件传送协议ftpfile-transfer-protocol>#</a> ! 文件传送协议FTP(File Transfer Protocol)</h3><ul><li>文件传送 - 将某台计算机中的文件通过网络传送到可能相距很远的另一台计算机中，是一项基本的网络应用</li><li>文件传输协议FTP是因特网上使用得最广泛得文件传输协议<ul><li>FTP提供交互式的访问，允许客户指明文件的类型与格式(如指明是否使用ASCII码)，并允许文件具有存取权限(如访问文件的用户必须经过授权，并输入有效的口令)</li><li>FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件</li></ul></li><li>FTP的应用<ul><li>在计算机之间传输文件，尤其是用于批量传输文件</li><li>让网站设计者将构成网站内容的大量文件批量上传到他们的Web服务器</li></ul></li></ul><p><strong>FTP的基本工作原理</strong></p><ul><li><p>主动模式工作过程</p><ul><li><p>假设各有FTP客户和FTP服务器</p></li><li><p>FTP服务器监听熟知端口号21，FTP客户随机选择一个临时端口号与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送FTP的相关命令，即这条TCP连接是FTP客户与服务器之间的命令通道</p></li><li><p>(<strong>主动模式</strong>)当有数据要传输时，FTP客户通过命令管道告知FTP服务器来与自己的另一个临时端口号建立TCP连接，即建立数据通道。FTP客户随机选择另一个端口号，FTP服务器使用自己的熟知端口号20与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送文件，即这条TCP连接是FTP客户与服务器之间的数据通道</p><ul><li>由于在建立数据通道时，FTP服务器主动连接FTP客户，因此称为主动模式</li></ul></li><li><p>(<strong>被动模式</strong>)它与主动模式并没有什么不同，不同之处在于，当有数据要传输时，FTP客户通过命令管道通知FTP服务器，开启某个协商好的临时端口，被动等待来自FTP客户的TCP连接以建立数据通道</p></li></ul></li><li><p>控制连接在整个会话期间一直保持打开，用于传送FTP相关控制命令</p></li><li><p>数据连接用于文件传输，在每次文件传输时才建立，传输结束就关闭</p></li></ul><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/network/part3/11.webp alt=""></p><h3 id=电子邮件><a class=anchor href=#电子邮件>#</a> 电子邮件</h3><ul><li>电子邮件采用客户/服务器方式</li><li>三个主要组成构件<ul><li>用户代理 - 是用户与电子邮件系统的接口，又称电子邮件客户端软件</li><li>邮件服务器 - 是电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱</li><li>电子邮件协议 - 邮件发送协议(例如SMTP)和邮件读取协议(例如POP3，IMAP)</li></ul></li></ul><p><strong>邮件的发送和接收过程</strong></p><ul><li>发送方的用户代理作为SMTP客户，与发送方邮件服务器中的SMTP服务器进行TCP连接，然后基于这条连接使用SMTP协议来发送邮件给发送方邮件服务器</li><li>发送方邮件服务器中的SMTP客户与接收方邮件服务器中的SMTP服务器进行TCP连接，然后基于这条连接使用SMTP协议来发送已收到的待转发邮件给接收方邮件服务器</li><li>接收方用户代理作为POP3客户，与接收方邮件服务器中的POP3服务器进行TCP连接，然后基于这条连接使用POP3协议从接收方邮件服务器读取邮件</li></ul><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/network/part3/12.webp alt=""></p><h4 id=简单邮件传送协议smtpsimple-mail-transfer-protocol><a class=anchor href=#简单邮件传送协议smtpsimple-mail-transfer-protocol>#</a> 简单邮件传送协议SMTP(Simple Mail Transfer Protocol)</h4><p>基于TCP协议，是一种用于发送电子邮件的协议。</p><p><strong>基本工作原理</strong></p><ul><li>以发送方邮件服务器使用SMTP协议，给接收方邮件服务器发送带转发的邮件为例</li><li>发送方邮件服务器周期性地扫描邮件缓存</li><li>如果发送带转发的邮件，则发送方邮件服务器中的SMTP客户会与接收方邮件服务器中的SMTP服务器进行TCP连接，端口号为25</li><li>之后，SMTP客户就可以基于这条TCP连接给SMTP服务器发送SMTP命令(共14条)，SMTP服务器也会给SMTP客户发送相应的应答(共21种)<ul><li>SMTP客户与服务器之间通过命令与应答的交互方式最终实现SMTP客户发送邮件给SMTP服务器</li></ul></li><li>当TCP连接建立成功后，SMTP服务器会主动推送服务就绪应答给SMTP客户，应答代码220后面可能跟有描述信息</li><li>SMTP客户收到该应答后，向服务器表明身份，告知自己SMTP服务器的域名，具体命令为<code>HELO 命令参数</code></li><li>SMTP服务器若认为身份有效，则发回应答代码250，否则发回其他错误代码<ul><li>421 - 服务不可用</li></ul></li><li>SMTP客户收到该应答后，使用命令<code>MAIL FROM</code>来告诉服务器邮件来自何方</li><li>SMTP服务器若认为合理，则发回应答代码250，否则发回其他错误代码</li><li>SMTP客户收到该应答后，使用命令<code>RCPT TO</code>来告诉服务器邮件去往何处，即收件人邮箱</li><li>SMTP服务器中如果有该收件人邮箱，则发回应答代码250，否则发回其他错误代码</li><li>SMTP收到该应答后，使用<code>DATA</code>命令来告诉服务器自己准备发送邮件内容了</li><li>SMTP服务器如果准备好接收，则发回应答代码354，否则发回其他错误代码</li><li>SMTP客户收到该应答后就向服务器发送邮件内容。SMTP客户发送完邮件内容后，还要发送结束符</li><li>SMTP服务器若收件成功，则发回应答代码250，否则发回其他错误代码</li><li>SMTP客户收到该应答后，使用命令<code>QUIT</code>向服务器请求断开连接</li><li>SMTP服务器发回应答代码221，表示接受请求并主动断开连接</li></ul><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/network/part3/13.webp alt=""></p><h4 id=电子邮件的信息格式><a class=anchor href=#电子邮件的信息格式>#</a> 电子邮件的信息格式</h4><ul><li>不是由SMTP定义的，而是在RFC 822中单独定义的，其已在2008年更新为RFC 5322<ul><li>一封电子邮件有信封和内容两部分</li><li>而内容又有首部和主体两部分构成</li></ul></li><li>SMTP协议只能传送ASCII码文本数据，不能传送可执行文件或其他的二进制对象</li><li>为了解决SMTP协议的问题，提出了多用途因特网邮件扩展MIME(Multipurpose Internet Mail Extensions)<ul><li>增加了5各新的邮件首部字段 - 提供了有关邮件主体的信息</li><li>定义了许多邮件内容的格式 - 对多媒体电子邮件的表示方法进行了标准化</li><li>定义了传送编码 - 可对任何内容格式进行转换，而不会被邮件系统改变</li></ul></li><li>MIME不仅用于SMTP，还用于HTTP</li></ul><h4 id=常用邮件接收协议><a class=anchor href=#常用邮件接收协议>#</a> 常用邮件接收协议</h4><ul><li>邮局协议POP(Post Office Protocol)<ul><li>POP3是其第三个版本，是因特网正式标准</li><li>用户只能以下载并删除方式或下载并保留方式从邮件服务器下载邮件到用户方计算机</li><li>不允许用户在邮件服务器上管理自己的邮件</li></ul></li><li>因特网邮件访问协议IMAP(Internet Message Access Protocol)<ul><li>IMAP4是其第四个版本，目前还只是因特网建议标准</li><li>用户在自己的计算机上就可以操控邮件服务器中的邮箱</li><li>IMAP是一个联机协议</li></ul></li><li>POP3和IMAP4都采用基于TCP连接的客户/服务器方式。<ul><li>POP3使用熟知端口110</li><li>IMAP4使用熟知端口143</li></ul></li></ul><p><strong>基于万维网的电子邮件</strong></p><p>通过浏览器邮件服务器万维网网站就可撰写，收发，阅读和管理电子邮件。工作模式与IMAP很类似，不同的是用户计算机无需安装专门的用户代理程序，只需使用通用的万维网浏览器。</p><details class=info><summary>电子邮件的发送过程？</summary><div><p>接受邮件的协议不是SMTP而是POP3协议。</p><p>比如邮箱是<code>dabai@cszhinan.com</code>，要向<code>xiaoma@qq.com</code>发送邮件，整个过程可以简单分为下面几步</p><ol><li>通过SMTP协议，将写好的邮件交给163邮箱服务器(邮局)</li><li>163邮箱服务器发现发送的邮箱是qq邮箱，然后它使用SMTP协议将该邮件转发到qq邮箱服务器</li><li>qq邮箱服务器接收邮件之后就通知邮箱为<code>xiaoma@qq.com</code>的用户来收邮件，然后用户就通过<code>POP3/IMAP</code>协议将邮件取出</li></ol></div></details><details class=info><summary>如何判断邮箱是真正存在的？</summary><div><p>很多场景(比如邮件营销)下需要判断要发送的邮箱地址是否真的存在，这个时候可以利用SMTP协议来检测，其简易过程为</p><ol><li>查找邮箱域名对应的SMTP服务器地址</li><li>尝试与服务器建立连接</li><li>连接成功后尝试向需要验证的邮箱发送邮件</li><li>根据返回结果判定邮箱地址的真实性</li></ol></div></details><h3 id=万维网wwwworld-wide-web><a class=anchor href=#万维网wwwworld-wide-web>#</a> ! 万维网WWW(World Wide Web)</h3><ul><li><p>万维网WWW并非某种特殊的计算机网络。它是一个大规模的，联机式的信息储藏所，是运行在因特网上的一个分布式应用</p></li><li><p>万维网利用网页之间的超链接将不同网站的网页连接成一张逻辑上的信息网</p></li><li><p>万维网是欧洲粒子物理实验室的<code>Tim Berners-Lee</code>最初于1989年3月提出的</p></li><li><p>浏览器最重要的部分是渲染引擎，即浏览器内核。负责对网页内容进行解析和显示</p><ul><li>不同的浏览器内核对网页内容的解析也有不同，因此同一网页在不同内核的浏览器里的显示效果可能不一样</li><li>网页编写者需要在不同内核的浏览器中测试网页显示效果</li></ul></li><li><p>万维网使用统一资源定位符URL来指明因特网上任何种类资源的位置</p></li><li><p>URL的一般形式由以下四个部分组成</p><ul><li><code>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/路径</code></li><li><code>http://www.example.com:80/index.html</code><ul><li>http - 协议</li><li><code>www.example.com</code> - 主机</li><li>80 - 端口</li><li><code>/index.html</code> - 路径</li></ul></li></ul></li><li><p>万维网文档</p><ul><li>超文本标记语言(HyperText Markup Language - HTML) - 使用多种标签来描述网页的结构和内容</li><li>层叠样式表(Cascading Style Sheets - CSS) - 从审美的角度来描述网页的样式</li><li>JavaScript脚本语言(与Java没有任何关系) - 控制网页的行为</li></ul></li></ul><h4 id=超文本传输协议httphypertext-transfer-protocol><a class=anchor href=#超文本传输协议httphypertext-transfer-protocol>#</a> 超文本传输协议HTTP(HyperText Transfer Protocol)</h4><ul><li>HTTP是一种用于传输超文本和多媒体内容的协议，主要是为Web浏览器与Web服务器之间的通信而设计的。当使用浏览器浏览网页的时候，网页就是通过HTTP请求进行加载的。HTTP定义了浏览器(即万维网客户进程)怎样向万维网服务器请求万维网文档，以及万维网服务器怎样把万维网文档传送给浏览器</li><li>HTTP使用<code>C/S</code>模型，基于TCP协议，其扩展性强、速度快、跨平台支持性好</li><li>客户端向服务器发送<code>HTTP Request</code>(请求)，发送HTTP请求之前首先要建立TCP连接也就是要经历3次握手。服务器响应请求并返回<code>HTTP Response</code>(响应)</li><li><code>HTTP/1.0</code>采用非持续连接方式。在该方式下，每次浏览器请求一个文件都要与服务器建立TCP连接，当收到响应后就立即关闭连接<ul><li>每请求一个文档就要有两倍的RTT的开销</li><li>为了减少时延，浏览器通常会建立多个并行的TCP连接同时请求多个对象(这会加大万维网服务器的负担)</li></ul></li><li>目前使用的HTTP协议大部分都是<code>HTTP/1.1</code>，默认是开启<code>Keep-Alive</code>的，采用持续连接方式，建立的连接可以在多次请求中被复用。在该方式下，万维网服务器在发送响应后仍保持这条连接，使同一个客户(浏览器)和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。这并不局限于传送同一个页面上引用的对象，而是只要这些文档都在同一个服务器上就行<ul><li>为了进一步提高效率，<code>HTTP/1.1</code>的持续连接还可以使用流水线方式工作，即浏览器在收到HTTP的响应报文之前就能够连续发送多个请求报文。这样的一个接一个的请求报文到达服务器后，服务器就发回一个接一个的响应报文。这样就节省了很多个RTT时间，使TCP连接中的空闲时间减少，提高了下载文档的效率</li></ul></li><li>HTTP协议是<strong>无状态</strong>的协议，它无法记录客户端用户的状态，一般都是通过Session来记录客户端用户的状态</li></ul><details class=info><summary>HTTP协议通信过程</summary><div><ul><li><p>服务器在80端口等待客户的请求</p></li><li><p>浏览器发起到服务器的TCP连接(创建Socket)</p></li><li><p>服务器接收来自浏览器的TCP连接</p></li><li><p>浏览器(HTTP客户端)与Web服务器(HTTP服务器)交换HTTP消息</p></li><li><p>关闭TCP连接</p></li></ul></div></details><details class=info><summary>HTTP基于TCP还是UDP？</summary><div><p>HTTP/3.0之前是基于TCP协议的，而HTTP/3.0将弃用TCP，改用基于UDP的QUIC协议。</p><p>此变化解决了HTTP/2中存在的队头阻塞问题。队头阻塞是指在HTTP/2.0中，多个HTTP请求和响应共享一个TCP连接，如果其中一个请求或响应因为网络拥塞或丢包而被阻塞，那么后续的请求或响应也无法发送，导致整个连接的效率降低。这是由于HTTP/2.0在单个TCP连接上使用了多路复用，受到TCP拥塞控制的影响，少量的丢包就可能导致整个TCP连接上的所有流被阻塞。HTTP/3.0在一定程度上解决了队头阻塞问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响(本质上是多路复用+轮询)。</p><p>除了解决队头阻塞问题，HTTP/3.0还可以减少握手过程的延迟。在HTTP/2.0中，如果要建立一个安全的HTTPS连接，需要经过TCP三次握手和TLS握手</p><ol><li>TCP三次握手 - 客户端和服务器交换SYN和ACK包，建立一个TCP连接。这个过程需要1.5个RTT(round-trip time)，即一个数据包从发送到接收的时间</li><li>TLS握手 - 客户端和服务器交换密钥和证书，建立一个TLS加密层。这个过程需要至少1个RTT(TLS 1.3)或者2个 RTT(TLS 1.2)</li></ol><p>所以，HTTP/2.0的连接建立就至少需要2.5个RTT(TLS 1.3)或者3.5个RTT(TLS 1.2)。而在HTTP/3.0中，使用的QUIC协议(TLS 1.3，TLS 1.3除了支持1个RTT的握手，还支持0个RTT的握手)连接建立仅需0-RTT或者1-RTT。这意味着QUIC在最佳情况下不需要任何的额外往返时间就可以建立新连接。</p></div></details><details class=info><summary>HTTP1.1版本有哪些新特性？</summary><div><ul><li>默认持久连接，节省通信量 - 只要客户端或服务端没有明确提出断开TCP连接，则一直保持连接，可以发送或响应多次HTTP请求</li><li>管线化 - 客户端可以同时发出多个HTTP请求，而不用挨个等待响应</li><li>断点续传 - 利用HTTP首部段，分块传输实体主体</li></ul></div></details><details class=info><summary>HTTP/1.1和HTTP/2.0有什么区别？</summary><div><ul><li><p><strong>多路复用(Multiplexing)</strong> - <code>HTTP/2.0</code>在同一连接上可以同时传输多个请求和响应(可以看作是 HTTP/1.1 中长链接的升级版本)，互不干扰。HTTP/1.1 则使用串行方式，每个请求和响应都需要独立的连接，而浏览器为了控制资源会有 6-8 个 TCP 连接都限制。。这使得 HTTP/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能</p></li><li><p><strong>二进制帧(Binary Frames)</strong> - <code>HTTP/2.0</code>使用二进制帧进行数据传输，而<code>HTTP/1.1</code>则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗</p></li><li><p><strong>头部压缩(Header Compression)</strong> - <code>HTTP/1.1</code>支持<code>Body</code>压缩，<code>Header</code>不支持压缩。<code>HTTP/2.0</code>支持对<code>Header</code>压缩，使用了专门为<code>Header</code>压缩而设计的HPACK算法，减少了网络开销</p></li><li><p><strong>服务器推送(Server Push)</strong> - <code>HTTP/2.0</code>支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而<code>HTTP/1.1</code>需要客户端自己发送请求来获取相关资源</p></li><li><p><strong><code>HTTP/2.0</code>多路复用</strong></p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/network-programming/http/1.webp alt=""></p><p>可以看到，<code>HTTP/2.0</code>的多路复用使得不同的请求可以共用一个TCP连接，避免建立多个连接带来不必要的额外开销，而<code>HTTP/1.1</code>中的每个请求都会建立一个单独的连接。</p></li></ul></div></details><details class=info><summary>HTTP/2.0和HTTP/3.0有什么区别？</summary><div><ul><li><p><strong>传输协议</strong> - HTTP/2.0是基于TCP协议实现的，HTTP/3.0新增了QUIC(Quick UDP Internet Connections)协议来实现可靠的传输，提供与TLS/SSL相当的安全性，具有较低的连接和传输延迟。可以将QUIC看作是UDP的升级版本，在其基础上新增了很多功能比如加密、重传等等。HTTP/3.0之前名为HTTP-over-QUIC，从这个名字中也可以发现，HTTP/3最大的改造就是使用了QUIC</p></li><li><p><strong>连接建立</strong> - HTTP/2.0需要经过经典的TCP三次握手过程(由于安全的HTTPS连接建立还需要TLS握手，共需要大约3个RTT)。由于QUIC协议的特性(TLS 1.3，TLS 1.3除了支持1个RTT的握手，还支持0个RTT 的握手)连接建立仅需 0-RTT 或者 1-RTT。这意味着 QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接</p></li><li><p><strong>队头阻塞</strong> - HTTP/2.0多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的HTTP请求。由QUIC协议的特性，HTTP/3.0在一定程度上解决了队头阻塞(Head-of-Line blocking - HOL blocking)问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响(本质上是多路复用+轮询)</p></li><li><p><strong>错误恢复</strong> - HTTP/3.0具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。而 HTTP/2.0则需要依赖于 TCP 的错误恢复机制</p></li><li><p><strong>安全性</strong> - HTTP/2.0和HTTP/3.0在安全性上都有较高的要求，支持加密通信，但在实现上有所不同。HTTP/2.0使用TLS协议进行加密，而HTTP/3.0基于QUIC协议，包含了内置的加密和身份验证机制，可以提供更强的安全性</p></li></ul><p><span class=exturl data-url=aHR0cHM6Ly9kYnd1LnRlY2gvcG9zdHMvaHR0cF9ldm9sdXRpb24v>→HTTP1到HTTP3的工程优化</span></p></div></details><h4 id=http报文格式><a class=anchor href=#http报文格式>#</a> HTTP报文格式</h4><ul><li><p>HTTP是面向文本的，其报文中的每一个字段都是一些ASCII码串，并且每个字段的长度都是不确定的</p><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/network/part3/14.webp alt=""></p></li><li><p>HTTP请求报文支持以下方法</p><ul><li>GET - 请求URL标志的文档</li><li>HEAD - 请求URL标志的文档首部</li><li>POST - 向服务器发送数据</li><li>PUT - 在指明的RTL下存储一个文档</li><li>DELETE - 删除URL标志的文档</li><li>CONNECT - 用于代理服务器</li><li>OPTIONS - 请求一些选项信息</li><li>TRACE - 用来进行环回测试</li><li>PATCH - 对PUT方法的补充，用来对已知资源进行局部更新</li></ul><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/computer-basic/network/part3/15.webp alt=""></p></li></ul><h4 id=cookie><a class=anchor href=#cookie>#</a> Cookie</h4><ul><li>使用Cookie在服务器上记录用户信息<ul><li>早期万维网应用简单，因此HTTP被设计为一种无状态的协议，这可以简化服务器的设计</li><li>Cookie提供了一种机制使得万维网服务器能够记住用户，而无需用户主动提供用户标识信息。也就是说，Cookie是一种对无状态的HTTP进行状态化的技术</li></ul></li><li>工作原理<ul><li>用户主机的浏览器进程，首先与万维网服务器中的服务进程建立TCP连接</li><li>当用户浏览器进程初次向服务器进程发送HTTP请求报文时，服务器进程会为其产生一个唯一的Cookie识别码，并以此为索引在服务器的后端数据库中创建一个项目，用来记录该用户访问该网站的各种信息，接着就会给浏览器进程发回HTTP响应报文</li><li>在响应报文中包含一个首部字段为<code>Set-Cookie</code>的首部行，该字段的取值就是Cookie识别码，当浏览器进程收到该响应报文后，就在一个特定的Cookie文件中添加一行，记录该服务器的域名和Cookie识别码</li><li>当用户再次使用该浏览器访问这个网站时，每发送一个HTTP请求报文，浏览器都会从Cookie文件中取出该网站的Cookie识别码，并放到HTTP请求报文的Cookie首部行中。服务器根据Cookie识别码就可以识别出该用户，并返回该用户的个性化网页</li></ul></li></ul><details class=info><summary>HTTP是不保存状态的协议, 如何保存用户状态？</summary><div><p>HTTP是一种不保存状态，即无状态(stateless)协议。也就是说HTTP协议自身不对请求和响应之间的通信状态进行保存。那么如何保存用户状态呢？Session机制的存在就是为了解决这个问题，Session的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为HTTP协议是无状态的。服务端给特定的用户创建特定的Session之后就可以标识这个用户并且跟踪这个用户了(一般情况下，服务器会在一定时间内保存这个Session，过了时间限制，就会销毁这个Session)。</p><p>在服务端保存Session的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然Session存放在服务器端，那么如何实现Session跟踪呢？大部分情况下，都是通过在Cookie中附加一个<code>Session ID</code>来方式来跟踪。</p></div></details><details class=info><summary>Cookie被禁用怎么办？</summary><div><p>最常用的就是利用URL重写把<code>Session ID</code>直接附加在URL路径的后面。</p><p><span class=exturl data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vc3lzdGVtLWRlc2lnbi9zZWN1cml0eS9iYXNpcy1vZi1hdXRob3JpdHktY2VydGlmaWNhdGlvbi5odG1sIyVFOCVBRSVBNCVFOCVBRiU4MS1hdXRoZW50aWNhdGlvbi0lRTUlOTIlOEMlRTYlOEUlODglRTYlOUQlODMtYXV0aG9yaXphdGlvbi0lRTclOUElODQlRTUlOEMlQkElRTUlODglQUIlRTYlOTglQUYlRTQlQkIlODAlRTQlQjklODg=">Cookie和Session的区别-认证授权的范畴</span></p></div></details><details class=info><summary>如何避免HTTP协议的无状态特性？</summary><div><ul><li>使用Cookie将状态信息保存在客户端</li><li>使用Session将状态信息保存在服务端</li></ul></div></details><h4 id=万维网缓存与代理服务器><a class=anchor href=#万维网缓存与代理服务器>#</a> 万维网缓存与代理服务器</h4><ul><li>万维网缓存又称Web缓存(Web Cache)，可位于客户机，也可位于中间系统上，位于中间系统上的Web缓存又称为代理服务器(Proxy Server)</li><li>Web缓存把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去因特网访问该资源</li><li>原始服务器通常会为每个响应的对象设定一个修改时间字段和一个有效日期字段<ul><li>若代理服务器中的被请求文档未过期，代理服务器将其封装在响应报文中发回给请求主机</li><li>若代理服务器中的被请求文档过期，代理服务器会向因特网上的原始服务器发送请求，在请求报文中包含一个首部字段为<code>if-modified-since</code>的首部行，该字段的取值就是该文档的修改日期。原始服务器根据该文档的修改日期，就可判断出代理服务器中存储的该文档是否与自己存储的该文档一致<ul><li>如果一致，则原始服务器给代理服务器发送不包含实体主体的响应，状态码为304，短语为<code>Not Modified</code>。代理服务器重新更新该文档的有效日期，然后将该文档封装在响应报文中发回给请求主机</li><li>如果不一致，则原始服务器给代理服务器发送封装有该文档的响应报文，这样代理服务器就更新了该文档，然后将该文档封装在响应报文中发回给请求主机</li></ul></li></ul></li></ul><h4 id=https协议hyper-text-transfer-protocol-secure><a class=anchor href=#https协议hyper-text-transfer-protocol-secure>#</a> HTTPS协议(Hyper Text Transfer Protocol Secure)</h4><p>HTTPS协议基于HTTP，是HTTP的加强安全版本，保密性好、信任度高。</p><p>HTTPS也是用TCP作为底层协议，并额外使用SSL/TLS协议用作加密和安全认证。默认端口号是443。</p><p>HTTPS协议之所以能达到较高的安全性要求，就是结合了SSL/TLS和TCP协议，对通信数据进行加密，解决了HTTP数据透明的问题，SSL通道通常使用基于密钥的加密算法，密钥长度通常是40比特或128比特。</p><details class=info><summary>SSL和TLS的区别？</summary><div><ul><li>1996年首次发布SSL指安全套接字协议(Secure Sockets Layer)的3.0版本，<code>SSL 1.0</code>从未面世，<code>SSL 2.0</code>则具有较大的缺陷(DROWN缺陷 - Decrypting RSA with Obsolete and Weakened eNcryption)</li><li>1999年<code>SSL 3.0</code>进一步升级，新版本被命名为<code>TLS 1.0</code></li></ul><p>因此，TLS是基于SSL之上的，但由于习惯叫法，通常把HTTPS中的核心加密协议混称为SSL/TLS。</p><p><span class=exturl data-url=aHR0cHM6Ly9qYXZhZ3VpZGUuY24vY3MtYmFzaWNzL25ldHdvcmsvaHR0cC12cy1odHRwcy5odG1sI3NzbC10bHMtJUU3JTlBJTg0JUU1JUI3JUE1JUU0JUJEJTlDJUU1JThFJTlGJUU3JTkwJTg2>→SSL/TLS的工作原理</span></p></div></details><details class=info><summary>HTTP和HTTPS有什么区别？()</summary><div><ul><li><p><strong>端口号与URL前缀</strong></p><ul><li>HTTP默认是80，URL前缀是<code>http://</code></li><li>HTTPS默认是 443，URL前缀是<code>https://</code></li></ul></li><li><p><strong>安全性和资源消耗</strong></p><ul><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，数据在传输过程中容易被窃听和篡改</li><li>HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS运行在TCP之上.在使用HTTPS时，服务器需要一个SSL证书，以验证服务器的身份，这个证书通常由可信任的证书颁发机构(CA)签发。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以HTTP的安全性没有HTTPS高，但是HTTPS比HTTP耗费更多服务器资源。由于HTTPS需要加密和解密数据，因此在一些情况下可能会比HTTP慢一些</li></ul></li><li><p><strong>SEO(搜索引擎优化)</strong> - 搜索引擎通常会更青睐使用HTTPS协议的网站，因为HTTPS能够提供更高的安全性和用户隐私保护。使用HTTPS协议的网站在搜索结果中可能会被优先显示，从而对SEO产生影响</p></li><li><p>与HTTPS相比，HTTP有哪些缺点？</p><ul><li>通信使用明文不加密，内容可能被窃听</li><li>不验证通信方身份，可能遭到伪装</li><li>无法验证报文完整性，可能被篡改</li></ul></li></ul></div></details><details class=info><summary>HTTPS的工作原理是什么？</summary><div><ul><li>客户端使用HTTPS的URL访问服务端，要求与服务端建立SSL连接</li><li>服务端收到客户端请求后，生成一对公钥和私钥，并把公钥放在证书中发送给客户端</li><li>客户端根据SSL连接的安全等级，建立会话密钥，然后用公钥将会话密钥加密，传送给服务端</li><li>服务端用自己的私钥解密出会话密钥</li><li>服务端利用会话密钥加密与客户端之间的通信</li></ul></div></details><h3 id=远程登陆协议telnet><a class=anchor href=#远程登陆协议telnet>#</a> 远程登陆协议(Telnet)</h3><p>基于TCP协议，用于通过一个终端登陆到其他服务器。Telnet协议的最大缺点之一是所有数据(包括用户名和密码)均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用Telnet，而是使用一种称为SSH的非常安全的网络传输协议的主要原因。</p><h3 id=安全外壳协议sshsecure-shell-protocol><a class=anchor href=#安全外壳协议sshsecure-shell-protocol>#</a> ! 安全外壳协议SSH(Secure Shell Protocol)</h3><p>是一种加密的网络传输协议，用于计算机之间的加密登录，可在不安全的网络中为网络服务提供安全的传输环境。</p><p>SSH通过在网络中建立安全隧道来实现SSH客户端与服务器之间的连接，最常见的用途是远程登录系统，除了远程登录，SSH还可以用于安全地执行远程命令、传输文件、创建安全的隧道以保护其他网络服务等。</p><p>SSH的工作方式涉及加密、公钥/私钥身份验证以及会话管理等多个方面，之所以能够保证安全，在于它采用了公钥加密。</p><p><strong>SSH工作流程</strong></p><ul><li>远程主机收到用户的登录请求，把自己的公钥发给用户</li><li>用户使用这个公钥，将登录密码加密后，发送回来</li><li>远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录</li></ul><p>这个过程本身是安全的，但是实施的时候存在一个风险，即如果有人截获了登录请求，然后冒充远程主机并将伪造的公钥发给用户，那么用户很难辨别真伪。它不像https协议，SSH协议的公钥是没有证书中心(CA)公证的，都是自己签发的。</p><p>如果攻击者隐蔽在用户与远程主机之间(比如在公共的wifi区域)，通过伪造的公钥来获取用户的登录密码。再用获取的密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的<strong>中间人攻击(Man-in-the-middle attack)</strong>。</p><h3 id=实时传输协议real-time-transport-protocol><a class=anchor href=#实时传输协议real-time-transport-protocol>#</a> 实时传输协议(Real-time Transport Protocol)</h3><p>RTP通常基于UDP协议，但也支持TCP协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由WebRTC实现。</p><p>RTP协议分为两种子协议</p><ul><li>实时传输协议(Real-time Transport Protocol - RTP) - 传输具有实时特性的数据。</li><li>RTP控制协议(RTP Control Protocol - RTCP) - 提供实时传输过程中的统计信息(如网络延迟、丢包率等)，WebRTC正是根据这些信息处理丢包</li></ul><h2 id=附录><a class=anchor href=#附录>#</a> 附录</h2><h3 id=ping><a class=anchor href=#ping>#</a> PING</h3><p>PING基于网络层的互联网控制报文协议ICMP，其主要原理就是通过在网络上发送和接收ICMP报文实现的。ICMP报文中包含了类型字段，用于标识ICMP报文类型。ICMP报文的类型有很多种，但大致可以分为两类</p><ul><li><strong>查询报文类型</strong> - 向目标主机发送请求并期望得到响应</li><li><strong>差错报文类型</strong> - 向源主机发送错误信息，用于报告网络中的错误情况</li></ul><p>PING命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。例如<code>ping -c 4 www.baidu.com</code></p><p>PING命令的输出结果通常包括以下几部分信息</p><ol><li><strong>ICMP Echo Request(请求报文)信息</strong> - 序列号、TTL(Time to Live)值</li><li><strong>目标主机的域名或IP地址</strong> - 输出结果的第一行</li><li><strong>往返时间(Round-Trip Time - RTT)</strong> - 从发送<code>ICMP Echo Request</code>(请求报文)到接收到<code>ICMP Echo Reply</code>(响应报文)的总时间，用来衡量网络连接的延迟</li><li><strong>统计结果(Statistics)</strong> - 包括发送的ICMP请求数据包数量、接收到的ICMP响应数据包数量、丢包率、往返时间(RTT)的最小、平均、最大和标准偏差值</li></ol><p>如果PING对应的目标主机无法得到正确的响应，则表明这两个主机之间的连通性存在问题(有些主机或网络管理员可能禁用了对ICMP请求的回复，这样也会导致无法得到正确的响应)。如果往返时间(RTT)过高，则表明网络延迟过高。</p><p>PING用到的<code>ICMP Echo Request</code>(类型为8)和<code>ICMP Echo Reply</code>(类型为0)属于查询报文类型。</p><ul><li>PING命令会向目标主机发送<code>ICMP Echo Request</code></li><li>如果两个主机的连通性正常，目标主机会返回一个对应的<code>ICMP Echo Reply</code></li></ul><h3 id=数字签名digital-signature><a class=anchor href=#数字签名digital-signature>#</a> ! 数字签名(Digital Signature)</h3><p>数字签名是一种用于验证数字信息完整性和来源的技术，它利用密码学原理来模拟物理签名的功能。数字签名能够保证一个数字文件或者数据传输过程中没有被篡改，并且可以确认数据的发送方是可信的。</p><p>数字签名通常基于非对称加密算法(如RSA、ECDSA等)实现。在非对称加密中，有两个密钥：一个私钥和一个公钥。私钥是保密的，仅被数据的发送方所持有；公钥则可以公开，任何人都可以使用它来验证签名。</p><p>数字签名的创建和验证过程大致如下</p><ol><li><strong>生成密钥对</strong> - 首先，发送方会生成一对密钥(即上述的私钥和公钥)。私钥用于签名，而公钥用于验证签名</li><li>签名过程<ul><li>发送方将消息(例如电子文档、软件或交易信息)通过哈希函数处理，生成一个固定长度的哈希值(摘要)</li><li>然后，发送方使用自己的私钥对这个哈希值进行加密，生成数字签名</li><li>这个数字签名随着原始消息一起发送给接收方</li></ul></li><li>验证过程<ul><li>接收方收到消息和数字签名后，使用相同的哈希函数处理消息，生成一个新的哈希值</li><li>接收方还会使用发送方的公钥对数字签名进行解密，得到一个哈希值</li><li>如果这两个哈希值相同，则说明消息在传输过程中未被更改，签名也证明了消息确实是由持有相应私钥的发送方所发出的</li></ul></li></ol><p>数字签名的安全性依赖于私钥的保密性。如果私钥不小心泄露，任何人都可以伪造签名。因此，私钥的管理和存储需要非常谨慎。</p><p>数字签名广泛用于多种场合，包括但不限于软件分发、电子邮件、电子商务和各类在线交易，以及其他需要高度安全性的通信和数据交换场景。</p><h3 id=数字证书public-key-certificate><a class=anchor href=#数字证书public-key-certificate>#</a> ! 数字证书(Public key certificate)</h3><p>数字证书是一种用于确认实体身份的电子文档，它利用公钥加密的原理来建立一个可信任的身份验证机制。数字证书通常由受信任的第三方机构，即证书颁发机构(Certificate Authority, CA)签发。它包含了证书持有者的信息以及与之关联的公钥，并且由CA用其自己的私钥进行签名。</p><p><strong>数字证书主要包含以下几个关键部分</strong></p><ul><li><p><strong>证书持有者的信息</strong> - 包括名称、组织和其他标识信息</p></li><li><p><strong>证书持有者的公钥</strong> - 用于在公钥基础设施(PKI)中验证持有者的私钥签名，并且用于加密信息，只有持有对应私钥的持有者才能解密</p></li><li><p><strong>证书颁发机构(CA)的信息</strong> - 提供了签发该证书的CA的识别信息</p></li><li><p><strong>有效期限</strong> - 证书的开始和结束有效日期</p></li><li><p><strong>证书序列号</strong> - 证书的唯一标识符</p></li><li><p><strong>数字签名</strong> - CA使用其私钥产生的对上述所有信息的数字签名</p></li></ul><p><strong>数字证书的作用如下</strong></p><ul><li><strong>认证身份</strong> - 证明一个公钥确实属于其声称的实体，比如一个人、服务器或组织</li><li><strong>建立信任关系</strong> - 在开展电子交易或通信时，帮助建立起参与各方之间的信任关系，因为证书是由权威的CA签发的</li><li><strong>数据加密</strong> - 提供加密通信所需的公钥，确保信息安全传输</li><li><strong>安全通信</strong> - 在TLS/SSL协议中使用，确保网络通信如HTTPS等的安全</li></ul><p>当你访问一个网站时，如果网站使用了SSL/TLS安全协议，你的浏览器会自动检查该网站的SSL证书是否有效，是否由受信任的CA颁发，以及是否与网站域名匹配。如果一切正常，浏览器就会建立安全连接；否则，可能显示警告信息。</p><p>数字证书的有效性依赖于颁发证书的CA的可信度。如果CA遭到破坏或不再被信任，则通过该CA签发的所有证书都可能变得不可靠。因此，维护CA的安全性和可靠性是数字证书体系中至关重要的一环。</p><h3 id=websocket><a class=anchor href=#websocket>#</a> WebSocket</h3><p>WebSocket是一种基于TCP连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。</p><p>WebSocket协议在2008年诞生，2011年成为国际标准，几乎所有主流较新版本的浏览器都支持该协议。不过，WebSocket不只能在基于浏览器的应用程序中使用，很多编程语言、框架和服务器都提供了WebSocket支持。</p><p>WebSocket协议本质上是应用层的协议，用于弥补HTTP协议在持久通信能力上的不足。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><p>WebSocket的常见应用场景</p><ul><li>视频弹幕</li><li>实时消息推送</li><li>实时游戏对战</li><li>多用户协同编辑</li><li>社交聊天</li></ul><details class=info><summary>WebSocket和 HTTP有什么区别？</summary><div><p>WebSocket 是一种双向实时通信协议，而HTTP是一种单向通信协议。并且，HTTP协议下的通信只能由客户端发起，服务器无法主动通知客户端。</p><p>WebSocket 使用 <code>ws://</code> 或 <code>wss://</code>(使用SSL/TLS加密后的协议，类似于HTTP和HTTPS的关系)作为协议前缀，HTTP 使用 <code>http://</code> 或 <code>https://</code> 作为协议前缀。</p><p>WebSocket可以支持扩展，用户可以扩展协议，实现部分自定义的子协议，如支持压缩、加密等。</p><p>WebSocket通信数据格式比较轻量，用于协议控制的数据包头部相对较小，网络开销小，而HTTP通信每次都要携带完整的头部，网络开销较大(<code>HTTP/2.0</code>使用二进制帧进行数据传输，还支持头部压缩，减少了网络开销)。</p><hr><details class=info><summary>WebSocket的工作过程是什么样的？</summary><div><ol><li>客户端向服务器发送一个HTTP请求，请求头中包含<code>Upgrade: websocket</code>和<code>Sec-WebSocket-Key</code>等字段，表示要求升级协议为WebSocket</li><li>服务器收到这个请求后，会进行升级协议的操作，如果支持 WebSocket，它将回复一个<code>HTTP 101</code>状态码，响应头中包含 ，<code>Connection: Upgrade</code>和<code>Sec-WebSocket-Accept: xxx</code>等字段、表示成功升级到 WebSocket协议</li><li>客户端和服务器之间建立了一个WebSocket连接，可以进行双向的数据传输。数据以帧(frames)的形式进行传送，WebSocket的每条消息可能会被切分成多个数据帧(最小单位)。发送端会将消息切割成多个帧发送给接收端，接收端接收消息帧，并将关联的帧重新组装成完整的消息</li><li>客户端或服务器可以主动发送一个关闭帧，表示要断开连接。另一方收到后，也会回复一个关闭帧，然后双方关闭 TCP 连接</li></ol><p>另外，建立 WebSocket 连接之后，通过心跳机制来保持 WebSocket 连接的稳定性和活跃性。</p></div></details></div></details><h3 id=附加项><a class=anchor href=#附加项>#</a> 附加项</h3><p><span class=exturl data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNjg3OTcwMA==">→从输入URL到页面加载发生了什么</span></p><details class=info><summary>如何获取客户端真实IP？</summary><div><p>获取客户端真实IP的方法有多种，主要分为应用层方法、传输层方法和网络层方法。</p><p><strong>应用层方法</strong> - 通过<span class=exturl data-url=aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWC1Gb3J3YXJkZWQtRm9y>X-Forwarded-Foropen in new window</span>请求头获取，简单方便。不过，这种方法无法保证获取到的是真实IP，这是因为X-Forwarded-For字段可能会被伪造。如果经过多个代理服务器，X-Forwarded-For字段可能会有多个值(附带了整个请求链中的所有代理服务器 IP 地址)。并且，这种方法只适用于HTTP和SMTP协议。</p><p><strong>传输层方法</strong> - 利用 TCP Options 字段承载真实源 IP 信息。这种方法适用于任何基于 TCP 的协议，不受应用层的限制。不过，这并非是 TCP 标准所支持的，所以需要通信双方都进行改造。也就是：对于发送方来说，需要有能力把真实源 IP 插入到 TCP Options 里面。对于接收方来说，需要有能力把 TCP Options 里面的 IP 地址读取出来。也可以通过 Proxy Protocol 协议来传递客户端 IP 和 Port 信息。这种方法可以利用 Nginx 或者其他支持该协议的反向代理服务器来获取真实 IP 或者在业务服务器解析真实 IP。</p><p><strong>网络层方法</strong> - 隧道 + DSR模式。这种方法可以适用于任何协议，就是实施起来会比较麻烦，也存在一定限制，实际应用中一般不会使用这种方法。</p></div></details><div class=tags><a href=/tags/computer-basic/ rel=tag><i class="ic i-tag"></i> 计算机基础</a></div></div><footer><div class=meta><span class=item><span class=icon><i class="ic i-calendar-check"></i></span> <span class=text>更新于</span> <time title="修改时间：2025-09-19 22:24:59" itemprop=dateModified datetime=2025-09-19T22:24:59+08:00>2025-09-19</time></span><span class=item data-path=/computer-science/computer-basic/network/nwpart3/ title=阅读次数><span class=icon><i class="ic i-eye"></i></span> <span class=text>阅读次数</span><span class=waline-pageview-count></span> <span class=text>次</span></span></div><div id=copyright><ul><li class=author><strong>本文作者：</strong> ReverseSacle <i class="ic i-at"><em>@</em></i>逆转天平</li><li class=link><strong>本文链接：</strong> <a href=https://www.reversesacle.com/computer-science/computer-basic/network/nwpart3/ title=计算机网络-第三部分>https://www.reversesacle.com/computer-science/computer-basic/network/nwpart3/</a></li><li class=license><strong>版权声明：</strong> 本站所有文章除特别声明外，均采用 <span class=exturl data-url=aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class=post-nav><div class="item left"><a href=/computer-science/computer-basic/network/nwpart2/ itemprop=url rel=prev data-background-image=https:&#x2F;&#x2F;resa-imgs.oss-accelerate.aliyuncs.com&#x2F;img&#x2F;acg19.webp title=计算机网络-第二部分><span class=type>上一篇</span><span class=category><i class="ic i-flag"></i> 计算机网络</span><h3>计算机网络-第二部分</h3></a></div><div class="item right"><a href=/computer-science/programming/dev-tool/git/ itemprop=url rel=next data-background-image=https:&#x2F;&#x2F;resa-imgs.oss-accelerate.aliyuncs.com&#x2F;img&#x2F;acg4.webp title=分布式版本控制系统Git><span class=type>下一篇</span><span class=category><i class="ic i-flag"></i> 开发工具</span><h3>分布式版本控制系统Git</h3></a></div></div><div class=wrap id=comments><div id=waline-comment></div></div></div><div id=sidebar><div class=inner><div class=panels><div class=inner><div class="contents panel pjax" data-title=文章目录><ol class=toc><li class="toc-item toc-level-2"><a class=toc-link href=#%E8%BF%90%E8%BE%93%E5%B1%82%E4%BC%A0%E8%BE%93%E5%B1%82transport-layer><span class=toc-number>1.</span> <span class=toc-text>运输层&#x2F;传输层(Transport layer)</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%A6%82%E8%BF%B0><span class=toc-number>1.1.</span> <span class=toc-text>概述</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%BF%90%E8%BE%93%E5%B1%82%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%88%86%E7%94%A8><span class=toc-number>1.2.</span> <span class=toc-text>! 运输层端口，复用与分用</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#udp%E5%92%8Ctcp%E7%9A%84%E5%AF%B9%E6%AF%94><span class=toc-number>1.3.</span> <span class=toc-text>! UDP和TCP的对比</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6><span class=toc-number>1.4.</span> <span class=toc-text>! TCP流量控制</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6><span class=toc-number>1.5.</span> <span class=toc-text>! TCP拥塞控制</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#tcp%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%80%89%E6%8B%A9><span class=toc-number>1.6.</span> <span class=toc-text>! TCP超时重传时间的选择</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#tcp%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0><span class=toc-number>1.7.</span> <span class=toc-text>TCP可靠传输的实现</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#tcp%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86><span class=toc-number>1.8.</span> <span class=toc-text>! TCP的运输连接管理</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#tcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%89%E6%8A%A5%E6%96%87%E6%8F%A1%E6%89%8B><span class=toc-number>1.8.1.</span> <span class=toc-text>TCP的连接建立(三报文握手)</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#tcp%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%87%8A%E6%94%BE%E5%9B%9B%E6%8A%A5%E6%96%87%E6%8C%A5%E6%89%8B><span class=toc-number>1.8.2.</span> <span class=toc-text>TCP连接的释放(四报文挥手)</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#tcp%E4%BF%9D%E6%B4%BB%E8%AE%A1%E6%97%B6%E5%99%A8><span class=toc-number>1.8.3.</span> <span class=toc-text>TCP保活计时器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#tcp%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F><span class=toc-number>1.9.</span> <span class=toc-text>! TCP报文段的首部格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%BA%94%E7%94%A8%E5%B1%82application-layer><span class=toc-number>2.</span> <span class=toc-text>应用层(Application layer)</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%A6%82%E8%BF%B0-2><span class=toc-number>2.1.</span> <span class=toc-text>概述</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AF%B9%E7%AD%89%E6%96%B9%E5%BC%8F><span class=toc-number>2.2.</span> <span class=toc-text>客户&#x2F;服务器方式和对等方式</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8clientservercs%E6%96%B9%E5%BC%8F><span class=toc-number>2.2.1.</span> <span class=toc-text>! 客户&#x2F;服务器(Client&#x2F;Server,C&#x2F;S)方式</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%AF%B9%E7%AD%89peer-to-peerp2p%E6%96%B9%E5%BC%8F><span class=toc-number>2.2.2.</span> <span class=toc-text>对等(Peer-to-Peer,P2P)方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AEdhcp><span class=toc-number>2.3.</span> <span class=toc-text>! 动态主机配置协议DHCP</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#dhcp%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B><span class=toc-number>2.3.1.</span> <span class=toc-text>DHCP的工作过程</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#dhcp%E4%B8%AD%E7%BB%A7%E4%BB%A3%E7%90%86><span class=toc-number>2.3.2.</span> <span class=toc-text>DHCP中继代理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9Fdnsdomain-name-system><span class=toc-number>2.4.</span> <span class=toc-text>! 域名系统DNS(Domain Name System)</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E6%A6%82%E8%BF%B0-3><span class=toc-number>2.4.1.</span> <span class=toc-text>概述</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E9%A1%B6%E7%BA%A7%E5%9F%9F%E5%90%8Dtldtop-level-domain><span class=toc-number>2.4.2.</span> <span class=toc-text>顶级域名TLD(Top Level Domain)</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%9F%9F%E5%90%8Ddns%E6%9C%8D%E5%8A%A1%E5%99%A8><span class=toc-number>2.4.3.</span> <span class=toc-text>域名(DNS)服务器</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B><span class=toc-number>2.4.4.</span> <span class=toc-text>域名解析的过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AEftpfile-transfer-protocol><span class=toc-number>2.5.</span> <span class=toc-text>! 文件传送协议FTP(File Transfer Protocol)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6><span class=toc-number>2.6.</span> <span class=toc-text>电子邮件</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AEsmtpsimple-mail-transfer-protocol><span class=toc-number>2.6.1.</span> <span class=toc-text>简单邮件传送协议SMTP(Simple Mail Transfer Protocol)</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9A%84%E4%BF%A1%E6%81%AF%E6%A0%BC%E5%BC%8F><span class=toc-number>2.6.2.</span> <span class=toc-text>电子邮件的信息格式</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%B8%B8%E7%94%A8%E9%82%AE%E4%BB%B6%E6%8E%A5%E6%94%B6%E5%8D%8F%E8%AE%AE><span class=toc-number>2.6.3.</span> <span class=toc-text>常用邮件接收协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%B8%87%E7%BB%B4%E7%BD%91wwwworld-wide-web><span class=toc-number>2.7.</span> <span class=toc-text>! 万维网WWW(World Wide Web)</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AEhttphypertext-transfer-protocol><span class=toc-number>2.7.1.</span> <span class=toc-text>超文本传输协议HTTP(HyperText Transfer Protocol)</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#http%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F><span class=toc-number>2.7.2.</span> <span class=toc-text>HTTP报文格式</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#cookie><span class=toc-number>2.7.3.</span> <span class=toc-text>Cookie</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E4%B8%87%E7%BB%B4%E7%BD%91%E7%BC%93%E5%AD%98%E4%B8%8E%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8><span class=toc-number>2.7.4.</span> <span class=toc-text>万维网缓存与代理服务器</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#https%E5%8D%8F%E8%AE%AEhyper-text-transfer-protocol-secure><span class=toc-number>2.7.5.</span> <span class=toc-text>HTTPS协议(Hyper Text Transfer Protocol Secure)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%E5%8D%8F%E8%AE%AEtelnet><span class=toc-number>2.8.</span> <span class=toc-text>远程登陆协议(Telnet)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%AE%89%E5%85%A8%E5%A4%96%E5%A3%B3%E5%8D%8F%E8%AE%AEsshsecure-shell-protocol><span class=toc-number>2.9.</span> <span class=toc-text>! 安全外壳协议SSH(Secure Shell Protocol)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%AE%9E%E6%97%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AEreal-time-transport-protocol><span class=toc-number>2.10.</span> <span class=toc-text>实时传输协议(Real-time Transport Protocol)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E9%99%84%E5%BD%95><span class=toc-number>3.</span> <span class=toc-text>附录</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#ping><span class=toc-number>3.1.</span> <span class=toc-text>PING</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8Ddigital-signature><span class=toc-number>3.2.</span> <span class=toc-text>! 数字签名(Digital Signature)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6public-key-certificate><span class=toc-number>3.3.</span> <span class=toc-text>! 数字证书(Public key certificate)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#websocket><span class=toc-number>3.4.</span> <span class=toc-text>WebSocket</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E9%99%84%E5%8A%A0%E9%A1%B9><span class=toc-number>3.5.</span> <span class=toc-text>附加项</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title=系列文章><ul><li><a href=/computer-science/computer-basic/network/nwpart1/ rel=bookmark title=计算机网络-第一部分>计算机网络-第一部分</a></li><li><a href=/computer-science/computer-basic/network/nwpart2/ rel=bookmark title=计算机网络-第二部分>计算机网络-第二部分</a></li><li class=active><a href=/computer-science/computer-basic/network/nwpart3/ rel=bookmark title=计算机网络-第三部分>计算机网络-第三部分</a></li></ul></div><div class="overview panel" data-title=站点概览><div class=author itemprop=author itemscope itemtype=http://schema.org/Person><img class=image itemprop=image alt=ReverseSacle data-src=/images/avatar.webp><p class=name itemprop=name>ReverseSacle</p><div class=description itemprop=description>知识书库 & 学习点滴</div></div><nav class=state><div class="item posts"><a href=/archives/ ><span class=count>186</span> <span class=name>文章</span></a></div><div class="item categories"><a href=/categories/ ><span class=count>52</span> <span class=name>分类</span></a></div><div class="item tags"><a href=/tags/ ><span class=count>18</span> <span class=name>标签</span></a></div></nav><div class=social><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JldmVyc2VTYWNsZQ==" title=https:&#x2F;&#x2F;github.com&#x2F;ReverseSacle><i class="ic i-github"></i></span><span class="exturl item email" data-url="bWFpbHRvOnByaXZhdGVAcmV2ZXJzZXNhY2xlLmNvbQ==" title=mailto:private@reversesacle.com><i class="ic i-envelope"></i></span></div><ul class=menu><li class=item><a href=/ rel=section><i class="ic i-home"></i> 首页</a></li><li class="item dropdown"><a href=javascript:void(0);><i class="ic i-feather"></i> 文章</a><ul class=submenu><li class=item><a href=/archives/ rel=section><i class="ic i-list-alt"></i> 归档</a></li><li class=item><a href=/categories/ rel=section><i class="ic i-th"></i> 分类</a></li><li class=item><a href=/tags/ rel=section><i class="ic i-tags"></i> 标签</a></li></ul></li><li class=item><a href=/about/ rel=section><i class="ic i-user"></i> 关于</a></li><li class=item><a href=/friend-links/ rel=section><i class="ic i-heart"></i> 友链</a></li></ul></div></div></div><ul id=quick><li class="prev pjax"><a href=/computer-science/computer-basic/network/nwpart2/ rel=prev title=上一篇><i class="ic i-chevron-left"></i></a></li><li class=up><i class="ic i-arrow-up"></i></li><li class=down><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href=/computer-science/programming/dev-tool/git/ rel=next title=下一篇><i class="ic i-chevron-right"></i></a></li><li class=percent></li></ul></div></div><div class=dimmer></div></div></main><footer id=footer><div class=inner><div class=widgets><div class="rpost pjax"><h2>随机文章</h2><ul><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/dynamic-program/ title="分类于 动态规划">动态规划</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/dynamic-program/combination/ title=动态规划-组合>动态规划-组合</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/two-pointer/ title="分类于 双指针">双指针</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/two-pointer/pattern/ title=双指针-模式>双指针-模式</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/rust/ title="分类于 Rust">Rust</a></div><span><a href=/computer-science/programming/rust/rust-data-structure/linear-structure/doubly-link-list/ title=Rust-双向链表>Rust-双向链表</a></span></li><li class=item><div class=breadcrumb><a href=/categories/general-science-and-technology/ title="分类于 通用科学技术">通用科学技术</a><i class="ic i-angle-right"></i> <a href=/categories/general-science-and-technology/pc/ title="分类于 通用技术之PC端">通用技术之PC端</a><i class="ic i-angle-right"></i> <a href=/categories/general-science-and-technology/pc/router/ title="分类于 路由器">路由器</a></div><span><a href=/general-science-and-technology/pc/router/customizing-firmware-for-openwrt/ title=自定义Openwrt固件的本地编译操作详解>自定义Openwrt固件的本地编译操作详解</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/computer-basic/ title="分类于 计算机基础">计算机基础</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/computer-basic/computer-composition-principles/ title="分类于 计算机组成原理">计算机组成原理</a></div><span><a href=/computer-science/computer-basic/composition/ccppart3/ title=计算机组成原理-CSAPP-第三部分>计算机组成原理-CSAPP-第三部分</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/algorithm/ title="分类于 算法">算法</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/algorithm/sort/ title="分类于 序列重组">序列重组</a></div><span><a href=/computer-science/programming/algorithm/sort/insertion-sort/ title=插入排序>插入排序</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/network-programming/ title="分类于 网络编程">网络编程</a></div><span><a href=/computer-science/programming/network-programming/thread-synchronization/ title=Linux线程同步>Linux线程同步</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/seqlist/ title="分类于 顺序表">顺序表</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/seqlist/pattern/ title=顺序表-模式>顺序表-模式</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/python/ title="分类于 Python">Python</a></div><span><a href=/computer-science/programming/python/flask-basic/ title=Python后端框架Flask基础>Python后端框架Flask基础</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a></div><span><a href=/computer-science/programming/c-language/c-data-structure/nonlinear-structure/tree-forest/ title=C语言-孩子兄弟树>C语言-孩子兄弟树</a></span></li></ul></div><div><h2>最新评论</h2><ul id=waline-recent></ul></div></div><div class=status><div class=copyright>&copy; 2021 – <span itemprop=copyrightYear>2025</span><span class=with-love><i class="ic i-sakura rotate"></i></span> <span class=author itemprop=copyrightHolder>ReverseSacle @ ReverseSacle-Blog</span></div><div class=count><i class="ic i-clock" aria-hidden=true></i> <span id=time align=center>载入时间中...<script defer>var now=new Date;function createtime(){var n=new Date("2021-11-16 22:30:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("time").innerHTML="已经过 "+dnum+" 天 "+hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></span><span class=post-meta-item-icon>|&nbsp<i class="ic i-chart-area"></i></span> <span title=站点总字数>2.1m 字</span> <span class=post-meta-item-icon>|&nbsp<i class="ic i-coffee"></i></span> <span title=站点阅读时长>40:40</span></div></div></div></footer></div><script data-config>var LOCAL={path:"computer-science/computer-basic/network/nwpart3/",favicon:{show:"ReverseSacle-Blog",hide:"ReverseSacle-Blog"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},waline:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src=https://polyfill.alicdn.com/v3/polyfill.min.js></script><script src=https://cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1.16.0/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js></script><script src=/js/app.js></script></body></html>