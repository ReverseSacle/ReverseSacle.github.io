<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content=#222><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=icon type=image/ico sizes=48x48 href=/images/favicon.ico><link rel=alternate type=application/rss+xml title=逆转天平 href=https://www.reversesacle.com/rss.xml><link rel=alternate type=application/atom+xml title=逆转天平 href=https://www.reversesacle.com/atom.xml><link rel=alternate type=application/json title=逆转天平 href=https://www.reversesacle.com/feed.json><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel=stylesheet href=/css/app.css><meta name=description content=编程语言><link rel=canonical href=https://www.reversesacle.com/computer-science/programming/c-language/basis/c++/cpppart3/ ><title>C++基础知识-第三部分-C++11标准 - C++基础 - C语言 - 编程 - 计算机科学 | ReverseSacle-Blog</title><meta name=generator content="Hexo 6.3.0"></head><body itemscope itemtype=http://schema.org/WebPage><div id=loading><div class=dotloader><div class=dot></div><div class=dot></div><div class=dot></div><div class=dot></div><div class=dot></div></div></div><div id=container><header id=header itemscope itemtype=http://schema.org/WPHeader><div class=inner><div id=brand><div class=pjax><h1 itemprop="name headline">C++基础知识-第三部分-C++11标准</h1><div class=meta><span class=item title="创建时间：2022-02-18 18:53:22"><span class=icon><i class="ic i-calendar"></i></span> <span class=text>发表于</span> <time itemprop="dateCreated datePublished" datetime=2022-02-18T18:53:22+08:00>2022-02-18</time></span><span class=item title=本文字数><span class=icon><i class="ic i-pen"></i></span> <span class=text>本文字数</span> <span>36k</span> <span class=text>字</span></span><span class=item title=阅读时长><span class=icon><i class="ic i-clock"></i></span> <span class=text>阅读时长</span> <span>42 分钟</span></span></div></div></div><nav id=nav><div class=inner><div class=toggle><div class=lines role=navigation aria-label=切换导航栏><span class=line></span><span class=line></span><span class=line></span></div></div><ul class=menu><li class="item title"><a href=/ rel=start>ReverseSacle-Blog</a></li></ul><ul class=right><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id=imgs class=pjax><ul><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg6.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg11.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg21.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg16.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg3.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg10.webp></li></ul></div></header><div id=waves><svg class=waves xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink viewBox="0 24 150 28" preserveAspectRatio=none shape-rendering=auto><defs><path id=gentle-wave d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352z"/></defs><g class=parallax><use xlink:href=#gentle-wave x=48 y=0 /><use xlink:href=#gentle-wave x=48 y=3 /><use xlink:href=#gentle-wave x=48 y=5 /><use xlink:href=#gentle-wave x=48 y=7 /></g></svg></div><main><div class=inner><div id=main class=pjax><div class="article wrap"><div class=breadcrumb itemscope itemtype=https://schema.org/BreadcrumbList><i class="ic i-home"></i> <span><a href=/ >首页</a></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/ itemprop=item rel=index title="分类于 计算机科学"><span itemprop=name>计算机科学</span></a><meta itemprop=position content=1></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/programming/ itemprop=item rel=index title="分类于 编程"><span itemprop=name>编程</span></a><meta itemprop=position content=2></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/programming/c-language/ itemprop=item rel=index title="分类于 C语言"><span itemprop=name>C语言</span></a><meta itemprop=position content=3></span><i class="ic i-angle-right"></i> <span class=current itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/programming/c-language/cpp-basic/ itemprop=item rel=index title="分类于 C++基础"><span itemprop=name>C++基础</span></a><meta itemprop=position content=4></span></div><article itemscope itemtype=http://schema.org/Article class="post block" lang=zh-CN><link itemprop=mainEntityOfPage href=https://www.reversesacle.com/computer-science/programming/c-language/basis/c++/cpppart3/ ><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content=/images/avatar.webp><meta itemprop=name content=ReverseSacle><meta itemprop=description content="所见即所得，所思即所行, 知识书库 & 学习点滴"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content=逆转天平></span><div class="body md" itemprop=articleBody><h2 id=列表初始化list-initialization><a class=anchor href=#列表初始化list-initialization>#</a> 列表初始化(List-initialization)</h2><p>可以把值写在花括号中，等于号也可省略，用于简化对象的初始化，可以用于数组、类类型、甚至是内置类型。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">15</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">int</span> b <span class="token punctuation">&#123;</span><span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id=新增数据类型及特性><a class=anchor href=#新增数据类型及特性>#</a> 新增数据类型及特性</h2><p><code>long long</code> - 8个字节</p><p><code>long double</code> - 字节不少于double，没有具体说明，不同的编译器字节可能不一样</p><p><strong>原始字面量</strong></p><ul><li>直接表示字符串的实际含义，字符串内转义字符和链接的作用无效</li><li>语法1 - <code>R&quot;字符串内容&quot;</code></li><li>语法2 - <code>R&quot;xxx1(字符串内容)xxx2&quot;</code> - <code>xxx1</code>与<code>xxx2</code>必须一致，用于表示注释，实际输出时只有括号内的字符串内容</li></ul><p>字符串字面值(常量字符串)可以通过空格或换行符进行连接，而形成一个连续的字符串。这被称为字符串字面值的拼接或连接。<code>C++</code>的字符串字面值拼接是自<code>C++11</code>标准引入的特性，因此只要使用了支持<code>C++11</code>及以上标准的编译器，就应该支持字符串字面值的拼接。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str1 <span class="token operator">=</span> <span class="token string">"Hello, "</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str2 <span class="token operator">=</span> <span class="token string">"world!"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> result1 <span class="token operator">=</span> str1 <span class="token string">" "</span> str2<span class="token punctuation">;</span> <span class="token comment">// 等价于 "Hello, world!"</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> result2 <span class="token operator">=</span> <span class="token string">"Hello, "</span> <span class="token string">"world!"</span><span class="token punctuation">;</span> <span class="token comment">// 也等价于 "Hello, world!"</span></pre></td></tr></table></figure><h2 id=auto类型推导><a class=anchor href=#auto类型推导>#</a> auto类型推导</h2><p><code>C++11</code>赋予auto关键字新的含义，使用它来做自动类型推导，编译器会在编译期间自动推导出变量的类型，不用手动指明变量的数据类型了，常用于定义迭代器。</p><p><strong>限制条件</strong></p><ul><li>使用 auto 的时候必须对变量进行初始化</li><li>不能在函数的参数中使用</li><li>不能作用于类的非静态成员变量(也就是没有 static 关键字修饰的成员变量)中</li><li>不能定义数组</li><li>不能作用于模板参数</li></ul><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// auto的使用案例</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">auto</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">int</span> n2 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">auto</span><span class="token operator">*</span> n_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>n2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token comment">// 定义迭代器</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    vector<span class="token operator">&lt;</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> v<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    </pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token comment">// vector&lt; vector&lt;int> >::iterator i = v.begin();</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token keyword">auto</span> i <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    </pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=17></td><td><pre></pre></td></tr><tr><td data-num=18></td><td><pre></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token comment">// 不能定义数组,以下为错误案例</span></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token comment">// char url[] = "http://c.biancheng.net/";</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token comment">// auto str[] = url;</span></pre></td></tr><tr><td data-num=22></td><td><pre></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token comment">/*</span></pre></td></tr><tr><td data-num=24></td><td><pre><span class="token comment">template &lt;typename T></span></pre></td></tr><tr><td data-num=25></td><td><pre><span class="token comment">class A&#123;</span></pre></td></tr><tr><td data-num=26></td><td><pre><span class="token comment">    //TODO:</span></pre></td></tr><tr><td data-num=27></td><td><pre><span class="token comment">&#125;;</span></pre></td></tr><tr><td data-num=28></td><td><pre><span class="token comment"></span></pre></td></tr><tr><td data-num=29></td><td><pre><span class="token comment">int  main()</span></pre></td></tr><tr><td data-num=30></td><td><pre><span class="token comment">&#123;</span></pre></td></tr><tr><td data-num=31></td><td><pre><span class="token comment">    A&lt;int> C1;</span></pre></td></tr><tr><td data-num=32></td><td><pre><span class="token comment">    A&lt;auto> C2 = C1;  //错误</span></pre></td></tr><tr><td data-num=33></td><td><pre><span class="token comment">    return 0;</span></pre></td></tr><tr><td data-num=34></td><td><pre><span class="token comment">&#125;</span></pre></td></tr><tr><td data-num=35></td><td><pre><span class="token comment">*/</span></pre></td></tr></table></figure><h2 id=使用using定义别名><a class=anchor href=#使用using定义别名>#</a> 使用using定义别名</h2><p>使用typedef重定义类型是有一些限制的，比如，无法重定义一个模板。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// typedef无法做到下面这行代码</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token comment">// typedef std::map&lt;std::string, int> StringIntMap;</span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment">// 使用using定义函数指针</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">using</span> FuncPtr <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token keyword">using</span> StringMap <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> T<span class="token operator">></span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id=for循环基于范围的循环><a class=anchor href=#for循环基于范围的循环>#</a> for循环(基于范围的循环)</h2><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span>declaration <span class="token operator">:</span> expression<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token comment">// loop body</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment">// declaration - 用于声明一个变量，该变量在每次迭代中会被初始化为容器中当前元素的值</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment">// expression - 是一个返回容器的表达式，该容器将会被遍历。</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">char</span> arc<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"http://c.biancheng.net/cplus/11/"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token comment">// for循环遍历普通数组</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>arc<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=11></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> arc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    </pre></td></tr><tr><td data-num=15></td><td><pre>    vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token function">myvector</span><span class="token punctuation">(</span>arc<span class="token punctuation">,</span>arc<span class="token operator">+</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=16></td><td><pre>    vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>iterator iter<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre>    <span class="token comment">// for循环遍历 vector 容器</span></pre></td></tr><tr><td data-num=18></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span>iter <span class="token operator">=</span> myvector<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> myvector<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>iter<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=19></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>iter<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=20></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=21></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=22></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=23></td><td><pre></pre></td></tr><tr><td data-num=24></td><td><pre><span class="token keyword">int</span> <span class="token function">main2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=25></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=26></td><td><pre>    <span class="token keyword">char</span> arc<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"http://c.biancheng.net/cplus/11/"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=27></td><td><pre>    <span class="token comment">// for循环遍历普通数组</span></pre></td></tr><tr><td data-num=28></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> ch <span class="token operator">:</span> arc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=29></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> ch<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=30></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=31></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token char">'!'</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=32></td><td><pre>    </pre></td></tr><tr><td data-num=33></td><td><pre>    vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token function">myvector</span><span class="token punctuation">(</span>arc<span class="token punctuation">,</span> arc <span class="token operator">+</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=34></td><td><pre>    </pre></td></tr><tr><td data-num=35></td><td><pre>    <span class="token comment">// for循环遍历 vector 容器</span></pre></td></tr><tr><td data-num=36></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> ch <span class="token operator">:</span> myvector<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=37></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> ch<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=38></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=39></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token char">'!'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=40></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=41></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id=新增结构体特性><a class=anchor href=#新增结构体特性>#</a> 新增结构体特性</h2><p><ins><strong>定义结构体时可以指定初始值</strong></ins></p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">ss</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"xxx"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>如果创建的结构体变量没有初始化，编译会报错(Linux除外)，而Linux的成员变量会是随机值。</p><p><code>memset(结构体地址,0,结构体大小)</code> - 把结构体成员值清零，当有堆内的成员变量时不可使用</p><p><ins><strong>结构体中能添加自定义函数</strong></ins></p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">ss</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id=新增内存管理操作特性><a class=anchor href=#新增内存管理操作特性>#</a> 新增内存管理操作特性</h2><p><code>C++</code>中void指针类型不允许隐式转换成其他类型，在重载的情况下，用0或NULL表示空指针会产生歧义，为此建议用<code>nullptr</code>表示空指针，也就是<code>(void *)0</code>，并保证<code>nullptr</code>任何情况下都代表空指针。</p><details class=info><summary>nullptr和null的区别？</summary><div><p><code>NULL</code>是C语言中用于表示空指针的宏，通常被定义为整数零。在<code>C++</code>中，<code>NULL</code>通常也被定义为整数零，所以它可以被用于初始化指针。由于<code>NULL</code>是一个宏，而不是一个真正的空指针常量，<code>NULL</code>可能会被隐式转换为其他指针类型，这可能导致一些类型转换问题 。</p><p><code>nullptr</code>是<code>C++11</code>引入的空指针常量。它是一个关键字，具有明确定义的类型，可以用于表示任何指针类型的空指针。<code>nullptr</code>的类型是<code>nullptr_t</code>，它是一个独立的类型，不同于任何其他指针类型。这意味着<code>nullptr</code>不能被隐式转换为其他指针类型，从而避免了一些潜在的问题。</p></div></details><h2 id=新增类和对象特性><a class=anchor href=#新增类和对象特性>#</a> 新增类和对象特性</h2><h3 id=新增定义><a class=anchor href=#新增定义>#</a> 新增定义</h3><p>可以为类的成员指定缺省值。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Person</span> </pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token comment">// 使用 C++11 语法为成员变量指定默认值</span></pre></td></tr><tr><td data-num=8></td><td><pre>    std<span class="token double-colon punctuation">::</span>string name <span class="token operator">=</span> <span class="token string">"Unknown"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><details class=info><summary>initializer_list 列表初始化是什么？</summary><div><p><code>std::initializer_list</code>是<code>C++11</code>引入的一种特性，用于支持列表初始化。这是一种使用花括号<code>&#123;&#125;</code>进行初始化的语法，允许以一种简洁且直观的方式初始化对象。<code>std::initializer_list</code> 通常用于构造函数和函数参数，以便能够接受初始化列表作为参数。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;initializer_list></span></span></pre></td></tr><tr><td data-num=4></td><td><pre> </pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">S</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">></span> v<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token function">S</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">></span> l<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">v</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=9></td><td><pre>         std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"constructed with a "</span> <span class="token operator">&lt;&lt;</span> l<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"-element list\n"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token keyword">void</span> <span class="token function">append</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">></span> l<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=12></td><td><pre>        v<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> T<span class="token operator">*</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token operator">></span> <span class="token function">c_arr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=15></td><td><pre>        <span class="token comment">// 在 return 语句中复制列表初始化，这不使用 std::initializer_list</span></pre></td></tr><tr><td data-num=16></td><td><pre>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token operator">&amp;</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>              </pre></td></tr><tr><td data-num=17></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=19></td><td><pre> </pre></td></tr><tr><td data-num=20></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token keyword">void</span> <span class="token function">templated_fn</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=22></td><td><pre> </pre></td></tr><tr><td data-num=23></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=24></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=25></td><td><pre>    S<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 复制初始化</span></pre></td></tr><tr><td data-num=26></td><td><pre>    s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 函数调用中的列表初始化</span></pre></td></tr><tr><td data-num=27></td><td><pre></pre></td></tr><tr><td data-num=28></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The vector size is now "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">c_arr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> <span class="token string">" ints:\n"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=29></td><td><pre></pre></td></tr><tr><td data-num=30></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> n <span class="token operator">:</span> s<span class="token punctuation">.</span>v<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=31></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=32></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=33></td><td><pre></pre></td></tr><tr><td data-num=34></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Range-for over brace-init-list: \n"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=35></td><td><pre></pre></td></tr><tr><td data-num=36></td><td><pre>    <span class="token comment">// auto 的规则令此带范围 for 工作</span></pre></td></tr><tr><td data-num=37></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=38></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=39></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=40></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=41></td><td><pre></pre></td></tr><tr><td data-num=42></td><td><pre>    <span class="token keyword">auto</span> al <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// auto 的特殊规则</span></pre></td></tr><tr><td data-num=43></td><td><pre></pre></td></tr><tr><td data-num=44></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The list bound to auto has size() = "</span> <span class="token operator">&lt;&lt;</span> al<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=45></td><td><pre>    <span class="token comment">// 编译错误！“ &#123;1, 2, 3&#125; ”不是表达式，它无类型，故 T 无法推导</span></pre></td></tr><tr><td data-num=46></td><td><pre>    <span class="token comment">//templated_fn(&#123;1, 2, 3&#125;); </span></pre></td></tr><tr><td data-num=47></td><td><pre></pre></td></tr><tr><td data-num=48></td><td><pre>    <span class="token generic-function"><span class="token function">templated_fn</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// OK</span></pre></td></tr><tr><td data-num=49></td><td><pre>    <span class="token generic-function"><span class="token function">templated_fn</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 也 OK</span></pre></td></tr><tr><td data-num=50></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></div></details><details class=info><summary>=default是什么？</summary><div><p><code>=default</code>是一个特殊的语法，用于指示编译器生成默认的特殊成员函数(比如默认构造函数、拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符或析构函数)。</p><p>通过使用<code>=default</code>，告诉编译器使用默认的实现，而不是用户自己提供实现。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token comment">// 使用默认析构函数</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token operator">~</span><span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment">// 在一个类中声明了一个析构函数,只想使用编译器生成的默认析构函数</span></pre></td></tr></table></figure></div></details><details class=info><summary>=delete是什么？</summary><div><p><code>=delete</code>是另一个特殊的语法，用于指示编译器删除(禁用)某个特殊成员函数或者重载运算符。通过使用<code>=delete</code>，告诉编译器不生成该函数的默认实现，从而明确地阻止特定操作。使用<code>=delete</code>的主要目的是防止某些危险或者不合适的操作发生。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">class</span> <span class="token class-name">NonCopyable</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token comment">// 默认构造函数</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token function">NonCopyable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token comment">// 移动构造函数</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token function">NonCopyable</span><span class="token punctuation">(</span>NonCopyable<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token comment">// 移动赋值运算符</span></pre></td></tr><tr><td data-num=10></td><td><pre>    NonCopyable<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>NonCopyable<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token comment">// 删除拷贝构造函数</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token function">NonCopyable</span><span class="token punctuation">(</span><span class="token keyword">const</span> NonCopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token comment">// 删除拷贝赋值运算符</span></pre></td></tr><tr><td data-num=16></td><td><pre>    NonCopyable<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> NonCopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token comment">/*</span></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token comment"> * NonCopyable类允许默认的构造和移动操作，</span></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token comment"> * 但明确地删除了拷贝构造函数和拷贝赋值运算符。</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token comment"> * 这样，当试图对该类执行拷贝操作，编译器将生成错误。</span></pre></td></tr><tr><td data-num=22></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure></div></details><h3 id=新增封装特性><a class=anchor href=#新增封装特性>#</a> 新增封装特性</h3><h4 id=移动构造语句><a class=anchor href=#移动构造语句>#</a> 移动构造语句</h4><p>移动构造函数是一个特殊的构造函数，其参数是右值引用（<code>T&amp;&amp;</code>）。右值引用允许你将资源的所有权从一个对象转移到另一个对象。用于高效地转移资源的所有权。与拷贝构造函数不同，移动构造函数通过“转移”而非“复制”资源，避免了不必要的资源开销。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyClass</span> </pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token comment">// 移动构造函数</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token function">MyClass</span><span class="token punctuation">(</span>MyClass<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> </pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Move constructor"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>        <span class="token comment">// 转移资源的所有权</span></pre></td></tr><tr><td data-num=9></td><td><pre>        data <span class="token operator">=</span> other<span class="token punctuation">.</span>data<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>        other<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// 让原对象失去对资源的所有权</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=12></td><td><pre></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token comment">// ...</span></pre></td></tr><tr><td data-num=14></td><td><pre></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token keyword">char</span><span class="token operator">*</span> data<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><details class=info><summary>noexcept关键字？</summary><div><p>用于标记函数或表达式是否会抛出异常。它的主要作用是告知编译器某个函数在执行过程中不会抛出异常，从而允许编译器进行更多优化。</p></div></details><h4 id=委托构造语句><a class=anchor href=#委托构造语句>#</a> 委托构造语句</h4><p>调用同一个类中的另一个构造函数来完成对象的初始化工作，从而避免重复的代码，这种机制使得可以通过一个构造函数的实现来重用其他构造函数的实现。</p><p><strong>创建方法</strong></p><ul><li><strong>定义一个构造函数</strong>，在该构造函数内部调用另一个构造函数。</li><li><strong>委托构造函数</strong>必须调用类中的另一个构造函数，这样就避免了在多个构造函数中编写相似的代码。</li></ul><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token comment">// 构造函数1</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x_</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>        <span class="token comment">// 初始化代码</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=7></td><td><pre></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token comment">// 委托构造函数2</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>        <span class="token comment">// 可以在这里添加额外的初始化代码</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=12></td><td><pre></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token keyword">int</span> x_<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id=强制转换运算符重载><a class=anchor href=#强制转换运算符重载>#</a> 强制转换运算符重载</h4><p><code>C++11</code>标准中消除了<code>C++98</code>标准中不能使用explicit转换函数的限制，可以将其用于将转换函数声明为显示。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Person</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">int</span> age<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">age</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=11></td><td><pre></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token comment">// 重载了(int)变量名的强制类型转换</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> age<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token keyword">operator</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> age<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token keyword">operator</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> age<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=17></td><td><pre></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=20></td><td><pre>    Person p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=21></td><td><pre>    <span class="token keyword">int</span> a <span class="token operator">=</span> p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=22></td><td><pre>    </pre></td></tr><tr><td data-num=23></td><td><pre>    string b <span class="token operator">=</span> g<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=24></td><td><pre>    <span class="token keyword">double</span> c <span class="token operator">=</span> g<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=25></td><td><pre>    </pre></td></tr><tr><td data-num=26></td><td><pre>    <span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=27></td><td><pre>    string b1 <span class="token operator">=</span> <span class="token punctuation">(</span>stirng<span class="token punctuation">)</span>g<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=28></td><td><pre>    <span class="token keyword">double</span> c1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>g<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=29></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=30></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><details class=info><summary>explicit关键字有什么用？</summary><div><p>主要作用是防止构造函数或转换函数在不合适的情况下被隐式调用。使用<code>explicit</code>关键字可以防止编译器进行隐式类型转换，从而提高代码的安全性和可读性。</p><p>通常情况下，如果一个构造函数只有一个参数，那么它将允许被用于执行隐式类型转换。通过在构造函数声明前加上 <code>explicit</code> 关键字，可以禁止这种隐式转换。</p></div></details><details class=info><summary>构造函数的using声明是什么？</summary><div><p><code>using</code>声明在构造函数中的使用是<code>C++11</code>引入的一个特性，它可以用来继承基类构造函数或者在派生类中重新定义构造函数。这种特性通常被称为构造函数的<code>using</code>声明，也可以称为构造函数的继承。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Base</span> </pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">value</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">int</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> </pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token comment">// 继承基类构造函数</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token comment">// 可以添加额外的构造逻辑</span></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">additionalValue</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=17></td><td><pre></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=19></td><td><pre>    <span class="token keyword">int</span> additionalValue<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=21></td><td><pre></pre></td></tr><tr><td data-num=22></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=23></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=24></td><td><pre>    <span class="token comment">// 使用 Derived 类的构造函数</span></pre></td></tr><tr><td data-num=25></td><td><pre>    Derived <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=26></td><td><pre>    </pre></td></tr><tr><td data-num=27></td><td><pre>    <span class="token comment">// 使用继承的基类构造函数</span></pre></td></tr><tr><td data-num=28></td><td><pre>    Derived <span class="token function">d2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=29></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=30></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这个例子中，<code>Derived</code>类继承了<code>Base</code>类的构造函数，使用<code>using Base::Base;</code>语句。这意味着<code>Derived</code>类的对象可以使用<code>Base</code>类中的构造函数，使得<code>Derived</code>类的构造函数变得更加灵活。</p><p><code>using Base::Base;</code> 中的<code>Base::Base</code>是基类的构造函数的名字。它将基类的构造函数引入到派生类中。</p><p><code>using</code>声明的效果是将基类中的构造函数引入到派生类的作用域中，使得派生类中也可以直接使用基类构造函数。使用<code>using</code>声明不仅仅可以用于构造函数，也可以用于其他成员函数。在派生类中，可以通过<code>using</code>声明继承多个基类的构造函数。</p></div></details><details class=info><summary>override关键字有什么用？</summary><div><p><code>override</code>是<code>C++11</code>引入的关键字，用于显式标记派生类中的成员函数，以确保其覆盖(重写)基类中的虚函数。使用<code>override</code>关键字可以提高代码的可读性，并在编译时捕获一些潜在的错误。主要用途有，</p><ul><li><p><strong>覆盖虚函数</strong> - <code>override</code>关键字用于明确指示一个成员函数意图覆盖其基类中的虚函数</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Base</span> </pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>        <span class="token comment">// 基类的虚函数实现</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> </pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token comment">// 使用 override 关键字确保 myFunction 覆盖了基类的虚函数</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=14></td><td><pre>        <span class="token comment">// 派生类的虚函数实现</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token comment">// 如果派生类中的函数没有成功覆盖基类中的虚函数，编译器将生成一条错误消息。</span></pre></td></tr></table></figure></li><li><p><strong>增强可读性</strong> - 使用<code>override</code>关键字可以提高代码的可读性，让读者清楚地知道某个函数是有意覆盖基类中的虚函数</p></li><li><p><strong>编译时检查</strong> - 编译器在遇到<code>override</code>关键字时会检查基类中是否存在相应的虚函数，以及函数签名是否匹配。这种编译时检查可以捕获一些潜在的错误，例如函数签名不匹配</p></li></ul></div></details><details class=info><summary>final关键字有什么用？</summary><div><p><code>final</code>是<code>C++11</code>引入的关键字，用于修饰类、虚函数或虚继承，具体用途有</p><ul><li><p><strong>修饰类</strong> - 在类的声明中使用<code>final</code>关键字可以阻止其他类继承它。这样的类被称为final类，不能被其他类派生</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token keyword">final</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token comment">// 类的定义</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment">// 下面的代码将导致编译错误，因为 Derived 试图继承 final 类 Base</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token comment">// ...</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p><strong>修饰虚函数</strong> - 在虚函数的声明中使用<code>final</code>关键字可以阻止派生类覆盖该虚函数。这样的虚函数被称为final虚函数</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Base</span> </pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">final</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>        <span class="token comment">// 虚函数的定义</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> </pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token comment">// 下面的代码将导致编译错误，因为它试图覆盖 final 虚函数 myFunction</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=14></td><td><pre>        <span class="token comment">// ...</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p><strong>修饰虚继承</strong> - 在虚继承中，使用<code>final</code>关键字可以阻止派生类再次被继承。这对于维护继承关系和防止钻石问题非常有用</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">C</span></span> </pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token comment">// 此时A被虚继承，下面的代码将导致编译错误</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token comment">// 因为B和C都是A的虚基类，D不允许再次继承A</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token comment">// 此时A被声明为final，阻止了进一步的派生</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token comment">// 此处的final关键字对于解决Diamond Problem很有帮助</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token comment">// 如果没有final，则编译器会生成A的两份副本，导致二义性</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token keyword">void</span> <span class="token function">someFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">final</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=14></td><td><pre>        <span class="token comment">// ...</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li></ul></div></details><h2 id=新增异常处理机制><a class=anchor href=#新增异常处理机制>#</a> 新增异常处理机制</h2><details class=info><summary>noexcept关键字有什么用？</summary><div><p><code>noexcept</code>是<code>C++11</code>引入的关键字，用于指定一个函数是否抛出异常。它用于增强程序的异常安全性和性能，以及帮助优化编译器生成更高效的代码。主要用途有</p><ul><li><p><strong>异常安全性</strong> - 在一些情况下，我们希望确保某个函数不会抛出异常，以保证程序的异常安全性。通过在函数声明或定义中使用 <code>noexcept</code> 关键字，我们可以明确表达该函数不会引发异常</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token comment">// 不会引发异常的代码</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p><strong>性能优化</strong> - 一些编译器可以利用<code>noexcept</code>信息进行性能优化。例如，当编译器知道一个函数不会抛出异常时，它可能会生成更加紧凑和高效的代码</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token comment">// 不会引发异常的代码</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p><strong>noexcept运算符</strong> - 在运行时，可以使用<code>noexcept</code>运算符来检查表达式是否可能引发异常。它返回一个<code>bool</code>值，表示给定的表达式是否可能引发异常</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">bool</span> canThrow <span class="token operator">=</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li></ul><p>使用 <code>noexcept</code> 并不意味着永远不会有异常发生。它只是对编译器和其他代码提供了一些信息，用于处理异常或进行性能优化。</p><p><code>noexcept</code> 关键字可以用于函数声明、函数定义和 lambda 表达式。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 函数声明</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment">// 函数定义</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token comment">// 函数体</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=8></td><td><pre></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token comment">// lambda 表达式</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token keyword">auto</span> myLambda <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token comment">// lambda 表达式体</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure></div></details><h2 id=新增模板泛型特性><a class=anchor href=#新增模板泛型特性>#</a> 新增模板(泛型)特性</h2><h3 id=支持函数的默认模板参数><a class=anchor href=#支持函数的默认模板参数>#</a> 支持函数的默认模板参数</h3><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token operator">></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token comment">// ...</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">97</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id=decltype关键字><a class=anchor href=#decltype关键字>#</a> decltype关键字</h3><ul><li>是declare type的缩写，译为<strong>声明类型</strong></li></ul><ul><li>语法 - <code>decltype(exp) var</code></li><li>用于在编译时期进行自动类型推导，其规则有<ul><li>如果exp是一个不被括号包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么decltype(exp)的类型就和exp一致，包括const等限定符</li><li>如果exp是函数调用，那么decltype(exp)的类型就和函数返回值的类型一致(函数不能返回void，但可以返回<code>void *</code>)</li><li>如果exp是一个左值，或者被括号包围，那么decltype(exp)的类型就是exp的引用。假设 exp 的类型为 T，那么decltype(exp)的类型就是 T&amp;</li><li>如果上述条件都不满足，则decltype(exp)的类型与expression的类型相同</li></ul></li></ul><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token comment">// 第一条规则</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">short</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">short</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">short</span><span class="token operator">&amp;</span> ra <span class="token operator">=</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token keyword">decltype</span><span class="token punctuation">(</span>ra<span class="token punctuation">)</span> da <span class="token operator">=</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    </pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token comment">// 第二条规则</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> daa <span class="token operator">=</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token keyword">decltype</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span> <span class="token operator">*</span>daaa <span class="token operator">=</span> func<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    </pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token comment">// 第三条规则</span></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">)</span> dd <span class="token operator">=</span> func<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id=函数后置返回类型><a class=anchor href=#函数后置返回类型>#</a> 函数后置返回类型</h3><ul><li>auto占位符写法 - <code>auto func(int x,double y) -&gt; int</code></li><li><code>int func(int x,double y)</code>写法等于<code>auto func(int x,double y) -&gt; int</code></li></ul><details class=info><summary>auto关键字与decltype关键字有什么用？(有了auto关键字为什么还需要decltype关键字?)</summary><div><p><code>auto</code>关键字用于自动推导变量的类型，不能用于函数参数的声明，编译器会根据变量的初始化表达式来确定其类型。这可以减少代码中的类型冗余，特别是在使用模板、迭代器和复杂类型时。</p><p><code>decltype</code>关键字用于获取表达式的类型，而不执行实际的表达式。它通常与<code>auto</code>结合使用，可以用于从一个表达式中提取类型，然后将该类型用于定义变量。</p></div></details><details class=info><summary>auto类型推断的原理是什么？</summary><div><p>auto使用的是<strong>模板实参推断</strong>(Template Argument Deduction)的机制。</p><p>从函数实参来确定模板实参的过程被称为模板实参推断(template argument deduction)。在使用类模板创建对象时，程序员需要显式的指明实参(也就是具体的类型)，而对于函数模板，调用函数时可以不显式地指明实参,编译器会根据传入的实参类型来自动推导出模板实参类型。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Container</span><span class="token operator">></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">void</span> <span class="token function">useContainer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Container<span class="token operator">&amp;</span> container<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">auto</span> pos <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">!=</span> container<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>        <span class="token keyword">auto</span><span class="token operator">&amp;</span> element <span class="token operator">=</span> <span class="token operator">*</span>pos<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>        … <span class="token comment">// 对元素进行操作</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=11></td><td><pre></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token comment">// auto pos = container.begin()的推断等价于如下调用模板的推断</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token keyword">void</span> <span class="token function">deducePos</span><span class="token punctuation">(</span>T pos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token function">deducePos</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token comment"> * auto被一个虚构的模板类型参数T替代，</span></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token comment"> * 然后进行推断，即相当于把变量设为一个函数参数，</span></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token comment"> * 将其传递给模板并推断为实参，</span></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token comment"> * auto相当于利用了其中进行的实参推断，承担了模板参数T的作用。</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure></div></details><h3 id=可变参数列表变参模板><a class=anchor href=#可变参数列表变参模板>#</a> 可变参数列表(变参模板)</h3><p><code>C++</code>中的可变参数列表是一种用于处理可变数量和类型参数的特性，通常通过使用变参模板(variadic templates)来实现。这提供了一种比传统的C风格可变参数更安全和类型更灵活的方式。</p><p><code>C++</code>中的变参模板使用了模板参数包(template parameter pack)，它允许在模板中接受任意数量的模板参数。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 可变参数函数模板</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> T<span class="token operator">></span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">void</span> <span class="token function">vair_fun</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token comment">//函数体</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment"> * - 递归终止函数</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment"> * 在递归处理可变参数列表时，递归终止函数提供了一个终止条件，</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token comment"> * 确保递归在达到一定条件时停止。本例子中，</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token comment"> * 终止条件是当可变参数列表为空时，递归终止函数不再递归调用，从而结束整个递归过程。</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token comment">**/</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token keyword">void</span> <span class="token function">processArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token comment">// 什么都不做，递归终止条件</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=13></td><td><pre></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token comment"> * 在函数体内，通过使用递归调用processArgs(args...)，</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token comment"> * 可以逐个处理参数。这种方式被称为模板参数包的展开。</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token comment">**/</span></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token keyword">void</span> <span class="token function">processArgs</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> first<span class="token punctuation">,</span> <span class="token keyword">const</span> Args<span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=20></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=21></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> first <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=22></td><td><pre>    <span class="token comment">/**</span></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token comment">     * 递归调用</span></pre></td></tr><tr><td data-num=24></td><td><pre><span class="token comment">     * 在每一次递归调用中，</span></pre></td></tr><tr><td data-num=25></td><td><pre><span class="token comment">     * 参数包的实参都会被正确传递给相应的T和`Args... args`，</span></pre></td></tr><tr><td data-num=26></td><td><pre><span class="token comment">     * 因此不需要显式地传递参数包的实参。</span></pre></td></tr><tr><td data-num=27></td><td><pre><span class="token comment">    **/</span></pre></td></tr><tr><td data-num=28></td><td><pre>    <span class="token function">processArgs</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num=29></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=30></td><td><pre></pre></td></tr><tr><td data-num=31></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=32></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=33></td><td><pre>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=34></td><td><pre>    <span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=35></td><td><pre>    <span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token char">'A'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=36></td><td><pre></pre></td></tr><tr><td data-num=37></td><td><pre>    <span class="token function">processArgs</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=38></td><td><pre></pre></td></tr><tr><td data-num=39></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=40></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>typename... Args</code>是<code>C++</code>中的模板参数包语法，它表示一个模板参数包，用于接受可变数量的模板参数。</p><ul><li><p><code>typename</code> - 表示这是一个类型模板参数</p></li><li><p><code>...</code> - 表示这是一个模板参数包，它可以接受零个或多个模板参数</p></li><li><p><code>args...</code> - 是<code>C++</code>中的可变参数包展开语法，用于在函数调用时将可变数量的参数传递给函数</p></li></ul><h3 id=新增模板类函数模板相关工具库><a class=anchor href=#新增模板类函数模板相关工具库>#</a> 新增模板类/函数模板相关工具库</h3><p><font size=4><ins><strong>std::function</strong></ins></font></p><p><code>std::function</code>是<code>C++11</code>中引入的一个模板类。它是一种通用的、可用于包装可调用对象(函数、函数指针、成员函数指针、Lambda 表达式等)的容器，提供了一种类型安全且灵活的方式来处理函数对象。</p><p>需头文件 - <code>#include&lt;functional&gt;</code></p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span> </span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;functional></span></span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> foo<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> bar<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">>></span> _map<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>        <span class="token punctuation">&#123;</span><span class="token string">"+"</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=11></td><td><pre>        <span class="token punctuation">&#123;</span><span class="token string">"-"</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=12></td><td><pre>        <span class="token punctuation">&#123;</span><span class="token string">"*"</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=13></td><td><pre>        <span class="token punctuation">&#123;</span><span class="token string">"/"</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x <span class="token operator">/</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre></pre></td></tr><tr><td data-num=16></td><td><pre>    foo <span class="token operator">=</span> <span class="token generic-function"><span class="token function">function</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre>    bar <span class="token operator">=</span> <span class="token generic-function"><span class="token function">function</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=18></td><td><pre></pre></td></tr><tr><td data-num=19></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"foo: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=20></td><td><pre></pre></td></tr><tr><td data-num=21></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=22></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><font size=4><ins><strong>std::bin</strong></ins></font></p><p><code>std::bind</code>是<code>C++11</code>标准库中引入的一个函数模板。它允许创建一个可调用对象，将参数绑定到函数，同时可以重新排列参数或者固定一些参数的值。<code>std::bind</code>的主要用途是创建函数对象，用于延迟执行函数、参数重排序、参数绑定等。</p><p>需头文件 - <code>#include&lt;functional&gt;</code></p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=7></td><td><pre></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">auto</span> func <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>myFunction<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的例子中，<code>std::bind</code>用于创建一个函数对象<code>func</code>，该对象绑定了函数<code>myFunction</code>，并且对参数进行了重新排序。当调用<code>func(1, 2)</code> 时，实际上会调用<code>myFunction(2, 100, 1)</code>。</p><h2 id=新增引用特性><a class=anchor href=#新增引用特性>#</a> 新增引用特性</h2><h3 id=右值引用rvalue-reference><a class=anchor href=#右值引用rvalue-reference>#</a> 右值引用(Rvalue Reference)</h3><p>右值引用是通过使用<code>&amp;&amp;</code>符号表示。与左值引用<code>&amp;</code>不同，右值引用绑定到临时对象(右值)上，这些对象通常是即将销毁的临时对象或者用户明确表达的右值。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token comment">// x是右值引用，绑定到临时对象42上</span></pre></td></tr></table></figure><h3 id=通用引用universal-reference><a class=anchor href=#通用引用universal-reference>#</a> 通用引用(Universal Reference)</h3><p>通用引用使用<code>T&amp;&amp;</code>的语法表示，有两个关键特征</p><ul><li>使用auto或模板参数声明</li><li>使用<code>&amp;&amp;</code>，但不是在类成员函数中</li></ul><p>通用引用的主要作用是允许引用绑定到任何类型的值，同时保留值的左值或右值性质。它是在模板函数或模板类中接受参数时的一种语法。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> arg<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token comment">// arg是通用引用</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id=转移语义移动语句transfer-semantics><a class=anchor href=#转移语义移动语句transfer-semantics>#</a> 转移语义/移动语句(Transfer Semantics)</h3><p>移动语义是一种优化资源管理的机制，通过转移资源而不是复制资源来提升性能，通常用于那些自身资源管理较为复杂的对象(例如大数组、大对象等)。</p><p>移动语义的核心是通过将资源的所有权从一个对象转移到另一个对象，而不是复制资源，从而避免不必要的性能开销。可以避免动态分配的资源中不必要的深层复制。移动语义的关键是右值引用和移动构造函数以及移动赋值运算符。</p><p><strong>移动构造函数(Move Constructor)</strong></p><p>移动构造函数允许从一个对象“窃取”资源，而不是进行深层复制。它采用一个右值引用参数，通常是指向同类型对象的右值引用。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyClass</span> </pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token comment">// 移动构造函数</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token function">MyClass</span><span class="token punctuation">(</span>MyClass<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> </pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>        <span class="token comment">// 从other窃取资源</span></pre></td></tr><tr><td data-num=8></td><td><pre>        <span class="token comment">// 将other的资源指针置为空，以防止在析构时重复释放资源</span></pre></td></tr><tr><td data-num=9></td><td><pre>        data_ <span class="token operator">=</span> other<span class="token punctuation">.</span>data_<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>        other<span class="token punctuation">.</span>data_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=12></td><td><pre></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token keyword">int</span><span class="token operator">*</span> data_<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>移动赋值运算符(Move Assignment Operator)</strong></p><p>与移动构造函数类似，移动赋值运算符也允许将资源从一个对象转移到另一个对象。通常，它采用一个右值引用参数，并在完成移动后将原对象的资源置为空。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyClass</span> </pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">int</span><span class="token operator">*</span> data_<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token comment">// 移动赋值运算符</span></pre></td></tr><tr><td data-num=7></td><td><pre>    MyClass<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>MyClass<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> </pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=9></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=10></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=11></td><td><pre>            <span class="token comment">// 释放当前对象的资源</span></pre></td></tr><tr><td data-num=12></td><td><pre>            <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data_<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>            </pre></td></tr><tr><td data-num=14></td><td><pre>            <span class="token comment">// 从other窃取资源</span></pre></td></tr><tr><td data-num=15></td><td><pre>            data_ <span class="token operator">=</span> other<span class="token punctuation">.</span>data_<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=16></td><td><pre>            </pre></td></tr><tr><td data-num=17></td><td><pre>            <span class="token comment">// 将other的资源指针置为空，以防止在析构时重复释放资源</span></pre></td></tr><tr><td data-num=18></td><td><pre>            other<span class="token punctuation">.</span>data_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=19></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=20></td><td><pre>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=21></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=22></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><details class=info><summary>move函数的作用？原理？</summary><div><p>需包含头文件<code>#include &lt;utility&gt;</code></p><p>move函数是一个用来实现移动语义的函数。它的主要作用是将对象的资源从一个对象转移到另一个对象，而不是进行深拷贝。这个过程可以显著提升性能，特别是在处理资源密集型的对象时(比如动态内存分配、文件句柄等资源)。</p><p>原理是通过将传入的对象转换为右值引用，使它可以绑定到一个临时对象上，从而支持移动语义。这样，资源可以被转移，无需花费大量时间进行资源的复制。</p></div></details><details class=info><summary>C++中为什么提供move函数？</summary><div><p><code>C++</code>中引入移动语义和移动函数(move semantics and move functions)的主要目的是提高程序性能和资源利用效率。移动语义的设计是为了更有效地处理临时对象、避免不必要的内存拷贝，并支持在资源管理类(如智能指针、字符串类等)中实现高效的资源转移。</p></div></details><h3 id=完美转发perfect-forwarding><a class=anchor href=#完美转发perfect-forwarding>#</a> 完美转发(Perfect Forwarding)</h3><p>完美转发是指在函数中传递参数时，保留原参数的值类别(左值或右值)。它是通过引入通用引用和<code>std::forward</code>函数来实现的。完美转发允许函数将它收到的参数原封不动地传递给其他函数，无论这些参数是左值还是右值。</p><p><code>std::forward</code>是一个用于完美转发的工具函数，它用于在函数模板中传递通用引用的参数，并保持其值类别，通常与模板参数一起使用。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;utility></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">void</span> <span class="token function">wrapper</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> arg<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token comment">// 在这里使用std::forward进行完美转发</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token function">some_function</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>完美转发通常用于编写通用函数或模板，其中参数需要被原样传递给其他函数。这在泛型编程和实现通用工具时非常有用。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Func</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">my_forwarding_function</span><span class="token punctuation">(</span>Func<span class="token operator">&amp;&amp;</span> func<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token comment">// 在这里使用完美转发将参数传递给其他函数</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Func<span class="token operator">></span></span></span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Args<span class="token operator">></span></span></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>完美转发是<code>C++</code>中用于实现通用代码、提高代码灵活性和性能的重要特性。</p><figure class="highlight cpp"><figcaption data-lang=C++><span>例子</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility></span></span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment">// 模拟的函数，用于演示完美转发</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Lvalue: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=9></td><td><pre></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Rvalue: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=14></td><td><pre></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token comment">// 使用完美转发的包装函数</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token keyword">void</span> <span class="token function">wrapper</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> arg<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=18></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=19></td><td><pre>    <span class="token function">display</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=21></td><td><pre></pre></td></tr><tr><td data-num=22></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=23></td><td><pre>    <span class="token keyword">int</span> lvalue <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=24></td><td><pre>    </pre></td></tr><tr><td data-num=25></td><td><pre>    <span class="token function">wrapper</span><span class="token punctuation">(</span>lvalue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调用display(const int&amp; x)</span></pre></td></tr><tr><td data-num=26></td><td><pre>    <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调用display(int&amp;&amp; x)</span></pre></td></tr><tr><td data-num=27></td><td><pre></pre></td></tr><tr><td data-num=28></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=29></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id=静态断言><a class=anchor href=#静态断言>#</a> 静态断言</h2><ul><li><p>需包含库<code>&lt;assert.h&gt;</code>或<code>&lt;cassert&gt;</code></p></li><li><p>语法 - <code>static_assert(常量表达式,提示信息)</code></p></li><li><p>用于在编译时检查源代码</p></li></ul><h2 id=智能指针><a class=anchor href=#智能指针>#</a> 智能指针</h2><p>需包含头文件 - <code>#include&lt;memory&gt;</code></p><h3 id=概念><a class=anchor href=#概念>#</a> 概念</h3><p>智能指针是一个RAII类模型，即资源获取即初始化，用于动态分配内存，其设计思想是将基本类型指针封装为(模板)类对象指针，并在离开作用域时调用析构函数，使用<code>delete</code>删除指针所指向的内存空间。</p><ul><li>智能指针是类模板，在栈上创建智能指针对象</li><li>把普通指针交给智能指针对象</li><li>智能指针对象过期时，调用析构函数释放普通指针的内存</li><li>需包含头文件 - <code>#include&lt;memory&gt;</code></li><li>智能指针不支持的运算<code>(+,-,++,--)</code></li><li>智能指针能够处理内存泄漏问题和空悬指针问题</li></ul><details class=info><summary>为什么要用智能指针？</summary><div><ul><li><p><strong>自动内存管理</strong> - 智能指针可以自动管理内存，避免了手动分配和释放内存的繁琐工作。当使用智能指针时，它们会在适当的时候自动释放所管理的对象，从而防止内存泄漏</p></li><li><p><strong>避免悬挂指针(Dangling Pointers)</strong> - 悬挂指针是指指向已释放内存的指针，使用悬挂指针可能导致程序崩溃或不确定的行为。智能指针通过在对象不再需要时自动释放内存，可以有效地防止悬挂指针的问题</p></li><li><p><strong>避免内存泄漏</strong> - 使用智能指针可以避免因忘记释放内存而导致的内存泄漏。智能指针是通过使用RAII(资源获取即初始化)原则来实现的，它们在构造函数中获取资源，在析构函数中释放资源，从而确保资源在对象的生命周期内得到正确的管理</p></li><li><p><strong>提高代码安全性</strong> - 智能指针可以提高代码的安全性，减少了手动管理内存所带来的错误。由于智能指针负责内存管理，程序员不需要手动调用<code>new</code>和<code>delete</code>，从而减少了因手动管理内存而引入的错误的机会</p></li><li><p><strong>方便使用和维护</strong> - 智能指针提供了对指针的高级抽象，使得代码更容易理解和维护。它们提供了像原始指针一样的语法，并添加了自动内存管理的好处</p></li></ul></div></details><details class=info><summary>RAII基本理解与使用？</summary><div><p><strong>RAII(Resource Acquisition Is Initialization)设计模式</strong></p><p>RAII是一种<code>C++</code>编程中的重要设计模式，用于管理资源的获取和释放。这种模式的基本思想是，通过在对象的构造函数中获取资源，而在析构函数中释放资源，来确保资源在对象生命周期内得到正确的管理。</p><p>使用方法 - 在构造函数中申请分配资源，在析构函数中释放资源。</p><p><strong>RAII模型的关键概念部分</strong></p><ul><li><p>资源获取(Resource Acquisition) - 在对象的构造函数中获取需要的资源。这可以是内存、文件句柄、网络连接、互斥锁等等，任何需要手动管理的资源都可以通过这种方式进行获取</p></li><li><p>初始化(Initialization) - 构造函数的执行确保资源的正确获取。这就意味着，如果对象的构造函数成功执行，资源就被正确地获取了</p></li><li><p>资源释放(Resource Release) - 在对象的析构函数中释放先前获取的资源。这确保了在对象生命周期结束时，资源被正确地释放，即使发生异常也能够正常处理</p></li></ul><p>这种模式通过将资源的获取和释放与对象的生命周期绑定在一起，确保资源的正确管理，避免了因为忘记释放资源或者异常而导致的资源泄漏的问题。</p></div></details><details class=info><summary>侵入式与非侵入式的智能指针是什么？</summary><div><p><strong>侵入式智能指针</strong></p><p>侵入式智能指针需要被管理的类提供特定的接口或继承指定的基类，以支持智能指针的操作。这意味着被管理的类必须拥有与智能指针相关的成员函数或遵循特定的约定。</p><p>侵入式智能指针可以更好地控制资源的生命周期，但需要修改被管理类的定义。例如，Boost库中的<code>boost::intrusive_ptr</code>就是一种侵入式智能指针。被管理的类必须实现<code>add_ref()</code>和<code>release()</code>等函数，以增加和释放引用计数。</p><p><strong>非侵入式智能指针</strong></p><p>非侵入式智能指针不需要被管理的类提供额外的接口或继承特定的基类。它通过自身的机制来管理资源的生命周期，而不需要对被管理的类做任何修改。这样可以更方便地将智能指针应用到已有的类中。</p><p><code>C++</code>标准库中的<code>std::shared_ptr</code>就是一种非侵入式智能指针。它可以管理任何动态分配的对象，而不需要对被管理的类做任何特殊要求。</p><p>非侵入式智能指针相对于侵入式智能指针更加灵活和方便，但在某些情况下侵入式智能指针可能提供更细粒度的资源管理控制。</p></div></details><h3 id=智能指针类型><a class=anchor href=#智能指针类型>#</a> 智能指针类型</h3><ul><li><p>不能用于管理不是通过new方法分配的内存。</p></li><li><p>通过<code>std::move()</code>可以转移对指针的控制权</p></li></ul><p><font size=4><ins><strong>std::auto_ptr</strong></ins></font></p><p>由于其拷贝语义和转移语义不明确，可能导致安全问题，其在<code>C++11</code>中被弃用，被 <code>std::unique_ptr</code>取代。</p><p><font size=4><ins><strong>std::unique_ptr</strong></ins></font></p><ul><li><p>独占(unique ownership)所指向的对象，是效率最高的智能指针</p></li><li><p>只能初始化，初始化后不能赋值</p></li><li><p>不能用于多个以普通指针初始化的智能指针，会释放同一块内存空间，同一时间只能有一个<code>std::unique_ptr</code>指向同一个对象</p></li><li><p>用nullptr给unique_ptr赋值将释放对象</p></li><li><p>通过<code>release()</code>方法释放对指针的控制权并将unique_ptr置空，再返回裸指针</p></li><li><p>通过<code>rest()</code>方法可释放对象</p></li><li><p>如果程序调用<code>exit()</code>退出，全局的unique_ptr可以自动释放，但局部的无法释放</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;memory></span></span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=8></td><td><pre>    string name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span>  x<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token comment">// 方法一</span></pre></td></tr><tr><td data-num=17></td><td><pre>    A<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token string">"xxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 普通指针</span></pre></td></tr><tr><td data-num=18></td><td><pre>    unique_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 智能指针</span></pre></td></tr><tr><td data-num=19></td><td><pre>    </pre></td></tr><tr><td data-num=20></td><td><pre>    <span class="token comment">// 方法二</span></pre></td></tr><tr><td data-num=21></td><td><pre>    unique_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token string">"xxx"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=22></td><td><pre>    unique_ptr<span class="token operator">&lt;</span>A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">uparr</span><span class="token punctuation">(</span><span class="token keyword">new</span> A<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 智能指针用于数组</span></pre></td></tr><tr><td data-num=23></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=24></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ul><p><font size=4><ins><strong>std::shared_ptr</strong></ins></font></p><ul><li><p>共享指向的对象，多个<code>shared_ptr</code>可以指向相同的对象</p></li><li><p>采用引用计数的共享所有权机制。当shared_ptr指向对象时，引用计数加1；当shared_ptr超出作用域时，引用计数减1。当引用计数变为0时会释放该对象；用nullptr给shared_ptr赋值时，引用计数减1</p></li><li><p>通过<code>use_count()</code>方法返回引用计数器的值</p></li><li><p>通过<code>unique()</code>方法判断引用计数器的值是否为1，返回bool类型</p></li><li><p>通过<code>get()</code>方法返回裸指针</p></li><li><p><code>std::move()</code>使用时只能将<code>unique_ptr</code>转换成<code>shared_ptr</code>，反过来不行</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;memory></span></span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=8></td><td><pre>    string name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span>  x<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=16></td><td><pre>    A<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token string">"xxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre>    shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=18></td><td><pre>    shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> sp1 <span class="token operator">=</span> sp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=19></td><td><pre>    shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> sp2 <span class="token operator">=</span> sp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=20></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ul><p><font size=4><ins><strong>std::weak_ptr</strong></ins></font></p><ul><li><p>shared_ptr内部有一个共享的引用计数器，多个shared_ptr可以指向同一个资源。如果出现了循环引用的情况，引用计数就无法归0，资源也不会被释放。weak_ptr用于辅助shared_ptr，它指向一个由shared_ptr管理的资源但不影响资源的生命周期，将一个weak_ptr绑定到一个shared_ptr时不会给shared_ptr的引用进行计数</p></li><li><p>weak_ptr严格来说，不能算是智能指针，只是一个类的弱引用，是用来解决两个<code>std::shared_ptr</code>相互进行引用的问题的</p></li><li><p>调用<code>lock()</code>方法来获取一个有效的<code>std::shared_ptr</code>。如果对象还存在，则<code>lock()</code>返回一个指向对象的<code>std::shared_ptr</code>；如果对象已被销毁，则返回一个空的<code>std::shared_ptr</code></p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> sharedPtr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">weakPtr</span><span class="token punctuation">(</span>sharedPtr<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token comment">// 使用 lock() 方法获取 shared_ptr</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> lockedPtr <span class="token operator">=</span> weakPtr<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=11></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Value observed through weakPtr: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>lockedPtr <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=13></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Object has been destroyed."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=15></td><td><pre></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token comment">// 此时释放 sharedPtr</span></pre></td></tr><tr><td data-num=17></td><td><pre>    sharedPtr<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=18></td><td><pre></pre></td></tr><tr><td data-num=19></td><td><pre>    <span class="token comment">// 再次尝试使用 lock() 方法获取 shared_ptr</span></pre></td></tr><tr><td data-num=20></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> lockedPtr <span class="token operator">=</span> weakPtr<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=21></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Value observed through weakPtr: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>lockedPtr <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=22></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=23></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Object has been destroyed."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=24></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=25></td><td><pre></pre></td></tr><tr><td data-num=26></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=27></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ul><details class=info><summary>C++中强引用和弱引用是什么？有什么区别？</summary><div><p>在<code>C++</code>中，强引用和弱引用这两个术语通常不是直接使用的术语，而是更常见于一些其他编程语言。然而，可以在<code>C++</code>中通过一些概念来理解类似的概念。</p><ul><li><p>强引用是指对对象的引用，该引用会增加对象的引用计数，阻止被引用对象被释放。在C++中，智能指针(如<code>std::shared_ptr</code>)通常用于创建强引用。当所有指向一个对象的<code>std::shared_ptr</code>都被销毁时，对象会被自动释放</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> strongReference <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token comment">// strongReference是强引用，引用计数+1</span></pre></td></tr><tr><td data-num=8></td><td><pre>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> anotherReference <span class="token operator">=</span> strongReference<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token comment">// 对象不会在这里被释放，因为还有一个引用存在</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>弱引用是一种不会增加对象引用计数的引用，它不会阻止对象被释放。在<code>C++</code>中，可以使用<code>std::weak_ptr</code>创建弱引用。弱引用通常用于避免循环引用的问题，因为循环引用可能导致内存泄漏</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> strongReference <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> weakReference <span class="token operator">=</span> strongReference<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token comment">// 对象不会在这里被释放，因为还有一个强引用存在</span></pre></td></tr><tr><td data-num=9></td><td><pre>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> anotherReference <span class="token operator">=</span> weakReference<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token comment">// 对象可能在这里被释放，因为没有强引用存在</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ul><p>区别是</p><ul><li><strong>强引用</strong> - 增加引用计数，阻止对象被释放，使用<code>std::shared_ptr</code>来实现</li><li><strong>弱引用</strong> - 不增加引用计数，不阻止对象被释放，使用<code>std::weak_ptr</code>来实现。通常用于解决循环引用问题，避免内存泄漏</li></ul></div></details><details class=info><summary>主要的三种智能指针的使用场景？</summary><div><p><code>std::unique_ptr</code> - 用于需要独占所有权的资源管理。它确保指针在任何时候只有一个所有者，当指针超出作用域时自动释放资源，非常适合管理那些不需要共享的资源，减少了手动释放内存的负担</p><p><code>std::shared_ptr</code> - 用于需要共享所有权的资源管理。多个<code>shared_ptr</code> 实例可以指向相同的对象，内部使用引用计数来跟踪资源的所有者数量。当最后一个<code>shared_ptr</code> 实例销毁时，资源才会被释放，适合跨多个函数或对象共享资源的场景。</p><p><code>std::weak_ptr</code> - 用于解决共享资源时的循环引用问题。它并不增加引用计数，因此不会影响<code>shared_ptr</code> 的生命周期。<code>weak_ptr</code> 可以被转换为<code>shared_ptr</code>，但必须确保所指向的对象仍然存在。适用场景如缓存或观察者模式中，跟踪对象但不拥有资源。</p></div></details><details class=info><summary>什么是引用计数？</summary><div><p>引用计数是一种内存管理技术，用于跟踪动态分配的内存的引用次数。在引用计数中，每当一个对象被引用时，引用计数就会增加；当引用离开作用域、被释放或不再被使用时，引用计数就会减少。当引用计数达到零时，表示没有任何引用指向该对象，此时可以安全地释放该对象占用的内存。</p><p><strong>引用计数的基本工作原理</strong></p><ul><li><p>初始化 - 当创建一个动态分配的对象时，引用计数初始化为1，表示有一个指针指向该对象</p></li><li><p>增加引用计数 - 每当有新的指针开始指向该对象时，引用计数会增加。这通常发生在复制智能指针(例如，通过<code>std::shared_ptr</code>的拷贝构造函数或赋值操作符)时</p></li><li><p>减少引用计数 - 当指向该对象的指针超出作用域、被销毁或以其他方式不再引用该对象时，引用计数会减少</p></li><li><p>释放内存 - 当引用计数减少到零时，表示没有指针再指向该对象，这时可以安全地释放对象占用的内存。通常，在<code>std::shared_ptr</code>的析构函数中进行内存的释放</p></li></ul></div></details><details class=info><summary>C++中的共享指针是怎样计数的？</summary><div><p>共享指针(<code>std::shared_ptr</code>)使用引用计数机制进行计数。这意味着<code>std::shared_ptr</code>会在内部维护一个计数器，用于跟踪指向相同对象的共享指针的数量。当有新的<code>std::shared_ptr</code>指向某个对象时，该对象的引用计数会增加；当<code>std::shared_ptr</code>销毁或不再指向该对象时，引用计数会减少。</p><p>以下是<code>std::shared_ptr</code>的基本工作原理</p><ul><li><p><strong>初始化</strong> - 当创建一个<code>std::shared_ptr</code>来管理某个对象时，引用计数初始化为1</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token comment">// 引用计数为1</span></pre></td></tr></table></figure></li><li><p><strong>增加引用计数</strong> - 每当有新的<code>std::shared_ptr</code>指向相同的对象时，引用计数会递增</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr2 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span><span class="token comment">// 引用计数递增为2</span></pre></td></tr></table></figure></li><li><p><strong>减少引用计数</strong> - 当<code>std::shared_ptr</code>超出作用域、被销毁或通过赋值操作离开指向对象时，引用计数会递减</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// ptr1和ptr2离开作用域，引用计数递减为0</span></pre></td></tr></table></figure></li><li><p><strong>释放内存</strong> - 当引用计数递减到零时，表示没有任何<code>std::shared_ptr</code>指向该对象，这时会调用对象的析构函数，并释放该对象占用的内存。</p></li></ul></div></details><details class=info><summary>如何实现一个引用计数功能？</summary><div><p>实现一个简单的引用计数功能通常包括以下步骤</p><ul><li><p>创建计数器 - 在对象的内部，添加一个整数变量来表示引用计数。这个计数器通常初始化为1，因为创建对象时已经有一个指针引用了它</p></li><li><p>增加引用计数 - 当有新的指针开始引用对象时，引用计数加1</p></li><li><p>减少引用计数 - 当指针离开作用域、被销毁或不再引用对象时，引用计数减1</p></li><li><p>释放内存 - 当引用计数减到零时，表示没有指针引用对象，此时可以释放对象占用的内存</p></li></ul><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">class</span> <span class="token class-name">RefCounted</span> </pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token function">RefCounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">refCount</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Object created. Ref count: "</span> <span class="token operator">&lt;&lt;</span> refCount <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=9></td><td><pre></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">void</span> <span class="token function">addReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=12></td><td><pre>        refCount<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Reference added. Ref count: "</span> <span class="token operator">&lt;&lt;</span> refCount <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=15></td><td><pre></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token keyword">void</span> <span class="token function">releaseReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=17></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=18></td><td><pre>        refCount<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=19></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Reference released. Ref count: "</span> <span class="token operator">&lt;&lt;</span> refCount <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=20></td><td><pre></pre></td></tr><tr><td data-num=21></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>refCount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=22></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=23></td><td><pre>            <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// Assuming the object was dynamically allocated.</span></pre></td></tr><tr><td data-num=24></td><td><pre>            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Object destroyed."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=25></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=26></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=27></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=28></td><td><pre>    <span class="token keyword">int</span> refCount<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=29></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=30></td><td><pre></pre></td></tr><tr><td data-num=31></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=32></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=33></td><td><pre>    <span class="token comment">// 创建对象并增加引用计数</span></pre></td></tr><tr><td data-num=34></td><td><pre>    RefCounted<span class="token operator">*</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">RefCounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=35></td><td><pre>    obj<span class="token operator">-></span><span class="token function">addReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=36></td><td><pre></pre></td></tr><tr><td data-num=37></td><td><pre>    <span class="token comment">// 创建另一个指针指向相同对象，增加引用计数</span></pre></td></tr><tr><td data-num=38></td><td><pre>    RefCounted<span class="token operator">*</span> obj2 <span class="token operator">=</span> obj<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=39></td><td><pre>    obj2<span class="token operator">-></span><span class="token function">addReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=40></td><td><pre></pre></td></tr><tr><td data-num=41></td><td><pre>    <span class="token comment">// 释放一个指针，减少引用计数</span></pre></td></tr><tr><td data-num=42></td><td><pre>    obj<span class="token operator">-></span><span class="token function">releaseReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=43></td><td><pre></pre></td></tr><tr><td data-num=44></td><td><pre>    <span class="token comment">// 释放另一个指针，减少引用计数</span></pre></td></tr><tr><td data-num=45></td><td><pre>    obj2<span class="token operator">-></span><span class="token function">releaseReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=46></td><td><pre></pre></td></tr><tr><td data-num=47></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=48></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></div></details><details class=info><summary>智能指针有什么线程安全问题？如何确保其线程安全？</summary><div><p><code>std::shared_ptr</code>提供了多个所有者共享对同一对象的所有权的能力，但它的引用计数机制可能引起线程安全问题。当多个线程同时操作同一个<code>std::shared_ptr</code>，可能导致竞争条件，从而影响引用计数的正确性，进而影响内存的正确释放。这种情况下，需要采取措施来确保线程安全。</p><p>在标准C++中，<code>std::shared_ptr</code>的引用计数是通过原子操作实现的，因此在一般情况下，<code>std::shared_ptr</code>是线程安全的。然而，如果在使用自定义的内存管理器或者在特殊环境下，可能需要考虑额外的线程安全措施。</p><p>以下是一些建议，以确保在多线程环境中使用<code>std::shared_ptr</code>时的线程安全性</p><ul><li>避免竞争条件 - 尽量避免多个线程同时对同一个<code>std::shared_ptr</code>进行写操作，以免引起竞争条件。如果确实需要在多线程环境下修改共享的<code>std::shared_ptr</code>，可能需要使用互斥锁来同步访问</li><li>使用<code>std::atomic</code> - 如果在多线程环境下修改<code>std::shared_ptr</code>的引用计数，确保使用原子操作。这可以通过使用<code>std::atomic</code>来包装<code>shared_ptr</code>来实现</li></ul></div></details><details class=info><summary>shared_ptr直接类构造和用make_shared区别？</summary><div><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 直接构造</span></pre></td></tr><tr><td data-num=2></td><td><pre>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> ptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>两者之间的区别</p><ul><li><p><strong>性能</strong> - 使用 <code>std::make_shared</code>可能具有更好的性能，因为它可以一次性分配内存来存储对象和引用计数，而直接构造则需要分配两次，一次给对象，一次给引用计数。这可以减少动态内存分配的开销</p></li><li><p><strong>异常安全性</strong> - <code>std::make_shared</code>可以提供更强的异常安全性，因为它可以在单个内存分配操作中完成对象和引用计数的分配。在直接构造的情况下，如果在为对象分配内存后发生异常，可能会导致引用计数的内存泄漏</p></li><li><p><strong>语法和可读性</strong> - <code>std::make_shared</code>的语法更加简洁，而且更符合现代C++的推荐做法。它不需要指定对象的类型，可以直接根据右侧的参数进行类型推导</p></li><li><p><strong>用户自定义类型</strong> - 如果有一个用户自定义类型，并且希望传递参数给该类型的构造函数<code>std::make_shared</code>允许传递构造函数的参数。直接构造的方式则需要在<code>new</code>后面提供参数列表</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 使用 std::make_shared，更简洁</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">auto</span> ptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>MyClass<span class="token operator">></span></span></span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment">// 直接构造，需要在 new 后面提供参数列表</span></pre></td></tr><tr><td data-num=5></td><td><pre>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>MyClass<span class="token operator">></span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">MyClass</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li></ul><p>推荐使用<code>std::make_shared</code>，因为它不仅具有更好的性能和异常安全性，而且语法更为简洁。</p></div></details><h3 id=删除器><a class=anchor href=#删除器>#</a> 删除器</h3><ul><li>默认情况下，智能指针过期的时候会用delete方法清除</li><li>可以通过自定义删除器来改变智能指针释放资源的行为</li><li>删除器可以是全局函数，仿函数和Lambda表达式，它们的形参为原始指针</li><li>用于想要在删除的时候做额外的工作</li></ul><h2 id=lambda表达式lambda匿名函数><a class=anchor href=#lambda表达式lambda匿名函数>#</a> lambda表达式/lambda匿名函数</h2><p>lambda源自希腊字母表中第11位的λ，在计算机科学领域，它则是被用来表示一种匿名函数。</p><p>匿名函数，又常被称为lambda函数或者lambda表达式，简单地理解就是没有名称的函数。</p><p>Lambda表达式是<code>C++11</code>引入的一种匿名函数的形式，允许在代码中内联定义函数。Lambda表达式是一种闭包，可以捕获其所在作用域的变量，并在函数体内使用这些变量。</p><p>lambda表达式 - <code>[capture](parameters)-&gt;return_type&#123;&#125;</code></p><ul><li><code>capture</code> - 捕获列表，用于指定Lambda表达式可以访问的外部变量</li><li><code>parameters</code> - 参数列表，类似于函数的参数</li><li><code>return_type</code> - 返回类型，指定Lambda表达式的返回类型</li><li><code>function body</code> - 函数体，定义Lambda表达式的具体逻辑</li></ul><figure class="highlight text"><figcaption data-lang=text></figcaption><table><tr><td data-num=1></td><td><pre>[外部变量访问方式说明符] (参数) mutable noexcept/throw() -> 返回值类型</pre></td></tr><tr><td data-num=2></td><td><pre>&#123;</pre></td></tr><tr><td data-num=3></td><td><pre>	函数体;</pre></td></tr><tr><td data-num=4></td><td><pre>&#125;;</pre></td></tr></table></figure><h2 id=新增模板特性><a class=anchor href=#新增模板特性>#</a> 新增模板特性</h2><h3 id=新增类模板特性><a class=anchor href=#新增类模板特性>#</a> 新增类模板特性</h3><p><ins><strong>std::enable_shared_from_this</strong></ins></p><p><code>std::enable_shared_from_this</code>允许一个对象在其成员函数中生成一个指向自身的<code>std::shared_ptr</code>。</p><p>可用于当希望一个对象的成员函数能提供一个<code>shared_ptr</code>的访问方式，以便对该对象进行操作。</p><p>可以保持对象的有效性。</p><h2 id=新增标准模板库stl><a class=anchor href=#新增标准模板库stl>#</a> 新增标准模板库(STL)</h2><h3 id=算法库><a class=anchor href=#算法库>#</a> 算法库</h3><p><font size=4><ins><strong>std::max与std::min - 最大/最小值</strong></ins></font></p><p>需头文件 - <code>#include&lt;algorithm&gt;</code></p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment">// 使用std::max返回较大的值</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">int</span> result1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token comment">// 使用std::min返回较大的值</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token keyword">int</span> result2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><font size=4><ins><strong>std::swap - 交互两个变量的内存值</strong></ins></font></p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id=c11新标准列举><a class=anchor href=#c11新标准列举>#</a> C++11新标准列举</h2><h3 id=新标准列举><a class=anchor href=#新标准列举>#</a> 新标准列举</h3><ul><li><code>long long</code>类型</li><li><code>char16_t</code>和<code>char32_t</code>类型</li><li>原始字面量</li><li>统一的初始化({}列表方式)</li><li><code>auto</code>关键字可用于自动推导类型</li><li><code>decltype</code>关键字</li><li>函数后置返回类型</li><li>模板的别名</li><li>空指针<code>nullptr</code></li><li>智能指针</li><li>异常规范方面的修改</li><li>作用域内枚举</li><li>强类型枚举(枚举类)</li><li><code>explicit</code>关键字</li><li>类内成员初始化</li><li>基于范围的for循环</li><li>新的STL容器<ul><li><code>array</code>静态数组</li><li><code>forward_list</code>单项链表</li><li><code>unordered_map</code> - <code>unordered_multimap</code> - <code>unordered_set</code> - <code>unordered_multiset</code></li></ul></li><li>新的STL方法(成员函数)<ul><li><code>cbegin()</code> - <code>cend()</code> - <code>crbegin()</code> - <code>crend()</code></li></ul></li><li>弃用<code>export</code></li><li>嵌套模板尖括号要求的变更<ul><li>旧标准 - <code>vector&lt;list&lt;int&gt; &gt; v1</code> - 后面尖括号之间有一个空格</li><li>新标准 - <code>vector&lt;list&lt;int&gt;&gt; v1</code></li></ul></li><li><code>final</code>关键字</li><li><code>override</code>关键字</li><li>数值类型和字符串之间的转换<ul><li><code>to_string()</code>方法</li><li><code>stoi</code> - <code>stol</code> - <code>stoll</code> - <code>stoul</code>等</li></ul></li><li>静态断言</li><li>常量表达式<code>constexpr</code>关键字<ul><li><code>const</code> - 表示只读</li><li><code>constexpr</code> - 表示常量</li></ul></li><li>默认函数控制<code>=default</code>与<code>=delete</code></li><li>委托构造和继承构造</li><li>lambda表达式</li><li>右值引用</li><li>移动语义</li><li>完美转发</li><li>可变参数模板</li><li>时间操作库chrono</li></ul><details class=info><summary>常用的新特性有哪些？</summary><div><ul><li>自动类型推断(auto)</li><li>范围 for 循环(range-based for loop)</li><li>智能指针(shared_ptr, unique_ptr)</li><li>右值引用和移动语义(rvalue references and move semantics)</li><li>线程库</li><li>lambda 表达式(lambda expressions)</li><li>常规表达式(nullptr)</li><li>静态断言(static_assert)</li><li>初始化列表(initializer_list)</li><li>函数对象和 std::bind</li><li>基于时间的集合(chrono library)</li></ul></div></details><details class=info><summary>介绍下C++11的enum class 、enum struct 和 enum？</summary><div><p>在<code>C++11</code>中引入了<code>enum class</code>，它是一种新型的枚举类型，可以有初始值，与传统的<code>enum</code>有一些不同。此外，<code>enum struct</code>其实是<code>enum class</code>的一种同义表达。</p><p><code>enum</code> - 传统的枚举类型，其枚举值属于同一命名空间，并且可以被隐式转换为整数。</p><p><code>enum class</code>(或<code>enum struct</code>) - 引入了作用域，枚举值在该作用域内是唯一的，不会与其他枚举或整数发生命名冲突。而且，不能隐式转换为整数，需要显式转换。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Color</span> </pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    RED<span class="token punctuation">,</span></pre></td></tr><tr><td data-num=4></td><td><pre>    GREEN<span class="token punctuation">,</span></pre></td></tr><tr><td data-num=5></td><td><pre>    BLUE</pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token comment">// 或者使用 enum struct</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token keyword">enum</span> <span class="token keyword">struct</span> <span class="token class-name">Month</span> </pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    JAN<span class="token punctuation">,</span></pre></td></tr><tr><td data-num=12></td><td><pre>    FEB<span class="token punctuation">,</span></pre></td></tr><tr><td data-num=13></td><td><pre>    MAR</pre></td></tr><tr><td data-num=14></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre></pre></td></tr><tr><td data-num=16></td><td><pre>Color color <span class="token operator">=</span> Color<span class="token double-colon punctuation">::</span>RED<span class="token punctuation">;</span> <span class="token comment">// 必须使用作用域</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token comment">// int value = color; // 错误，不能隐式转换为整数</span></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 正确，需要显式转换</span></pre></td></tr></table></figure><p><code>enum class</code>更加类型安全，因为它不允许不同枚举类型之间的混淆，也不允许隐式转换为整数。</p><p><code>enum</code>和<code>enum class</code>都可以指定底层类型(Underlying Type)。在不指定底层类型的情况下，<code>enum class</code>默认使用<code>int</code>作为底层类型，而传统的<code>enum</code>默认使用整数。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">enum</span> <span class="token class-name">Color</span> <span class="token operator">:</span> <span class="token keyword">char</span> </pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    RED<span class="token punctuation">,</span></pre></td></tr><tr><td data-num=4></td><td><pre>    GREEN<span class="token punctuation">,</span></pre></td></tr><tr><td data-num=5></td><td><pre>    BLUE</pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Color</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">char</span></span> </pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    RED<span class="token punctuation">,</span></pre></td></tr><tr><td data-num=11></td><td><pre>    GREEN<span class="token punctuation">,</span></pre></td></tr><tr><td data-num=12></td><td><pre>    BLUE</pre></td></tr><tr><td data-num=13></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure></div></details><h3 id=线程><a class=anchor href=#线程>#</a> 线程</h3><p><strong>创建</strong></p><p>需包含头文件 - <code>#include&lt;thread&gt;</code></p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;thread></span></span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">inlcude</span><span class="token expression"><span class="token operator">&lt;</span>windows<span class="token punctuation">.</span>h<span class="token operator">></span></span></span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"working"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1s</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=14></td><td><pre></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=17></td><td><pre>    thread <span class="token function">t1</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"xxxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 用普通函数创建线程</span></pre></td></tr><tr><td data-num=18></td><td><pre>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 回收线程t1的资源</span></pre></td></tr><tr><td data-num=19></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>线程资源回收</strong></p><ul><li>在主程序中，调用<code>join()</code>成员函数等待子线程退出并回收资源，当子线程已退出，<code>join()</code>函数立即返回，否则会参数阻塞，直到子线程退出</li><li>在子线程中，调用<code>detach()</code>成员函数分离子线程，子线程退出时，系统会自动回收资源。<code>joinable()</code>一元函数可以判断子线程的分离转台，函数返回布尔类型</li></ul><p><strong>this_thread的全局函数</strong></p><ul><li><code>get_id()</code> - 获取线程id</li><li><code>sleep_for()</code> - 让线程休眠一段时间</li><li><code>sleep_until()</code> - 让线程休眠至指定时间，用于实现定时任务</li><li><code>yield()</code> - 让线程主动让出当前线程以获得的CPU时间片</li><li><code>swap()</code> - 交换两个线程</li></ul><p><strong>call_once函数</strong></p><ul><li>在多线程环境中，某些函数只能被调用一次，可以用<code>std::call_once()</code>来保证某个函数只被调用一次</li><li>需头文件 - <code>#include&lt;mutex&gt;</code></li></ul><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 定义一个全局变量。本质是取值为0和1的锁</span></pre></td></tr><tr><td data-num=2></td><td><pre>once_flag onceflag<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token comment">// ...</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token function">call_once</span><span class="token punctuation">(</span>onceflag<span class="token punctuation">,</span>函数<span class="token punctuation">,</span>函数参数<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>native_handle函数</strong></p><ul><li>用于弥补<code>C++11</code>线程库的不足，获取与操作系统相关的原生线程句柄，操作系统原生的线程库就可以用原生线程句柄操作线程</li></ul><p><strong>线程安全</strong></p><ul><li>同一进程中的多个线程共享该进程中全部的系统资源，多个线程访问同一个共享资源时就会产生冲突</li><li>顺序性 - 程序按照代码的先后顺序执行</li><li>可见性 - 当多个线程并发访问共享变量时，一个线程对共享变量的修改，其他线程能够立即看到</li></ul><p><strong>保证线程安全</strong></p><ul><li><p>volatile关键字 - 不能保证线程安全</p><ul><li>保证内存变量的可见性</li><li>禁止代码优化(重排序)</li></ul></li><li><p>原子操作(原子类型)</p></li><li><p>线程同步(锁)</p></li></ul><h3 id=线程同步><a class=anchor href=#线程同步>#</a> 线程同步</h3><p><strong>互斥锁</strong></p><ul><li><p>需包含头文件 - <code>#include&lt;mutex&gt;</code></p></li><li><p>包含</p><ul><li>mutex - 互斥锁</li><li>timed_mutex - 带超时机制的互斥锁</li><li>recursive_mutex - 递归互斥锁</li><li>recursive_timed_mutex - 带超时机制的递归互斥锁</li></ul></li><li><p>加锁<code>lock()</code></p><ul><li><p>互斥锁有锁定和未锁定两种状态</p></li><li><p>处于未锁定状态并调用<code>lock()</code>时成员函数的线程会得到互斥锁的所有权，并将其上锁</p></li><li><p>处于锁定状态并调用<code>lock()</code>时成员函数的线程就会阻塞等待，直到互斥锁变为未锁定状态</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 创建互斥锁，用于保护共享资源</span></pre></td></tr><tr><td data-num=2></td><td><pre>mutex mtx；</pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre>mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment">// ...需要保护的操作</span></pre></td></tr><tr><td data-num=6></td><td><pre>mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li></ul></li><li><p>尝试加锁<code>trylock()</code></p><ul><li>当互斥锁是未锁定状态，则加锁成功并返回<code>true</code></li><li>当互斥锁是锁定状态，则加锁失败并立即返回<code>false</code>(线程不会阻塞等待)</li></ul></li><li><p>解锁<code>unlock()</code> - 只有持有锁的线程才能解锁</p></li><li><p>timed_mutex类</p></li><li><p>recursive_mutex类 - 递归互斥锁允许同一线程多次获得互斥锁，可以解决同一线程多次加锁造成死锁的问题</p></li><li><p>lock_guard类 - 模板类，可以简化互斥锁的使用，更安全</p></li></ul><h3 id=条件变量-生成消费者模型><a class=anchor href=#条件变量-生成消费者模型>#</a> 条件变量 - 生成/消费者模型</h3><ul><li>条件变量是一种线程同步机制，当条件不满足时相关线程一直被阻塞，直到某种条件出现时才被唤醒</li><li>下面两个类需包含头文件 - <code>#include&lt;condition_variable&gt;</code></li></ul><p><strong>condition_variable</strong>类</p><ul><li>只支持与普通<code>mutex</code>搭配，效率更高</li><li><code>notify_one()</code> - 通知一个等待线程唤醒</li><li><code>notify_all()</code> - 通知全部等待的线程唤醒</li><li><code>wait(unique_lock&lt;mutex&gt; lock)</code> - 阻塞当前线程，直到通知到达<ul><li>把互斥锁解锁</li><li>阻塞，等待被唤醒</li><li>给互斥锁加锁</li></ul></li><li><code>wait(unique_lock&lt;mutex&gt; lock,Pred pred)</code> - 循环的阻塞当前线程，直到通知到达且谓词满足</li><li><code>wait_for()</code></li><li><code>wait_until()</code></li></ul><p><strong>condition_variable_any</strong>类</p><ul><li>是一种通用的条件变量，可以与任意<code>mutex</code>搭配(包括用户自定义的锁类型)</li></ul><h3 id=原子类型atomic><a class=anchor href=#原子类型atomic>#</a> 原子类型atomic</h3><ul><li><code>C++11</code>提供了(结构体)，用于支持原子类型，模板参数可以是bool, char, int, long, long long，指针类型(不支持浮点类型和自定义数据类型)</li><li>原子操作由CPU指令提供支持，他的性能比锁和消息传递更高，并且，不需要手动处理加锁和释放锁的问题，支持修改，读取，交换，比较并交换等操作</li><li>需头文件 - <code>#inlcude&lt;atomic&gt;</code></li><li><code>atomic&lt;T&gt;</code>模板类重载了整数操作的各种运算符</li><li><code>atomic&lt;T&gt;</code>模板类的模板参数支持指针，但不代表它指向的对象是原子类型</li><li>原子整形可以用作计数器，布尔类型可以用作开关</li><li>CAS指令是实现无锁队列基础</li></ul><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr></table></figure><details class=info><summary>C++11中的原子操作(atomic operation)是什么？</summary><div><p><code>C++11</code>引入了<code>&lt;atomic&gt;</code>头文件，其中定义了一组原子操作，用于实现多线程编程中的原子操作，避免了竞态条件(race conditions)。原子操作是不可中断的操作，它们保证了多线程环境下对共享数据的原子性访问，从而避免了数据竞争。</p></div></details><h2 id=相关补充项><a class=anchor href=#相关补充项>#</a> 相关补充项</h2><p>if语句的括号中的圆括号不仅可以用于表达式的条件判断，还可以用于声明和初始化变量。这是<code>C++11</code>标准引入的一项特性，被称为条件变量声明(Condition Variable Declaration)。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> x <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>        <span class="token comment">// 在这里，x 只在 if 语句块内有效</span></pre></td></tr><tr><td data-num=7></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x is positive: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=9></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x is non-positive: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 编译错误，x 不在这个作用域内</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=11></td><td><pre></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token comment">// 在这里，x 不再可见</span></pre></td></tr><tr><td data-num=13></td><td><pre></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><details class=info><summary>static关键字在C语言和C++中有什么区别？</summary><div><p><strong>共同点</strong></p><ul><li><p><strong>静态变量</strong> - 在<code>C/C++</code>中，<code>static</code>都可以用于声明静态变量。静态变量在程序的整个生命周期内存在，而不是在函数调用期间创建和销毁</p></li><li><p><strong>静态函数</strong> - <code>static</code>也可以用于声明静态函数。静态函数的作用域仅限于声明它的文件(在C中)或者编译单元(在C++中)</p></li></ul><p><strong>不同点</strong></p><ul><li><strong>静态变量的初始化</strong><ul><li>在C语言中，静态变量的初始化只会在第一次进入作用域时进行一次，之后的进入不会再次初始化。例如，静态变量在函数内部的情况下，只会在第一次调用函数时初始化</li><li>在<code>C++</code>中，静态变量的初始化也只会在第一次进入作用域时进行一次，但这是线程安全的，并且在程序启动时进行初始化</li></ul></li><li><strong>静态函数的作用域</strong><ul><li>在C语言中，静态函数的作用域限制在声明它的文件内部。这使得静态函数在文件外不可见，从而实现了文件作用域</li><li>在<code>C++</code>中，静态函数的作用域限制在编译单元(translation unit)内部，即在同一源文件内。这使得静态函数在文件外不可见，但在不同源文件中的静态函数是不相关的</li></ul></li></ul></div></details><details class=info><summary>C/C++中static初始化时机？</summary><div><p><strong>全局变量和静态全局变量</strong>在程序开始执行之前就会被初始化。它们的初始化顺序与它们的定义顺序有关。</p><p><strong>局部静态变量</strong>是在函数内部定义的<code>static</code>变量。这些变量在程序的生命周期内只被初始化一次，即使函数被多次调用。它们在第一次调用函数时被初始化。</p><p><strong>类的静态成员变量</strong>在程序开始执行之前被初始化，与全局变量类似。它们只有一个副本，属于类而不是类的实例。</p></div></details><details class=info><summary>C/C++中static线程安全问题？</summary><div><p><strong>静态局部变量</strong> - 在函数内部声明的<code>static</code>局部变量在多线程环境下可能存在线程安全问题。如果一个线程正在访问这个函数，并且正在初始化这个静态局部变量，同时另一个线程也调用了这个函数，那么两个线程可能会同时初始化这个静态局部变量，导致不确定的行为。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">int</span> staticLocalVariable <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    staticLocalVariable<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre></pre></td></tr><tr><td data-num=9></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread ID: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", Value: "</span> <span class="token operator">&lt;&lt;</span> staticLocalVariable <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=11></td><td><pre></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=13></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>myFunction<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre>    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>myFunction<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=16></td><td><pre></pre></td></tr><tr><td data-num=17></td><td><pre>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=18></td><td><pre>    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=19></td><td><pre></pre></td></tr><tr><td data-num=20></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=22></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token comment"> * 在上述示例中，</span></pre></td></tr><tr><td data-num=24></td><td><pre><span class="token comment"> * 两个线程可能会同时访问和修改staticLocalVariable，</span></pre></td></tr><tr><td data-num=25></td><td><pre><span class="token comment"> * 导致输出的结果不一致</span></pre></td></tr><tr><td data-num=26></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><p><strong>静态成员变量</strong> - 对于类的静态成员变量，它们在程序启动时进行初始化，理论上应该是线程安全的。不过，在某些情况下，编译器可能采用非线程安全的初始化方式。因此，在多线程环境中，最好使用<code>C++11</code>标准引入的线程安全的初始化方式，即使用<code>std::call_once</code>。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyClass</span> </pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token comment">// 线程安全的静态成员变量初始化</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">getStaticMemberVariable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=11></td><td><pre>        std<span class="token double-colon punctuation">::</span><span class="token function">call_once</span><span class="token punctuation">(</span>flag<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=12></td><td><pre>            staticMemberVariable <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre>        <span class="token keyword">return</span> staticMemberVariable<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=17></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">int</span> staticMemberVariable<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=18></td><td><pre>    <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>once_flag flag<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=20></td><td><pre></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token keyword">int</span> MyClass<span class="token double-colon punctuation">::</span>staticMemberVariable <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=22></td><td><pre>std<span class="token double-colon punctuation">::</span>once_flag MyClass<span class="token double-colon punctuation">::</span>flag<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=23></td><td><pre></pre></td></tr><tr><td data-num=24></td><td><pre><span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=25></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=26></td><td><pre>    <span class="token keyword">int</span><span class="token operator">&amp;</span> value <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token double-colon punctuation">::</span><span class="token function">getStaticMemberVariable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=27></td><td><pre>    value<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=28></td><td><pre></pre></td></tr><tr><td data-num=29></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread ID: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", Value: "</span> <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=30></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=31></td><td><pre></pre></td></tr><tr><td data-num=32></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=33></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=34></td><td><pre>    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>myFunction<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=35></td><td><pre>    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>myFunction<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=36></td><td><pre></pre></td></tr><tr><td data-num=37></td><td><pre>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=38></td><td><pre>    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=39></td><td><pre></pre></td></tr><tr><td data-num=40></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=41></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=42></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=43></td><td><pre><span class="token comment"> * 在这个示例中，</span></pre></td></tr><tr><td data-num=44></td><td><pre><span class="token comment"> * std::call_once确保staticMemberVariable只被初始化一次，</span></pre></td></tr><tr><td data-num=45></td><td><pre><span class="token comment"> * 从而提供线程安全性。</span></pre></td></tr><tr><td data-num=46></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure></div></details><details class=info><summary>C++中重载和重写，重定义的区别?</summary><div><ul><li><p><strong>重载(Overloading)</strong> - 重载是指在同一个作用域内，可以定义多个具有相同名称但参数列表不同(类型、顺序、个数)的函数或运算符，重载提供了更灵活的函数或运算符使用方式，可以根据不同的参数类型调用相应的函数</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p><strong>重写(Overriding)</strong> - 重写是指在派生类中重新定义(覆盖)基类中已有的虚函数，使得派生类中的函数与基类中的虚函数具有相同的签名(名称、参数列表、返回类型)，重写通常用于实现多态，通过基类指针或引用调用派生类的函数</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Base</span> </pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base class"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> </pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=13></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derived class"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p><strong>重定义(Shadowing)</strong> - 重定义是指在派生类中重新定义(遮蔽)了基类中的同名成员，包括变量和函数，导致在派生类中无法直接访问基类中的成员，重定义可能导致在派生类中隐藏基类中的成员，可以使用作用域解析运算符 <code>::</code> 来访问基类成员</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Base</span> </pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">int</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> </pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">double</span> x<span class="token punctuation">;</span> <span class="token comment">// 重定义了基类中的 x</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li></ul></div></details><details class=info><summary>C++程序优化的方法?</summary><div><ul><li>空间足够时，可以将经常需要读取的资源，缓存在内存中</li><li>尽量减少大内存对象的构造与析构，考虑缓存暂时不用的对象，等待后续继续使用</li><li>尽量使用C++11的右值语义，减少临时对象的构造</li><li>简单的功能函数可以使用内联。少用继承，多用组合，尽量减少继承层级</li><li>在循环遍历时，优化判断条件，减少循环次数</li><li>优化线程或进程的同步方式，能用原子操作的就不用锁。能应用层同步的就不用内核对象同步</li><li>优化堆内存的使用，如果有内存频繁的申请与释放，可以考虑内存池</li><li>优化线程的使用，节省系统资源与切换造成的性能损耗，线程使用频繁的可以考虑线程池</li><li>尽量使用事件通知，谨慎使用轮循或者sleep函数</li><li>界面开发中，耗时的业务代码不要放在UI线程中执行，使用单独的线程去异步处理耗时业务，提高界面响应速度</li><li>经常重构、优化代码结构。优化算法或者架构，从设计层面进行性能的优化</li></ul></div></details><details class=info><summary>C++11的RVO/NRVO机制？</summary><div><p>RVO和NRVO是C++中的两种优化机制，旨在优化函数返回值的构造和拷贝操作，提高程序的性能。</p><ul><li><p>RVO(Return Value Optimization) - RVO是一种优化手段，它尝试避免在函数返回时创建临时对象，而是直接将对象构造在调用者的栈上，从而减少对象的构造和拷贝开销。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token comment">// Without RVO</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyClass</span> </pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Constructor called"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=10></td><td><pre></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyClass<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=12></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Copy constructor called"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre></pre></td></tr><tr><td data-num=16></td><td><pre>MyClass <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=17></td><td><pre>    <span class="token keyword">return</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=19></td><td><pre></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=21></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=22></td><td><pre>    MyClass obj <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// RVO may optimize the copy away</span></pre></td></tr><tr><td data-num=23></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=24></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=25></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=26></td><td><pre><span class="token comment"> * 在上述例子中，如果没有RVO，</span></pre></td></tr><tr><td data-num=27></td><td><pre><span class="token comment"> * createObject函数返回时将调用拷贝构造函数。</span></pre></td></tr><tr><td data-num=28></td><td><pre><span class="token comment"> * 但是，RVO可能会优化掉这个拷贝步骤，直接在main函数中构造obj对象。</span></pre></td></tr><tr><td data-num=29></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure></li><li><p>NRVO(Named Return Value Optimization) - NRVO是RVO的一种特殊情况，它发生在函数中明确命名了要返回的对象，并且在函数中只有一个这样的对象。编译器会尝试直接在调用者的栈上构造这个对象，而不是在函数内部创建临时对象再进行拷贝</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token comment">// Without NRVO</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyClass</span> </pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Constructor called"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=10></td><td><pre></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyClass<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=12></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Copy constructor called"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre></pre></td></tr><tr><td data-num=16></td><td><pre>MyClass <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=17></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=18></td><td><pre>    MyClass tempObject<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=19></td><td><pre>    <span class="token keyword">return</span> tempObject<span class="token punctuation">;</span><span class="token comment">// NRVO may optimize the copy away</span></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=21></td><td><pre></pre></td></tr><tr><td data-num=22></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=23></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=24></td><td><pre>    MyClass obj <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=25></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=26></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=27></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=28></td><td><pre><span class="token comment"> * 在上述例子中，如果没有NRVO，</span></pre></td></tr><tr><td data-num=29></td><td><pre><span class="token comment"> * createObject函数返回时将调用拷贝构造函数。</span></pre></td></tr><tr><td data-num=30></td><td><pre><span class="token comment"> * 但是，如果启用了NRVO，编译器可能会优化掉这个拷贝步骤，</span></pre></td></tr><tr><td data-num=31></td><td><pre><span class="token comment"> * 直接在main函数中构造obj对象。</span></pre></td></tr><tr><td data-num=32></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure></li></ul></div></details><details class=info><summary>Code Dump是什么？</summary><div><p>&quot;Code dump&quot;(代码转储)通常指的是在程序运行时由于错误或异常导致的进程崩溃，系统将当前程序的内存内容转储到磁盘上的文件中。这个文件通常称为&quot;core dump&quot;或&quot;core文件&quot;。Code dump中包含了程序崩溃时的内存快照，可以通过分析这个转储文件来了解程序崩溃的原因。</p><p><strong>产生Code Dump的情况</strong></p><ul><li>段错误(Segmentation Fault) - 当程序试图访问未分配的内存或者越界访问时，操作系统会强制终止程序并生成core dump</li><li>非法指令 - 如果程序执行了非法的机器指令，也会导致进程崩溃并生成core dump</li><li><strong>除以零</strong> - 当程序试图除以零时，通常会导致浮点异常，从而生成core dump</li></ul><p><strong>预防Code Dump</strong></p><ul><li><p>合理的边界检查 - 避免数组越界、指针空指针引用等</p></li><li><p>异常处理 - 在<code>C++</code>中使用异常处理机制，可以在发生错误时优雅地处理异常情况，而不是导致程序崩溃</p></li><li><p>避免野指针和空指针 - 对指针进行良好的管理，确保在使用指针前进行初始化，并在使用后及时释放</p></li><li><p>合理的资源管理 - 使用智能指针等RAII机制，以确保资源正确释放</p></li><li><p>良好的代码规范 - 编写规范的、易于理解的代码，可以减少出错的可能性</p></li></ul></div></details><details class=info><summary>C++中另一文件可以调用其他文件中的函数？</summary><div><p><code>C++</code>允许在一个文件中定义的函数被其他文件调用。这通常通过使用头文件(header file)和源文件(source file)的组合来实现。</p></div></details><details class=info><summary>C++的编程范式是什么？</summary><div><p>编程范式是一种编程风格或方法论，它是一套规则和约定，指导程序员如何组织、设计和实现计算机程序。不同的编程范式强调不同的概念和原则，影响着程序的结构、可读性、可维护性和扩展性。</p><p><code>C++</code>是一种多范式编程语言，支持多种编程范式的混合使用。<code>C++</code>中常见的编程范式有</p><ul><li>过程式编程(Procedural Programming) - 使用函数和程序结构化的思维方式</li><li>面向对象编程(Object-Oriented Programming - OOP) - <code>C++</code>最强调的编程范式之一，支持类、封装、继承和多态</li><li>泛型编程(Generic Programming) - 使用模板实现泛型编程，允许编写与数据类型无关的代码</li><li>函数式编程(Functional Programming) - 支持Lambda表达式、函数对象和STL算法等功能，允许使用函数式编程的思想</li><li>元编程(Metaprogramming) - 利用模板元编程实现在编译期进行计算和代码生成</li><li>并发编程(Concurrent Programming) - <code>C++</code>提供了多线程支持，允许通过<code>std::thread</code>等类实现并发编程</li></ul></div></details><details class=info><summary>main函数执行前后会执行什么代码？(C++程序执行流程？)</summary><div><ul><li><p>执行前</p><ul><li><p><strong>全局变量初始化</strong> - 在 <code>main</code> 函数执行之前，所有的全局变量和静态变量会被初始化。全局变量和静态变量的初始化顺序与它们的声明顺序有关，但跨文件的初始化顺序是不确定的</p></li><li><p><strong>调用构造函数</strong> - 对象的构造函数会在程序开始时被调用。这包括全局对象、静态对象以及定义在 <code>main</code> 函数之外的其他函数中的静态对象</p></li></ul></li><li><p>main函数执行 - <code>main</code>函数是程序的入口点，程序从<code>main</code>函数开始执行。<code>main</code>函数返回时，程序结束执行</p></li><li><p>执行后</p><ul><li><strong>全局变量和静态变量的析构函数</strong> - 在程序结束时，所有的全局变量和静态变量的析构函数会被调用。析构函数的调用顺序与构造函数的调用顺序相反</li></ul></li></ul><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyObject</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token function">MyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Constructor called!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=8></td><td><pre></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token operator">~</span><span class="token function">MyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Destructor called!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre></pre></td></tr><tr><td data-num=14></td><td><pre>MyObject globalObject<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=17></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Inside main function!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=18></td><td><pre>    MyObject localObject<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=19></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上述示例中，程序执行顺序如下</p><ol><li>构造函数<code>MyObject::MyObject()</code>被调用，初始化全局变量<code>globalObject</code></li><li><code>main</code>函数开始执行，构造函数<code>MyObject::MyObject()</code>被调用，初始化局部变量<code>localObject</code></li><li><code>main</code>函数执行完毕，局部变量<code>localObject</code>的析构函数<code>MyObject::~MyObject()</code>被调用</li><li><code>main</code>函数返回，程序结束执行，全局变量<code>globalObject</code>的析构函数<code>MyObject::~MyObject()</code>被调用</li></ol><p>不同的编译器和操作系统可能有不同的实现细节。</p></div></details><details class=info><summary>总结c++中四种变量存储类型？</summary><div><p>变量的存储类共有四种。</p><p><strong>auto存储类(自动存储类/自动变量)</strong></p><ul><li>auto存储类，即自动存储类。在函数内部定义的变量，如果不指定其存储类，那么它就是auto类变量，因此平常变量声明时不加关键字auto</li><li>自动存储类在在进入代码块(函数)之前生成，在函数体内部存活，出了函数体(函数返回)后就消失</li><li>自动变量默认初始值是不确定的</li><li>自动存储类每调用一次函数时都要赋一次初始值</li></ul><p><strong>static存储类 (静态存储类/静态变量)</strong></p><ul><li><code>static</code>关键字修饰的变量，被修饰的变量将会受到限制</li></ul><p><strong>extern存储类 (外部存储类/外部变量)</strong></p><ul><li>extern关键字修饰的变量。如果在一个文件中要引用另一个文件中定义的外部变量，则在此文件中应用extern关键字把此变量说明为外部的</li></ul><p><strong>register存储类(寄存器存储类/寄存器变量)</strong></p><ul><li>为了提高某些自动类变量或函数参数的处理速度，可以在定义这些变量的类型说明符的前面加上register关键字，以通知编译系统为这些变量分配寄存器来存放其值。若使用register(而非auto)存储类标识代码块内的变量，编译器就会将变量缓存于处理器内的寄存器中，此种情况下不能对该变量或其成员变量使用引用操作符&amp;以获取其地址，因为&amp;只能获取内存空间中的地址</li></ul></div></details><div class=tags><a href=/tags/programming-language/ rel=tag><i class="ic i-tag"></i> 编程语言</a></div></div><footer><div class=meta><span class=item><span class=icon><i class="ic i-calendar-check"></i></span> <span class=text>更新于</span> <time title="修改时间：2024-07-21 14:50:57" itemprop=dateModified datetime=2024-07-21T14:50:57+08:00>2024-07-21</time></span><span class=item data-path=/computer-science/programming/c-language/basis/c++/cpppart3/ title=阅读次数><span class=icon><i class="ic i-eye"></i></span> <span class=text>阅读次数</span><span class=waline-pageview-count></span> <span class=text>次</span></span></div><div id=copyright><ul><li class=author><strong>本文作者：</strong> ReverseSacle <i class="ic i-at"><em>@</em></i>逆转天平</li><li class=link><strong>本文链接：</strong> <a href=https://www.reversesacle.com/computer-science/programming/c-language/basis/c++/cpppart3/ title=C++基础知识-第三部分-C++11标准>https://www.reversesacle.com/computer-science/programming/c-language/basis/c++/cpppart3/</a></li><li class=license><strong>版权声明：</strong> 本站所有文章除特别声明外，均采用 <span class=exturl data-url=aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class=post-nav><div class="item left"><a href=/computer-science/programming/c-language/basis/c++/cpppart2/ itemprop=url rel=prev data-background-image=https:&#x2F;&#x2F;resa-imgs.oss-accelerate.aliyuncs.com&#x2F;img&#x2F;acg10.webp title=C++基础知识-第二部分-C++98&#x2F;03标准><span class=type>上一篇</span><span class=category><i class="ic i-flag"></i> C++基础</span><h3>C++基础知识-第二部分-C++98/03标准</h3></a></div><div class="item right"><a href=/computer-science/programming/c-language/c-data-structure/linear-structure/seqlist/ itemprop=url rel=next data-background-image=https:&#x2F;&#x2F;resa-imgs.oss-accelerate.aliyuncs.com&#x2F;img&#x2F;acg18.webp title=C语言-顺序表><span class=type>下一篇</span><span class=category><i class="ic i-flag"></i> C语言</span><h3>C语言-顺序表</h3></a></div></div><div class=wrap id=comments><div id=waline-comment></div></div></div><div id=sidebar><div class=inner><div class=panels><div class=inner><div class="contents panel pjax" data-title=文章目录><ol class=toc><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96list-initialization><span class=toc-number>1.</span> <span class=toc-text>列表初始化(List-initialization)</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%96%B0%E5%A2%9E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%89%B9%E6%80%A7><span class=toc-number>2.</span> <span class=toc-text>新增数据类型及特性</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC><span class=toc-number>3.</span> <span class=toc-text>auto类型推导</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E4%BD%BF%E7%94%A8using%E5%AE%9A%E4%B9%89%E5%88%AB%E5%90%8D><span class=toc-number>4.</span> <span class=toc-text>使用using定义别名</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#for%E5%BE%AA%E7%8E%AF%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84%E5%BE%AA%E7%8E%AF><span class=toc-number>5.</span> <span class=toc-text>for循环(基于范围的循环)</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%96%B0%E5%A2%9E%E7%BB%93%E6%9E%84%E4%BD%93%E7%89%B9%E6%80%A7><span class=toc-number>6.</span> <span class=toc-text>新增结构体特性</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%96%B0%E5%A2%9E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%93%8D%E4%BD%9C%E7%89%B9%E6%80%A7><span class=toc-number>7.</span> <span class=toc-text>新增内存管理操作特性</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%96%B0%E5%A2%9E%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7><span class=toc-number>8.</span> <span class=toc-text>新增类和对象特性</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%96%B0%E5%A2%9E%E5%AE%9A%E4%B9%89><span class=toc-number>8.1.</span> <span class=toc-text>新增定义</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%96%B0%E5%A2%9E%E5%B0%81%E8%A3%85%E7%89%B9%E6%80%A7><span class=toc-number>8.2.</span> <span class=toc-text>新增封装特性</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E8%AF%AD%E5%8F%A5><span class=toc-number>8.2.1.</span> <span class=toc-text>移动构造语句</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E8%AF%AD%E5%8F%A5><span class=toc-number>8.2.2.</span> <span class=toc-text>委托构造语句</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD><span class=toc-number>8.2.3.</span> <span class=toc-text>强制转换运算符重载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%96%B0%E5%A2%9E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6><span class=toc-number>9.</span> <span class=toc-text>新增异常处理机制</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%96%B0%E5%A2%9E%E6%A8%A1%E6%9D%BF%E6%B3%9B%E5%9E%8B%E7%89%B9%E6%80%A7><span class=toc-number>10.</span> <span class=toc-text>新增模板(泛型)特性</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0><span class=toc-number>10.1.</span> <span class=toc-text>支持函数的默认模板参数</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#decltype%E5%85%B3%E9%94%AE%E5%AD%97><span class=toc-number>10.2.</span> <span class=toc-text>decltype关键字</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%87%BD%E6%95%B0%E5%90%8E%E7%BD%AE%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B><span class=toc-number>10.3.</span> <span class=toc-text>函数后置返回类型</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF><span class=toc-number>10.4.</span> <span class=toc-text>可变参数列表(变参模板)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%96%B0%E5%A2%9E%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E5%BA%93><span class=toc-number>10.5.</span> <span class=toc-text>新增模板类&#x2F;函数模板相关工具库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%96%B0%E5%A2%9E%E5%BC%95%E7%94%A8%E7%89%B9%E6%80%A7><span class=toc-number>11.</span> <span class=toc-text>新增引用特性</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8rvalue-reference><span class=toc-number>11.1.</span> <span class=toc-text>右值引用(Rvalue Reference)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E9%80%9A%E7%94%A8%E5%BC%95%E7%94%A8universal-reference><span class=toc-number>11.2.</span> <span class=toc-text>通用引用(Universal Reference)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%BD%AC%E7%A7%BB%E8%AF%AD%E4%B9%89%E7%A7%BB%E5%8A%A8%E8%AF%AD%E5%8F%A5transfer-semantics><span class=toc-number>11.3.</span> <span class=toc-text>转移语义&#x2F;移动语句(Transfer Semantics)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91perfect-forwarding><span class=toc-number>11.4.</span> <span class=toc-text>完美转发(Perfect Forwarding)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80><span class=toc-number>12.</span> <span class=toc-text>静态断言</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88><span class=toc-number>13.</span> <span class=toc-text>智能指针</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%A6%82%E5%BF%B5><span class=toc-number>13.1.</span> <span class=toc-text>概念</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B><span class=toc-number>13.2.</span> <span class=toc-text>智能指针类型</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%88%A0%E9%99%A4%E5%99%A8><span class=toc-number>13.3.</span> <span class=toc-text>删除器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8Flambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0><span class=toc-number>14.</span> <span class=toc-text>lambda表达式&#x2F;lambda匿名函数</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%96%B0%E5%A2%9E%E6%A8%A1%E6%9D%BF%E7%89%B9%E6%80%A7><span class=toc-number>15.</span> <span class=toc-text>新增模板特性</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%96%B0%E5%A2%9E%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%89%B9%E6%80%A7><span class=toc-number>15.1.</span> <span class=toc-text>新增类模板特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%96%B0%E5%A2%9E%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93stl><span class=toc-number>16.</span> <span class=toc-text>新增标准模板库(STL)</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%AE%97%E6%B3%95%E5%BA%93><span class=toc-number>16.1.</span> <span class=toc-text>算法库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#c11%E6%96%B0%E6%A0%87%E5%87%86%E5%88%97%E4%B8%BE><span class=toc-number>17.</span> <span class=toc-text>C++11新标准列举</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%96%B0%E6%A0%87%E5%87%86%E5%88%97%E4%B8%BE><span class=toc-number>17.1.</span> <span class=toc-text>新标准列举</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%BA%BF%E7%A8%8B><span class=toc-number>17.2.</span> <span class=toc-text>线程</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5><span class=toc-number>17.3.</span> <span class=toc-text>线程同步</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-%E7%94%9F%E6%88%90%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B><span class=toc-number>17.4.</span> <span class=toc-text>条件变量 - 生成&#x2F;消费者模型</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8Batomic><span class=toc-number>17.5.</span> <span class=toc-text>原子类型atomic</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%9B%B8%E5%85%B3%E8%A1%A5%E5%85%85%E9%A1%B9><span class=toc-number>18.</span> <span class=toc-text>相关补充项</span></a></li></ol></div><div class="related panel pjax" data-title=系列文章><ul><li><a href=/computer-science/programming/c-language/basis/c++/cpppart1/ rel=bookmark title=C++基础知识-第一部分-C++98/03标准>C++基础知识-第一部分-C++98/03标准</a></li><li><a href=/computer-science/programming/c-language/basis/c++/cpppart2/ rel=bookmark title=C++基础知识-第二部分-C++98/03标准>C++基础知识-第二部分-C++98/03标准</a></li><li class=active><a href=/computer-science/programming/c-language/basis/c++/cpppart3/ rel=bookmark title=C++基础知识-第三部分-C++11标准>C++基础知识-第三部分-C++11标准</a></li></ul></div><div class="overview panel" data-title=站点概览><div class=author itemprop=author itemscope itemtype=http://schema.org/Person><img class=image itemprop=image alt=ReverseSacle data-src=/images/avatar.webp><p class=name itemprop=name>ReverseSacle</p><div class=description itemprop=description>知识书库 & 学习点滴</div></div><nav class=state><div class="item posts"><a href=/archives/ ><span class=count>186</span> <span class=name>文章</span></a></div><div class="item categories"><a href=/categories/ ><span class=count>52</span> <span class=name>分类</span></a></div><div class="item tags"><a href=/tags/ ><span class=count>18</span> <span class=name>标签</span></a></div></nav><div class=social><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JldmVyc2VTYWNsZQ==" title=https:&#x2F;&#x2F;github.com&#x2F;ReverseSacle><i class="ic i-github"></i></span><span class="exturl item email" data-url="bWFpbHRvOnByaXZhdGVAcmV2ZXJzZXNhY2xlLmNvbQ==" title=mailto:private@reversesacle.com><i class="ic i-envelope"></i></span></div><ul class=menu><li class=item><a href=/ rel=section><i class="ic i-home"></i> 首页</a></li><li class="item dropdown"><a href=javascript:void(0);><i class="ic i-feather"></i> 文章</a><ul class=submenu><li class=item><a href=/archives/ rel=section><i class="ic i-list-alt"></i> 归档</a></li><li class=item><a href=/categories/ rel=section><i class="ic i-th"></i> 分类</a></li><li class=item><a href=/tags/ rel=section><i class="ic i-tags"></i> 标签</a></li></ul></li><li class=item><a href=/about/ rel=section><i class="ic i-user"></i> 关于</a></li><li class=item><a href=/friend-links/ rel=section><i class="ic i-heart"></i> 友链</a></li></ul></div></div></div><ul id=quick><li class="prev pjax"><a href=/computer-science/programming/c-language/basis/c++/cpppart2/ rel=prev title=上一篇><i class="ic i-chevron-left"></i></a></li><li class=up><i class="ic i-arrow-up"></i></li><li class=down><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href=/computer-science/programming/c-language/c-data-structure/linear-structure/seqlist/ rel=next title=下一篇><i class="ic i-chevron-right"></i></a></li><li class=percent></li></ul></div></div><div class=dimmer></div></div></main><footer id=footer><div class=inner><div class=widgets><div class="rpost pjax"><h2>随机文章</h2><ul><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/rust/ title="分类于 Rust">Rust</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/rust/rust-basic/ title="分类于 Rust基础">Rust基础</a></div><span><a href=/computer-science/programming/rust/rust-basic/rustpart1/ title=Rust语言-基础-第一部分>Rust语言-基础-第一部分</a></span></li><li class=item><div class=breadcrumb><a href=/categories/general-science-and-technology/ title="分类于 通用科学技术">通用科学技术</a><i class="ic i-angle-right"></i> <a href=/categories/general-science-and-technology/pc/ title="分类于 通用技术之PC端">通用技术之PC端</a><i class="ic i-angle-right"></i> <a href=/categories/general-science-and-technology/pc/laptop/ title="分类于 笔记本">笔记本</a></div><span><a href=/general-science-and-technology/pc/laptop/occupied-cpu-by-lenovo-isf/ title=占用CPU的Lenovo-ISFramework>占用CPU的Lenovo-ISFramework</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a></div><span><a href=/computer-science/programming/c-language/c-data-structure/linear-structure/seqqueue/ title=C语言-顺序队列>C语言-顺序队列</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/algorithm/ title="分类于 算法">算法</a></div><span><a href=/computer-science/programming/algorithm/pattern-search/knuth%E2%80%93morris%E2%80%93pratt/ title=Knuth–Morris–Pratt(KMP)>Knuth–Morris–Pratt(KMP)</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/algorithm/ title="分类于 算法">算法</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/algorithm/sort/ title="分类于 序列重组">序列重组</a></div><span><a href=/computer-science/programming/algorithm/sort/selection-sort/ title=选择排序>选择排序</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/c-data-structure/ title="分类于 C语言数据结构">C语言数据结构</a></div><span><a href=/computer-science/programming/c-language/c-data-structure/queue/ title=线性表之队列>线性表之队列</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/dynamic-program/ title="分类于 动态规划">动态规划</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/dynamic-program/abstract/ title=动态规划-抽象>动态规划-抽象</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/two-pointer/ title="分类于 双指针">双指针</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/two-pointer/search/ title=双指针-查找>双指针-查找</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/network-programming/ title="分类于 网络编程">网络编程</a></div><span><a href=/computer-science/programming/network-programming/signal/ title=Linux的信号(signal)>Linux的信号(signal)</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/c-basic/ title="分类于 C语言基础">C语言基础</a></div><span><a href=/computer-science/programming/c-language/basis/c/cpart1/ title=C语言基础-第一部分-C89&#x2F;C90标准>C语言基础-第一部分-C89/C90标准</a></span></li></ul></div><div><h2>最新评论</h2><ul id=waline-recent></ul></div></div><div class=status><div class=copyright>&copy; 2021 – <span itemprop=copyrightYear>2025</span><span class=with-love><i class="ic i-sakura rotate"></i></span> <span class=author itemprop=copyrightHolder>ReverseSacle @ ReverseSacle-Blog</span></div><div class=count><i class="ic i-clock" aria-hidden=true></i> <span id=time align=center>载入时间中...<script defer>var now=new Date;function createtime(){var n=new Date("2021-11-16 22:30:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("time").innerHTML="已经过 "+dnum+" 天 "+hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></span><span class=post-meta-item-icon>|&nbsp<i class="ic i-chart-area"></i></span> <span title=站点总字数>2.1m 字</span> <span class=post-meta-item-icon>|&nbsp<i class="ic i-coffee"></i></span> <span title=站点阅读时长>40:40</span></div></div></div></footer></div><script data-config>var LOCAL={path:"computer-science/programming/c-language/basis/c++/cpppart3/",favicon:{show:"ReverseSacle-Blog",hide:"ReverseSacle-Blog"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},waline:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src=https://polyfill.alicdn.com/v3/polyfill.min.js></script><script src=https://cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1.16.0/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js></script><script src=/js/app.js></script></body></html>