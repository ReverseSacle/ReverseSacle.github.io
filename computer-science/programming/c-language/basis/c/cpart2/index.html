<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content=#222><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=icon type=image/ico sizes=48x48 href=/images/favicon.ico><link rel=alternate type=application/rss+xml title=逆转天平 href=https://www.reversesacle.com/rss.xml><link rel=alternate type=application/atom+xml title=逆转天平 href=https://www.reversesacle.com/atom.xml><link rel=alternate type=application/json title=逆转天平 href=https://www.reversesacle.com/feed.json><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel=stylesheet href=/css/app.css><meta name=description content=编程语言><link rel=canonical href=https://www.reversesacle.com/computer-science/programming/c-language/basis/c/cpart2/ ><title>C语言基础-第二部分-C89/C90标准 - C语言基础 - C语言 - 编程 - 计算机科学 | ReverseSacle-Blog</title><meta name=generator content="Hexo 6.3.0"></head><body itemscope itemtype=http://schema.org/WebPage><div id=loading><div class=dotloader><div class=dot></div><div class=dot></div><div class=dot></div><div class=dot></div><div class=dot></div></div></div><div id=container><header id=header itemscope itemtype=http://schema.org/WPHeader><div class=inner><div id=brand><div class=pjax><h1 itemprop="name headline">C语言基础-第二部分-C89/C90标准</h1><div class=meta><span class=item title="创建时间：2022-02-17 16:55:49"><span class=icon><i class="ic i-calendar"></i></span> <span class=text>发表于</span> <time itemprop="dateCreated datePublished" datetime=2022-02-17T16:55:49+08:00>2022-02-17</time></span><span class=item title=本文字数><span class=icon><i class="ic i-pen"></i></span> <span class=text>本文字数</span> <span>34k</span> <span class=text>字</span></span><span class=item title=阅读时长><span class=icon><i class="ic i-clock"></i></span> <span class=text>阅读时长</span> <span>39 分钟</span></span></div></div></div><nav id=nav><div class=inner><div class=toggle><div class=lines role=navigation aria-label=切换导航栏><span class=line></span><span class=line></span><span class=line></span></div></div><ul class=menu><li class="item title"><a href=/ rel=start>ReverseSacle-Blog</a></li></ul><ul class=right><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id=imgs class=pjax><ul><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg18.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg7.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg10.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg6.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg17.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg14.webp></li></ul></div></header><div id=waves><svg class=waves xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink viewBox="0 24 150 28" preserveAspectRatio=none shape-rendering=auto><defs><path id=gentle-wave d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352z"/></defs><g class=parallax><use xlink:href=#gentle-wave x=48 y=0 /><use xlink:href=#gentle-wave x=48 y=3 /><use xlink:href=#gentle-wave x=48 y=5 /><use xlink:href=#gentle-wave x=48 y=7 /></g></svg></div><main><div class=inner><div id=main class=pjax><div class="article wrap"><div class=breadcrumb itemscope itemtype=https://schema.org/BreadcrumbList><i class="ic i-home"></i> <span><a href=/ >首页</a></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/ itemprop=item rel=index title="分类于 计算机科学"><span itemprop=name>计算机科学</span></a><meta itemprop=position content=1></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/programming/ itemprop=item rel=index title="分类于 编程"><span itemprop=name>编程</span></a><meta itemprop=position content=2></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/programming/c-language/ itemprop=item rel=index title="分类于 C语言"><span itemprop=name>C语言</span></a><meta itemprop=position content=3></span><i class="ic i-angle-right"></i> <span class=current itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/programming/c-language/c-basic/ itemprop=item rel=index title="分类于 C语言基础"><span itemprop=name>C语言基础</span></a><meta itemprop=position content=4></span></div><article itemscope itemtype=http://schema.org/Article class="post block" lang=zh-CN><link itemprop=mainEntityOfPage href=https://www.reversesacle.com/computer-science/programming/c-language/basis/c/cpart2/ ><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content=/images/avatar.webp><meta itemprop=name content=ReverseSacle><meta itemprop=description content="所见即所得，所思即所行, 知识书库 & 学习点滴"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content=逆转天平></span><div class="body md" itemprop=articleBody><h2 id=内存操作与管理><a class=anchor href=#内存操作与管理>#</a> 内存操作与管理</h2><h3 id=系统内存布局><a class=anchor href=#系统内存布局>#</a> 系统内存布局</h3><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/c/basic/1.webp alt=""></p><p><strong>栈区(stack)</strong></p><p>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元会被自动释放。</p><p>栈内存的分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。栈区主要存放运行函数时分配的<strong>函数参数，返回数据，返回地址，局部变量</strong>等。</p><p>当栈区的内存被耗尽时，便会出现<code>stack overflow</code>(栈溢出)错误。</p><ul><li>栈的内存是系统自动管理的，当内存空间离开作用域时会自动释放</li><li>栈的内存大小一般只有8M(可以通过修改系统参数来更改 - Linux)</li><li>栈的内存分配方式有静态分配和动态分配，两者的内存空间在离开作用域时都会自动释放</li><li>栈是系统提供的数据结构，计算机底层提供了对栈的支持，有专门的指令，分配效率比较高</li><li>栈使用的是一级缓存，有严格的执行规则，不会产生内存碎片</li><li>栈是以降序从上往下分配内存</li></ul><p><strong>堆区(heap)</strong></p><p>由程序员手动分配和释放，分配方式类似于链表，若不释放，程序结束后可能由操作系统(OS)回收。</p><ul><li>堆的内存大小受限于物理内存空间</li><li>堆的内存分配方式只有动态分配</li><li>当堆内存被频繁分配和释放时，会产生内存碎片，导致性能下降</li><li>堆则是存放在二级缓存中</li><li>堆是以升序从下往上分配内存</li></ul><p><strong>数据段/静态区(static)</strong></p><p>数据段在操作系统中被称为<strong>静态区</strong>，用于存放全局变量，静态数据，程序结束后由系统释放。</p><p><strong>代码段(text segment)</strong></p><p>存放函数体(<code>C++</code>类成员函数和全局函数)的二进制代码。还包含，全局变量和静态变量的初始化值、字符串常量。</p><p><strong>相关概念</strong></p><p>(<strong>Out Of Memory - OOM</strong>) - 内存溢出，是指需要的内存空间大于系统分配的内存空间。</p><p><strong>Memory Leak</strong> - 内存泄漏，是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p><details class=info><summary>C语言中内存分配的方式有几种？</summary><div><ul><li><p>静态存储区分配 - 内存分配在程序编译之前完成，且在程序的整个运行期间都存在，例如全局变量、静态变量等</p></li><li><p>栈上分配 - 在函数执行时，函数内的局部变量的存储单元在栈上创建，函数执行结束时这些存储单元自动释放局部变量、函数内参数都在栈上</p></li><li><p>堆上分配 - new开辟的空间在堆上</p></li></ul></div></details><details class=info><summary>c/c++参数入栈顺序是什么？为什么？</summary><div><p>参数入栈顺序是指将实际参数传递给函数时，这些参数在栈上的存储顺序。通常，参数是从右往左入栈的，即右边的参数先入栈，左边的参数后入栈。这是因为栈是一种先进后出的数据结构，从右往左入栈可以方便地实现参数的逆序访问。</p></div></details><details class=info><summary>C语言函数调用的压栈过程是什么？</summary><div><ul><li><p><strong>保存返回地址</strong> - 当一个函数被调用时，调用指令会将下一条指令的地址(返回地址)压入栈中。这样，在函数执行完毕后，程序可以通过该地址返回到调用函数</p></li><li><p><strong>为局部变量分配空间</strong> - 分配一段内存用于存储函数的局部变量。这些局部变量通常存储在栈上，以便在函数调用结束时自动释放</p></li><li><p><strong>将实际参数压栈</strong> - 将调用函数时传递的实际参数按照从右到左的顺序依次压入栈中</p></li><li><p><strong>跳转到被调用函数的入口点</strong> - 使用跳转指令(如<code>call</code>指令)将控制权转移给被调用函数的入口点，即函数的第一条指令</p></li></ul><p>在函数执行完毕后，会执行以下步骤</p><ul><li><p><strong>弹出实际参数</strong> - 被调用函数通过移动栈指针来弹出压入栈的实际参数</p></li><li><p><strong>释放局部变量空间</strong> - 栈指针移动回函数调用前的位置，释放局部变量的空间</p></li><li><p><strong>恢复返回地址</strong> - 从栈中弹出保存的返回地址，并跳转到该地址，使控制权返回到调用函数的下一条指令</p></li></ul></div></details><details class=info><summary>栈帧(Stack Frame)是什么？</summary><div><p>栈帧也称为活动记录(Activation Record)或帧(Frame)，是函数调用栈中的一个部分，用于存储与特定函数调用相关的信息。每次函数被调用时，都会在栈上创建一个新的栈帧，用于管理该函数调用的局部变量、参数、返回地址等信息。栈帧的创建和销毁与函数的调用和返回密切相关。</p></div></details><details class=info><summary>函数调用栈(Function Call Stack)是什么？</summary><div><p>函数调用栈是计算机程序执行中用于管理函数调用和局部变量的一种数据结构。它以栈的形式组织，具体而言，是一个后进先出的数据结构。在程序执行期间，每个函数的调用都会在栈上创建一个新的帧，用于存储函数的局部变量、参数、返回地址等信息。</p></div></details><details class=info><summary>栈为什么要有上限？</summary><div><p>栈有上限是由于栈的工作原理和底层硬件的限制所决定的。栈是一种具有后进先出特性的数据结构，它用于存储函数调用的信息、局部变量等。栈的大小在编译时或运行时就被固定下来，主要有以下原因</p><ul><li><p><strong>硬件限制</strong> - 计算机的硬件架构在设计时通常会为每个线程分配一个固定大小的栈空间。这个大小是由操作系统或编译器设置的，取决于具体的操作系统和体系结构。分配大量栈空间可能会导致内存资源的浪费，而分配过小可能导致栈溢出</p></li><li><p><strong>快速访问</strong> - 栈上的数据是通过简单的指针操作进行访问的，这使得栈上的内存访问速度非常快。然而，为了保证这种快速访问，栈的大小必须是固定的，以便在编译时或运行时就能够计算出相对于栈底的偏移</p></li><li><p><strong>栈帧的管理</strong> - 每个函数调用都会在栈上创建一个新的栈帧，栈帧包含了函数的局部变量、返回地址等信息。如果栈的大小不固定，那么在运行时动态调整栈帧的大小将会变得非常复杂</p></li><li><p><strong>安全性</strong> - 限制栈的大小可以防止无限递归或大量局部变量的使用导致栈溢出。栈溢出是一种严重的错误，可能导致程序崩溃</p></li></ul></div></details><details class=info><summary>只使用栈的缺点是什么？</summary><div><p><strong>有限的空间</strong> - 栈的大小通常是有限的，而且在编译时就被确定了。这意味着在栈上分配的内存空间有限，如果需要大量的内存(比如大型数组、大对象等)，栈可能会不够用</p><p><strong>生存期受限</strong> - 栈上分配的变量的生存期受到函数调用的限制。当一个函数结束时，其局部变量会被自动销毁，因此栈上的内存不再可用。这使得在函数之间传递数据和保留数据的状态变得更加复杂</p><p><strong>不灵活的内存管理</strong> - 栈上的内存由编译器自动管理，而且是以一种固定的方式进行分配和释放。这种自动管理的方式可能不够灵活，特别是在需要动态分配和释放内存的复杂场景中</p><p><strong>不适用于大型数据结构</strong> - 如果需要使用大型数据结构，比如大型链表或树，栈上的内存可能不足以容纳这些结构，从而迫使使用堆来分配更大的内存空间</p><p><strong>递归深度限制</strong> - 栈的大小也限制了函数调用的递归深度。如果递归层数太深，栈可能会溢出，导致程序崩溃</p></div></details><details class=info><summary>只使用堆的缺点是什么？</summary><div><p><strong>手动内存管理</strong> - 在堆上分配和释放内存通常需要手动管理，这可能导致内存泄漏或释放已释放内存的风险。忘记释放堆上的内存可能会导致内存泄漏，而提前释放内存可能导致悬挂指针(dangling pointers)问题。</p><p><strong>性能开销</strong> - 动态内存分配和释放可能比栈上的内存操作更耗时。堆上的内存分配通常涉及到搜索合适的块，而且由于内存分散在堆中，可能会导致缓存不命中，影响性能。</p><p><strong>碎片问题</strong> - 堆内存可能会出现碎片化，即已分配的内存块之间存在未分配的小块内存，这可能导致浪费一些内存空间，而且可能使得随着时间的推移，分配较大内存块的难度增加。</p><p><strong>不适用于一些特定情况</strong> - 有些情况下，堆上的内存分配并不适用。例如，对于一些实时系统或嵌入式系统，需要更可控、更可靠的内存分配，而堆上的分配可能无法满足这些要求。</p><p><strong>容易产生内存泄漏和悬挂指针</strong> - 由于手动管理堆上的内存，容易出现忘记释放内存或者释放后仍然保留指向已释放内存的指针的情况，从而导致内存泄漏和悬挂指针问题。</p></div></details><details class=info><summary>堆栈溢出(Stack Overflow)的情况以及解决方法？</summary><div><p>堆栈溢出是指程序的调用栈(stack)耗尽了分配给它的内存空间，通常由于递归调用深度过大或者函数调用层次嵌套过深而导致。栈用于存储函数调用的信息，包括局部变量、函数参数和返回地址等。当递归调用或函数调用嵌套层次过深时，每次调用都会在栈上分配一些内存，如果栈空间用尽，就会导致堆栈溢出。</p><p><strong>常见的堆栈溢出情况包括</strong></p><ul><li><p>递归调用深度过大 - 如果递归调用的深度很大，每一次递归调用都会在栈上分配一段内存，当递归层次很深时，栈空间可能被耗尽</p></li><li><p>函数调用层次嵌套过深 - 如果程序中存在大量的函数调用，导致调用栈的层次嵌套过深，也可能导致堆栈溢出</p></li></ul><p><strong>解决堆栈溢出的方法</strong></p><ul><li><p>优化递归或循环结构 - 如果是递归调用导致的堆栈溢出，可以尝试优化递归算法，减少递归深度或使用迭代替代递归</p></li><li><p>增加栈空间 - 可以通过编译器或操作系统的设置来增加程序的栈空间大小，但这并不是一个通用的解决方案，因为栈空间是有限的</p></li><li><p>使用堆而非栈 - 将一些局部变量的存储从栈移到堆上，以减轻栈的压力。这需要谨慎管理动态内存，以防止内存泄漏等问题</p></li></ul></div></details><details class=info><summary>段错误(Segmentation Fault)是什么？</summary><div><p>段错误是指程序试图访问其内存空间的一部分，但该部分并未分配给程序，或者程序没有权限访问该部分内存。这通常是由于程序中的错误引起的，可能是由于指针错误、数组越界、访问已释放的内存等。段错误通常涉及到对内存的非法访问，例如</p><ul><li>空指针引用</li><li>数组越界</li><li>内存空间释放后再次访问</li></ul></div></details><details class=info><summary>内存溢出(Memory Overflow)是什么？内存溢出的情况有哪些？</summary><div><p>内存溢出是指程序在运行时请求分配超过其能够使用或操作的内存空间的情况。当程序试图写入超过其分配的内存范围的数据时，就可能导致内存溢出问题。内存溢出通常有以下几种情况</p><ul><li>动态内存分配失败 - 行动态内存分配时，没有足够的内存可用，或者程序没有正确释放已分配的内存</li><li>栈溢出 - 当程序使用递归调用或过度深的函数调用栈时，栈空间可能耗尽，导致栈溢出</li><li>缓冲区溢出 - 当向数组或缓冲区中写入超过其分配空间的数据时，可能会导致缓冲区溢出，覆盖其他内存区域</li></ul></div></details><details class=info><summary>内存碎片是什么？如何减少内存碎片？</summary><div><p>内存碎片是指内存中已分配但无法被有效利用的小块空间，主要分为两种类型</p><ul><li><p>外部碎片 - 外部碎片是指内存中存在的、相对较小的、不连续的未分配内存块。虽然总的可用内存可能足够，但是由于内存空间被零散占用，使得大内存块无法被分配。外部碎片通常是由内存分配和释放操作的频繁发生导致的</p></li><li><p>内部碎片 - 内部碎片是指已分配给进程的内存块中未被有效利用的部分。这通常发生在内存分配器将一块比需要的更大的内存块分配给进程时。由于分配器无法将这块内存的未使用部分分配给其他请求，就会导致内部碎片</p></li></ul><p><strong>内存碎片可能导致以下问题</strong></p><ul><li>空间浪费 - 内存碎片导致了可用内存的浪费，系统无法充分利用已分配的内存</li><li>分配失败 - 外部碎片可能导致某些内存分配请求失败，即使总体上还有足够的内存</li></ul><p><strong>解决内存碎片的方法</strong></p><ul><li><p>内存池 - 使用内存池技术，将内存按照固定大小的块进行划分，从而降低外部碎片的发生</p></li><li><p>紧凑操作 - 定期进行内存紧凑操作，将零散的小内存块合并成更大的连续块，减少外部碎片的影响</p></li><li><p>使用更高级的内存分配策略 - 一些现代的内存分配器(如jemalloc、tcmalloc等)采用更复杂的算法，以减少碎片的产生</p></li><li><p>使用动态数据结构 - 采用动态数据结构(例如自平衡二叉树、红黑树)来管理内存分配，提高内存分配和释放的效率</p></li><li><p>使用内存池和缓存池 - 针对特定类型的对象，可以使用内存池和缓存池的概念，避免频繁的内存分配和释放操作</p></li></ul></div></details><h3 id=内存申请和释放><a class=anchor href=#内存申请和释放>#</a> 内存申请和释放</h3><p>需包含头文件 - <code>#include&lt;stdlib.h&gt;</code></p><p><code>void* malloc(size_t size)</code> - 申请一块连续的内存空间，但不初始化</p><p><code>void* calloc(size_t num,size_t size)</code> - 申请一块连续的内存空间并将内存空间中的每个字节初始化为0</p><p><code>void* realloc(void* ptr,size_t size)</code> - 对已申请的内存空间的大小进行调整，如果已申请的内存空间后面有足够的空间可追加，就直接追加，否则会在内存中找一块新的内存空间并释放旧的内存空间</p><p><code>void* free(void* ptr)</code> - 释放已申请的内存</p><p>申请的内存空间通过指针来接收，并通过对指针的操作来对已申请内存的空间进行相关操作。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token comment">// 申请一个大小为10个整型字节大小的数组</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">int</span><span class="token operator">*</span> arry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 不会自动初始化的内存申请</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> arry<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">// 手动初始化未初始化的内存空间</span></pre></td></tr><tr><td data-num=10></td><td><pre>    </pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token keyword">int</span><span class="token operator">*</span> arry2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 自动初始化的内存申请</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token function">realloc</span><span class="token punctuation">(</span>arry<span class="token punctuation">,</span><span class="token number">20</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 对已申请的内存空间的大小进行调整</span></pre></td></tr><tr><td data-num=13></td><td><pre>    </pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token comment">// 内存释放</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token function">free</span><span class="token punctuation">(</span>arry<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token function">free</span><span class="token punctuation">(</span>arry2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><details class=info><summary>内存分配原理与free函数原理？</summary><div><p><code>free</code>函数的原理涉及到内存管理的底层机制，主要包括内存块的分配和释放以及内存管理数据结构。</p><p><strong>内存分配的原理</strong></p><ul><li>内存池管理 - 典型的内存管理器使用内存池来存储已分配的内存块。内存池通常由一系列大小相等或相近的内存块组成</li><li>分配算法 - 当调用<code>malloc</code>或 <code>calloc</code>时，内存管理器会从内存池中找到足够大的空闲块，并标记为已分配。分配算法的选择可以影响性能，通常使用最佳适应算法或首次适应算法</li><li>内存块头部 - 每个已分配的内存块通常都有一个头部，用于存储关于该块的元数据，如块大小、是否已分配等</li></ul><p><strong><code>free</code>的原理</strong></p><ul><li>释放内存块 - 当调用<code>free</code>时，内存管理器将标记被释放的内存块为未分配状态</li><li>合并相邻空闲块 - 内存管理器可能会检查相邻的未分配块，并将它们合并成一个更大的未分配块，以避免碎片化</li><li>内存池维护 - 内存管理器还可能执行一些其他操作，如将已释放的内存块归还给操作系统(通过<code>sbrk</code>或<code>brk</code>等系统调用)，以减少整个程序的内存占用</li></ul></div></details><details class=info><summary>被free回收的内存是立即返还给操作系统吗？为什么？</summary><div><p>在一般情况下，<code>free</code>函数释放的内存并不总是立即返还给操作系统。这是因为内存管理器通常会使用一种称为<strong>延迟释放</strong>(delayed free)的机制来提高性能。</p><p>延迟释放的原理是，当调用<code>free</code>释放内存时，内存管理器通常不会立即将该内存块返回给操作系统。相反，它会将这块内存标记为可用，但并不立即返还给底层操作系统。这样做的原因主要有</p><ul><li><strong>性能优化</strong> - 操作系统内存管理开销较大，频繁地向操作系统请求分配和释放内存可能导致性能下降。通过延迟释放，内存管理器可以在未来的内存分配中重用已经释放的内存块，减少与操作系统的交互次数</li><li><strong>内存碎片</strong> - 立即返还内存给操作系统可能导致内存碎片的增加。延迟释放允许内存管理器更灵活地合并和组织内存块，以降低碎片化的程度</li><li><strong>分配策略</strong> - 某些内存管理器使用不同的分配策略，可能会保留一些内存块以提高性能。这种情况下，释放的内存可能被保留供将来使用</li></ul><p>虽然延迟释放有助于提高性能和减少内存碎片，但在某些情况下，可能需要手动触发内存的立即返还。</p></div></details><details class=info><summary>静态内存分配和动态内存分配有什么区别？</summary><div><ul><li>静态内存分配是在编译时期完成的，不占用CPU资源；动态内存分配是在运行时期完成的，分配和释放需要占用CPU资源</li><li>静态内存分配是在栈上分配的；动态内存分配是在堆上分配的</li><li>静态内存分配不需要指针或引用类型的支持；动态内存分配需要</li><li>静态内存分配是按计划分配的，在编译前确定内存块的大小；动态内存分配是按需要分配的</li><li>静态内存分配是把内存的控制权交给了编译器；动态内存分配是把内存的控制权给了程序员</li><li>静态内存分配的运行效率比动态内存分配高，动态内存分配不当可能造成内存泄漏</li></ul></div></details><details class=info><summary>可以在栈上动态分配内存吗？怎么做？</summary><div><p>在一些编程语言和特定的情境下，可以通过使用一些特殊的函数或语法来在栈上动态分配内存。在C语言中，<code>alloca</code>函数(不是标准C库的一部分)可用于在栈上分配内存空间，在函数返回时会被自动释放。</p><p><code>alloca</code>函数能够在栈上分配内存的原因是因为它使用了函数调用栈上的空间，实现方式是增加栈指针(stack pointer)来分配一段连续的内存空间，然后在函数返回时自动回收这些空间。</p></div></details><h3 id=常见与内存有关的错误操作><a class=anchor href=#常见与内存有关的错误操作>#</a> 常见与内存有关的错误操作</h3><p>解引用空指针(NULL)❌</p><p>解引用未初始化的指针❌</p><p>越界访问动态开辟的内存空间❌</p><p>对非动态开辟的内存进行释放操作❌</p><p>对需整体使用的内存进行内存空间的部分释放❌</p><p>对已释放的内存再次进行释放操作❌</p><p>忘记对已动态开辟的内存进行释放操作(会造成内存泄漏)❌</p><h3 id=指针作为参数传递><a class=anchor href=#指针作为参数传递>#</a> 指针作为参数传递</h3><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment">// 传值传递，错误操作</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment">// 形参str是实参p的一份拷贝，申请的空间会给形参，造成内存泄漏</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">void</span> <span class="token function">GetMemory</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    str <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=9></td><td><pre></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token comment">// 传址传递</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token keyword">void</span> <span class="token function">GetMemory2</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=14></td><td><pre></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=17></td><td><pre>    <span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=18></td><td><pre>    </pre></td></tr><tr><td data-num=19></td><td><pre>    <span class="token comment">//p = GetMemory(p);// 传值传递，错误操作</span></pre></td></tr><tr><td data-num=20></td><td><pre>    p <span class="token operator">=</span> <span class="token function">GetMemory2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 传址传递</span></pre></td></tr><tr><td data-num=21></td><td><pre>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=22></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id=字符串相关的内存操作函数><a class=anchor href=#字符串相关的内存操作函数>#</a> 字符串相关的内存操作函数</h3><p>需头文件 - <code>#include&lt;string.h&gt;</code></p><p><code>void* memcpy(void* destination,const void* source,size_t num)</code> - 内存之间进行数据拷贝</p><ul><li><code>memcpy</code>的作用是将<code>source</code>指针指向的内存块中的数据复制到<code>destination</code>指针指向的内存块中，共拷贝<code>num</code>个字节。函数返回的是目标内存区域的起始地址(即<code>destination</code>指针)</li><li><code>memcpy</code>不适用于重叠的内存区域，如果<code>destination</code>和<code>source</code>区域有重叠，使用<code>memmove</code>函数可能更安全</li><li><code>memcpy</code>不关心数据的类型，只是按字节进行拷贝。因此，对于结构体等复杂数据类型的拷贝需要谨慎处理</li></ul><p><code>void* memmove(void* destinantion,const void* source,size_t num)</code> - 将源内存区域的数据拷贝到目标内存区域，并处理源内存区域和目标内存区域重叠的情况</p><p><code>int memcmp(const void* ptr1,const voide* ptr2,size_t num)</code> - 比较两段内存区域的内容是否相等，即按字节比较两个内存区域的数据</p><p><code>void* memset(void* dest,int c,size_t count)</code> - 将指定内存区域的每个字节都设置为特定的值，不仅仅限于字符串操作，用于对内存块进行通用的初始化操作</p><h2 id=指针与数组和函数><a class=anchor href=#指针与数组和函数>#</a> 指针与数组和函数</h2><p><code>数组名[下标]</code> = <code>*(数组首地址 + 下标)</code></p><p><code>地址[下标]</code> = <code>*(地址 + 下标)</code>，把当前地址当成数组首地址，并在截取的数组中获取对应下标的值</p><h3 id=一维数组的数组名详解><a class=anchor href=#一维数组的数组名详解>#</a> 一维数组的数组名详解</h3><p>一维数组在内存中是连续存放的，一个挨着一个，每个间隔sizeof(<code>数组元素的类型</code>)个字节。</p><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">int</span><span class="token operator">*</span> num <span class="token operator">=</span> <span class="token operator">&amp;</span>arr2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 取出数组内特定元素位置的地址</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    </pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> sz<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num=12></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;arr[%d] = %p\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>        <span class="token operator">++</span>i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>当使用<code>sizeof</code>计算数组字节大小时，假如数组名为arr，只有<code>sizeof(arr)</code>中的arr代表整个数组，即相当于计算整个数组的的字节大小。此外，<code>sizeof(&amp;arr)</code>中，arr跟取址符<code>&amp;</code>结合后才表示为整个数组的地址，通过<code>*</code>解引用可获取整个数组。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token comment">// 传入数组首元素地址</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> nums<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token comment">// (4/8)个字节，传入的nums为指针类型，即sizeof计算的是指针字节大小</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token comment">// 4个字节，获取nums数组首元素的值，即sizeof计算的是值类型的字节大小</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token comment">// (4/8)个字节，二级指针并解引用，取得nums指针的地址，即sizeof计算的是指针字节大小</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">&amp;</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=13></td><td><pre></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token comment">// 形参为数组指针，传入整个数组的地址</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>nums<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=17></td><td><pre>    <span class="token comment">// (4/8)个字节，传入的nums为10个元素数组的指针→指针</span></pre></td></tr><tr><td data-num=18></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=19></td><td><pre>    <span class="token comment">// 40个字节，解引用取得整个数组→整个数组</span></pre></td></tr><tr><td data-num=20></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=22></td><td><pre></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=24></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=25></td><td><pre>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=26></td><td><pre>    <span class="token comment">// 4个字节，此处表示为地址取值操作→数值</span></pre></td></tr><tr><td data-num=27></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=28></td><td><pre></pre></td></tr><tr><td data-num=29></td><td><pre>    <span class="token comment">// (4/8)个字节，数组名是首地址，地址的类型判定为指针，32位与64位各不同→地址</span></pre></td></tr><tr><td data-num=30></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=31></td><td><pre>    <span class="token comment">// (4/8)个字节，数组名是首地址，+1时地址跳跃一个int字节→地址</span></pre></td></tr><tr><td data-num=32></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=33></td><td><pre></pre></td></tr><tr><td data-num=34></td><td><pre>    <span class="token comment">// (4/8)个字节，数组的地址，是指针类型→地址</span></pre></td></tr><tr><td data-num=35></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=36></td><td><pre>    <span class="token comment">// (4/8)个字节，数组的地址，sizeof只判定传入类型并不理会传入的是什么→地址</span></pre></td></tr><tr><td data-num=37></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=38></td><td><pre>    <span class="token comment">// (4/8)个字节，指针类型，数组第一个元素的地址跳跃一个int字节→地址</span></pre></td></tr><tr><td data-num=39></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=40></td><td><pre></pre></td></tr><tr><td data-num=41></td><td><pre>    <span class="token comment">// 4个字节，表示为地址首元素→是数值</span></pre></td></tr><tr><td data-num=42></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=43></td><td><pre>    <span class="token comment">// 40个字节，(&amp;a)表示整个数组的地址，*解引用后取得整个数组元素→整个数组</span></pre></td></tr><tr><td data-num=44></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=45></td><td><pre></pre></td></tr><tr><td data-num=46></td><td><pre>    <span class="token function">test1</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 传入数组首元素地址</span></pre></td></tr><tr><td data-num=47></td><td><pre>    <span class="token function">test2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 传入数组的地址</span></pre></td></tr><tr><td data-num=48></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=49></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id=二维数组的数组名详解><a class=anchor href=#二维数组的数组名详解>#</a> 二维数组的数组名详解</h3><p>二维数组在内存中也是连续存放的，一个挨着一个，每个间隔sizeof(<code>数组元素的类型</code>)个字节，每行间隔具有一整个列数量的数据类型个字节。</p><p>二维整型数组形式体为，<code>(int**)</code>行中有<code>(int*)</code>列，即每一行都有一个一维数组。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    </pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token comment">// 16个字节，a相当于该数组首元素地址→第一行一维数组的字节大小</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 16个字节→第一行一维数组</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 16个字节→第四行一维数组</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4个字节→值</span></pre></td></tr><tr><td data-num=12></td><td><pre>    </pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token comment">// (4/8)个字节，第一行一维数组首元素地址加一个整型字节→地址</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4个字节，相当于a[0][1]</span></pre></td></tr><tr><td data-num=16></td><td><pre>    </pre></td></tr><tr><td data-num=17></td><td><pre>    <span class="token comment">// (4/8)个字节，二维数组首元素地址加一个整型字节→地址</span></pre></td></tr><tr><td data-num=18></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=19></td><td><pre>    <span class="token comment">// (4/8)个字节，二维数组的地址加上一个二维数组大小的字节→地址</span></pre></td></tr><tr><td data-num=20></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=21></td><td><pre>    <span class="token comment">// (4/8)个字节，第一行一维数组的地址加上一维数组大小的字节→地址</span></pre></td></tr><tr><td data-num=22></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=23></td><td><pre>    <span class="token comment">// 16个字节，第一行一维数组的地址加上一维数组大小的字节，</span></pre></td></tr><tr><td data-num=24></td><td><pre>    <span class="token comment">// 即第二行一维数组的地址解引用→第二行一维数组</span></pre></td></tr><tr><td data-num=25></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=26></td><td><pre>    </pre></td></tr><tr><td data-num=27></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=28></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><details class=info><summary>数组详解综合</summary><div><p>数组的声明在代码块内</p><ul><li>数组名就是数组的首地址</li><li><code>*</code>解引用首地址就是取数组第一个元素</li><li>首地址加偏移量即向前或向后多少个元素</li><li><code>&amp;</code>配合数组名即整个数组的地址</li><li><code>*</code>解引用整个数组的地址就是取全部元素(例如<code>*&amp;arr</code>)</li><li>数组的地址加偏移量即向前或向后多少个整个数组</li></ul></div></details><details class=info><summary>二维数组名为什么不能直接赋值给二级指针？</summary><div><p>二维数组和二级指针，它们的类型和内存布局是不同的，因此不能直接赋值。这是由于数组和指针的性质以及内存布局的不同所导致的。</p><ul><li><p><strong>二维数组</strong> - 在内存中是连续分配的一块内存，数组名代表数组的起始地址</p></li><li><p><strong>二级指针</strong> - 是一个指向指针的指针，它的值是一个指针的地址，而这个指针才指向实际数据</p></li></ul><p>一级指针可以存放一维数组的起始地址，由于数组的空间连续性的存放特征，因此可通过操作指针来操作一维数组的内存空间数据，指针每移动一步相当于移动了<strong>单个数组元素个字节</strong>。二级指针可以存放一级指针，假如存放二维数组，就相当于存放多个一维数组，一维数组又可以用一级指针来寻址，因此，二维数组的存放相当于一维一级指针数组的存放。假如将一级指针与一维数组的模式照搬给二级指针与二维数组，当用二级指针来代替二维数组时，移动一步时应该要移动<strong>一整个一维数组元素个字节</strong>，但二级指针里存放的是一级指针，最多移动一级指针个字节，这明显不符，因此二维数组名不能直接赋值给二级指针。</p></div></details><h3 id=数组的指针进阶><a class=anchor href=#数组的指针进阶>#</a> 数组的指针进阶</h3><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>假如一个数组为int a<span class="token punctuation">[</span>5<span class="token punctuation">]</span></pre></td></tr><tr><td data-num=2></td><td><pre>其中int <span class="token punctuation">[</span>5<span class="token punctuation">]</span>是该数组类型，而a是该数组的变量名。</pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre>   int  a<span class="token punctuation">[</span>5<span class="token punctuation">]</span>     -> </pre></td></tr><tr><td data-num=5></td><td><pre>   a<span class="token punctuation">[</span>5<span class="token punctuation">]</span> - `数组`  -></pre></td></tr><tr><td data-num=6></td><td><pre>   int - `整型`</pre></td></tr><tr><td data-num=7></td><td><pre>-> 由于<span class="token punctuation">[</span><span class="token punctuation">]</span>优先级较高，a与<span class="token punctuation">[</span><span class="token punctuation">]</span>结合，因此变量`a`是个`数组`，剩下的`int`就为其类型，</pre></td></tr><tr><td data-num=8></td><td><pre>   因此`int  a<span class="token punctuation">[</span>5<span class="token punctuation">]</span>`是`整型数组`，此数组里面存放5个int类型元素。</pre></td></tr><tr><td data-num=9></td><td><pre></pre></td></tr><tr><td data-num=10></td><td><pre>   int* pa<span class="token punctuation">[</span>5<span class="token punctuation">]</span>     -></pre></td></tr><tr><td data-num=11></td><td><pre>   pa<span class="token punctuation">[</span>5<span class="token punctuation">]</span> - `数组`  -></pre></td></tr><tr><td data-num=12></td><td><pre>   int* - `整型指针`</pre></td></tr><tr><td data-num=13></td><td><pre>-> 由于<span class="token punctuation">[</span><span class="token punctuation">]</span>优先级较高，pa与<span class="token punctuation">[</span><span class="token punctuation">]</span>结合，因此变量`pa`是个`数组`，剩下的`int*`就为其类型，</pre></td></tr><tr><td data-num=14></td><td><pre>   因此`int* pa<span class="token punctuation">[</span>5<span class="token punctuation">]</span>`是`指针数组`，此数组里面存放5个int*类型元素。</pre></td></tr><tr><td data-num=15></td><td><pre></pre></td></tr><tr><td data-num=16></td><td><pre>   int (*paa)<span class="token punctuation">[</span>5<span class="token punctuation">]</span>      -></pre></td></tr><tr><td data-num=17></td><td><pre>   *paa - `指针`       -></pre></td></tr><tr><td data-num=18></td><td><pre>   int <span class="token punctuation">[</span>5<span class="token punctuation">]</span> - `整型数组`</pre></td></tr><tr><td data-num=19></td><td><pre>-> 由于()的优先级最高，`*`与paa结合，因此变量`paa`是个`指针`，剩下的`int <span class="token punctuation">[</span>5<span class="token punctuation">]</span>`就为其类型，</pre></td></tr><tr><td data-num=20></td><td><pre>   因此`int (*paa)<span class="token punctuation">[</span>5<span class="token punctuation">]</span>`是`数组指针`，此指针里面存放一个包含5个int类型元素的数组地址。</pre></td></tr><tr><td data-num=21></td><td><pre>   </pre></td></tr><tr><td data-num=22></td><td><pre>   int (*paaa<span class="token punctuation">[</span>10<span class="token punctuation">]</span>)<span class="token punctuation">[</span>5<span class="token punctuation">]</span>  -></pre></td></tr><tr><td data-num=23></td><td><pre>   paaa<span class="token punctuation">[</span>10<span class="token punctuation">]</span> - `数组`    -></pre></td></tr><tr><td data-num=24></td><td><pre>   int (*)<span class="token punctuation">[</span>5<span class="token punctuation">]</span>  - `整型指针数组`</pre></td></tr><tr><td data-num=25></td><td><pre>-> 由于()的优先级最高，再由于<span class="token punctuation">[</span><span class="token punctuation">]</span>优先级较高，paaa先与<span class="token punctuation">[</span>10<span class="token punctuation">]</span>结合，因此，变量`paaa`是个`数组`，</pre></td></tr><tr><td data-num=26></td><td><pre>   剩下的`int (*)<span class="token punctuation">[</span>5<span class="token punctuation">]</span>`就为其类型，因此`int (*paaa<span class="token punctuation">[</span>10<span class="token punctuation">]</span>)<span class="token punctuation">[</span>5<span class="token punctuation">]</span>`是`数组指针数组`，</pre></td></tr><tr><td data-num=27></td><td><pre>   此数组里面存放10个数组指针元素，每个数组指针里面存放一个包含5个int类型元素的数组地址。</pre></td></tr></table></figure><details class=info><summary>数组与指针的区别？</summary><div><p><strong>内存分配</strong></p><ul><li>数组 - 在声明数组时，编译器会在栈上为数组的所有元素分配连续的内存空间。</li><li>指针 - 指针本身只占用一个内存单元，它存储的是一个地址。初始化指针之后，可以通过动态内存分配来分配内存。指针可以在运行时动态分配和释放内存，灵活性更好。</li></ul><p><strong>类型安全性</strong></p><ul><li>数组 - 数组在声明时绑定了具体的类型，编译器在访问数组时可以进行类型检查。</li><li>指针 - 指针声明时也有类型，但指针所指向的内存地址可以重新赋值，容易引起类型不匹配的问题，可能导致运行时错误。</li></ul></div></details><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>函数声明：int Add(int x, int y);</pre></td></tr><tr><td data-num=2></td><td><pre>其中int为其返回类型，Add为函数名，()为函数运算符，</pre></td></tr><tr><td data-num=3></td><td><pre>int为传入参数的类型，此外，Add 、x 和 y 为操作数。</pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre>当Add函数被调用时，会在系统内存中的栈区选取一块空间来存放Add函数，</pre></td></tr><tr><td data-num=6></td><td><pre>要想取得这块空间地址，可通过</pre></td></tr><tr><td data-num=7></td><td><pre>printf("<span class="token comment">%p",  add);</span></pre></td></tr><tr><td data-num=8></td><td><pre>printf("<span class="token comment">%p", &amp;add);</span></pre></td></tr><tr><td data-num=9></td><td><pre></pre></td></tr><tr><td data-num=10></td><td><pre>对于这两种方法，回想一下数组的内存空间地址的获取，</pre></td></tr><tr><td data-num=11></td><td><pre>倘若打印地址时传入的是变量名，则返回的会是`数组首地址`；</pre></td></tr><tr><td data-num=12></td><td><pre>倘若打印地址时传入的是取址符(<span class="token punctuation">&amp;</span>)加变量名，则返回的会是整个数组的地址，</pre></td></tr><tr><td data-num=13></td><td><pre>但对于这一点，函数不同，其取址符(<span class="token punctuation">&amp;</span>)获取到的地址与其直接为变量名的地址是一致的，</pre></td></tr><tr><td data-num=14></td><td><pre>也就是说，获取地址时，函数变量不加取址符(<span class="token punctuation">&amp;</span>)与加取址符(<span class="token punctuation">&amp;</span>)都一样。</pre></td></tr><tr><td data-num=15></td><td><pre></pre></td></tr><tr><td data-num=16></td><td><pre>假如需要一块空间用于存放Add函数的地址，那可以创建一个</pre></td></tr><tr><td data-num=17></td><td><pre>函数指针来存放该地址，可通过</pre></td></tr><tr><td data-num=18></td><td><pre>int (*p)(int, int) = add;</pre></td></tr><tr><td data-num=19></td><td><pre>int (*p)(int, int) = <span class="token punctuation">&amp;</span>add;</pre></td></tr><tr><td data-num=20></td><td><pre>这两种方法来实现，另外需注意一种错误的写法</pre></td></tr><tr><td data-num=21></td><td><pre>int* p(int, int);</pre></td></tr><tr><td data-num=22></td><td><pre>由于()的优先级较高，其与p结合后相当于一个函数，</pre></td></tr><tr><td data-num=23></td><td><pre>这种写法相当于一个返回整型指针类型的函数声明。</pre></td></tr><tr><td data-num=24></td><td><pre></pre></td></tr><tr><td data-num=25></td><td><pre>另外，倘若需要使用函数指针，那需要注意下面两种函数指针的`陷阱`了。</pre></td></tr><tr><td data-num=26></td><td><pre>-----------------------------------------------------------</pre></td></tr><tr><td data-num=27></td><td><pre>第一种是函数类型转换与函数调用的误区。</pre></td></tr><tr><td data-num=28></td><td><pre></pre></td></tr><tr><td data-num=29></td><td><pre>(*(void (*)())0)();</pre></td></tr><tr><td data-num=30></td><td><pre></pre></td></tr><tr><td data-num=31></td><td><pre>如上，这种写法中`void (*)()`为一个函数指针，</pre></td></tr><tr><td data-num=32></td><td><pre>该指针指向的函数不需要参数并且也不返回值，</pre></td></tr><tr><td data-num=33></td><td><pre>之后再通过`()`形式使`数字0`进行一次函数指针类型的`强制转换`，</pre></td></tr><tr><td data-num=34></td><td><pre>例如，强制类型转换的例子</pre></td></tr><tr><td data-num=35></td><td><pre>-----------</pre></td></tr><tr><td data-num=36></td><td><pre>(int)a</pre></td></tr><tr><td data-num=37></td><td><pre>(float)a</pre></td></tr><tr><td data-num=38></td><td><pre>(char)a</pre></td></tr><tr><td data-num=39></td><td><pre>-----------</pre></td></tr><tr><td data-num=40></td><td><pre>这种形式，由此可见`数字0`被充当为一个用来存放调用函数的地址工具，</pre></td></tr><tr><td data-num=41></td><td><pre>之后通过`*`号来解引用地址中存放的函数，最后再通过()形式来调用此函数。</pre></td></tr><tr><td data-num=42></td><td><pre></pre></td></tr><tr><td data-num=43></td><td><pre>(*(void (*)())0)() -> (*(函数指针类型强制转换)0)() -> (*0)()</pre></td></tr><tr><td data-num=44></td><td><pre>-----------------------------------------------------------</pre></td></tr><tr><td data-num=45></td><td><pre>第二种是返回函数指针类型的函数声明。</pre></td></tr><tr><td data-num=46></td><td><pre></pre></td></tr><tr><td data-num=47></td><td><pre>void (*signal(int, void (*)(int)))(int);</pre></td></tr><tr><td data-num=48></td><td><pre></pre></td></tr><tr><td data-num=49></td><td><pre>如上，这种写法中`void (*)(int)`为函数指针的写法，</pre></td></tr><tr><td data-num=50></td><td><pre>并且由于变量名加()可表示为函数，</pre></td></tr><tr><td data-num=51></td><td><pre>可见`signal`是一个函数，`void (*)(int)`为其传入的形参，</pre></td></tr><tr><td data-num=52></td><td><pre>此外假如将`signal(int, void (*)(int))`看成一个函数，</pre></td></tr><tr><td data-num=53></td><td><pre>则上述写法可写成</pre></td></tr><tr><td data-num=54></td><td><pre></pre></td></tr><tr><td data-num=55></td><td><pre>void (*函数名(整型形参,函数指针形参))(int)</pre></td></tr><tr><td data-num=56></td><td><pre></pre></td></tr><tr><td data-num=57></td><td><pre>这样看来，`void (*)(int)`只能为其返回类型了，</pre></td></tr><tr><td data-num=58></td><td><pre>所以这是一个返回函数指针类型的函数声明。</pre></td></tr><tr><td data-num=59></td><td><pre></pre></td></tr><tr><td data-num=60></td><td><pre>void (*signal(int, void(*)(int)))(int) -></pre></td></tr><tr><td data-num=61></td><td><pre>void (*signal(形参, 形参))(int)	-></pre></td></tr><tr><td data-num=62></td><td><pre>void (*函数名(形参, 形参))(int)	-></pre></td></tr><tr><td data-num=63></td><td><pre>函数返回类型 函数名(形参, 形参)</pre></td></tr><tr><td data-num=64></td><td><pre>-----------------------------------------------------------</pre></td></tr></table></figure><h3 id=函数与指针的数组进阶><a class=anchor href=#函数与指针的数组进阶>#</a> 函数与指针的数组进阶</h3><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>假如此时需要实现一个简单的`计算器`逻辑，其中的`加、减、乘和除`已经实现了，</pre></td></tr><tr><td data-num=2></td><td><pre>并命名为`Add，Sub，Mul，Div`，当动手实现时却发现一个问题，</pre></td></tr><tr><td data-num=3></td><td><pre>倘若只是简单的使用`switch`或`if/else`语句，此时实现的代码即冗长又繁杂，</pre></td></tr><tr><td data-num=4></td><td><pre>因此，通过将已经实现的函数方法储存起来再利用不失为一种简单有效的方法。</pre></td></tr><tr><td data-num=5></td><td><pre>----------------------</pre></td></tr><tr><td data-num=6></td><td><pre>int Add(int x, int y);</pre></td></tr><tr><td data-num=7></td><td><pre>int Sub(int x, int y);</pre></td></tr><tr><td data-num=8></td><td><pre>int Mul(int x, int y);</pre></td></tr><tr><td data-num=9></td><td><pre>int Div(int x, int y);</pre></td></tr><tr><td data-num=10></td><td><pre>----------------------</pre></td></tr><tr><td data-num=11></td><td><pre>要想储存上述已经实现的函数，需要一个包含`4`个储存空间的数组，</pre></td></tr><tr><td data-num=12></td><td><pre>并且存储的是函数的`地址`，可以通过定义一个函数指针数组</pre></td></tr><tr><td data-num=13></td><td><pre>int (*p<span class="token punctuation">[</span>4<span class="token punctuation">]</span>)(int, int) = <span class="token punctuation">&#123;</span>Add, Sub, Mul, Div<span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=14></td><td><pre></pre></td></tr><tr><td data-num=15></td><td><pre>这种方法，当想要调用数组中的函数时，可以通过</pre></td></tr><tr><td data-num=16></td><td><pre>printf("<span class="token comment">%d", p[0](2,3));</span></pre></td></tr><tr><td data-num=17></td><td><pre>printf("<span class="token comment">%d", (*p[0])(2,3));</span></pre></td></tr><tr><td data-num=18></td><td><pre>这两种方法。</pre></td></tr><tr><td data-num=19></td><td><pre></pre></td></tr><tr><td data-num=20></td><td><pre>倘若此时需要实现的不再是一个简单的`计算器`，而是更加完整的`计算器`，</pre></td></tr><tr><td data-num=21></td><td><pre>想必，多个`函数指针数组`是必不可少的，</pre></td></tr><tr><td data-num=22></td><td><pre>此时还需要一个能储存不同类别数组的指针，</pre></td></tr><tr><td data-num=23></td><td><pre>这个`指针`指向一个包含多个函数指针的数组，可以通过</pre></td></tr><tr><td data-num=24></td><td><pre>int (*(*pa)<span class="token punctuation">[</span>4<span class="token punctuation">]</span>)(int, int) = <span class="token punctuation">&amp;</span>p;</pre></td></tr><tr><td data-num=25></td><td><pre>这种方法来定义一个`指向函数指针数组的指针`，由于定义方法较为复杂，此处对其进行剖析。</pre></td></tr><tr><td data-num=26></td><td><pre></pre></td></tr><tr><td data-num=27></td><td><pre>对于`指向函数指针数组的指针`，已经明确了该变量类型为指针即`*pa`，</pre></td></tr><tr><td data-num=28></td><td><pre>接着，因为这个指针是用于存放`一个函数指针的数组`，</pre></td></tr><tr><td data-num=29></td><td><pre>因此，其类型为`int (*<span class="token punctuation">[</span>4<span class="token punctuation">]</span>)(int, int)`。</pre></td></tr></table></figure><h3 id=数组与指针与函数的进阶><a class=anchor href=#数组与指针与函数的进阶>#</a> 数组与指针与函数的进阶</h3><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>----</pre></td></tr><tr><td data-num=2></td><td><pre>数组</pre></td></tr><tr><td data-num=3></td><td><pre>------------------------------------------------------</pre></td></tr><tr><td data-num=4></td><td><pre>1.假如有`4`个`整型`元素需要储存在变量`a`中，</pre></td></tr><tr><td data-num=5></td><td><pre>可以写成`整型数组`，</pre></td></tr><tr><td data-num=6></td><td><pre>数组存储的类型是4个整型元素各自的`值`。</pre></td></tr><tr><td data-num=7></td><td><pre>int a<span class="token punctuation">[</span>4<span class="token punctuation">]</span> = <span class="token punctuation">&#123;</span>1, 2, 3, 4<span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=8></td><td><pre></pre></td></tr><tr><td data-num=9></td><td><pre>2.假如有4个`存储整型数组的数组`元素需要储存在变量`b`中，</pre></td></tr><tr><td data-num=10></td><td><pre>可以写成`存储整型数组的数组`，</pre></td></tr><tr><td data-num=11></td><td><pre>数组存储的类型是4个存储整型数组的数组各自的`首地址`。</pre></td></tr><tr><td data-num=12></td><td><pre>int a1<span class="token punctuation">[</span>4<span class="token punctuation">]</span> = <span class="token punctuation">&#123;</span>1,2,3,4<span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=13></td><td><pre>int b1<span class="token punctuation">[</span>4<span class="token punctuation">]</span> = <span class="token punctuation">&#123;</span>2,3,4,5<span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=14></td><td><pre>int c1<span class="token punctuation">[</span>4<span class="token punctuation">]</span> = <span class="token punctuation">&#123;</span>3,4,5,6<span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=15></td><td><pre>int d1<span class="token punctuation">[</span>4<span class="token punctuation">]</span> = <span class="token punctuation">&#123;</span>4,5,6,7<span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=16></td><td><pre></pre></td></tr><tr><td data-num=17></td><td><pre>int* b<span class="token punctuation">[</span>4<span class="token punctuation">]</span> = <span class="token punctuation">&#123;</span>a1, b1, c1, d1<span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=18></td><td><pre></pre></td></tr><tr><td data-num=19></td><td><pre>3.假如有4个`整型指针`元素需要储存在变量`c`中，</pre></td></tr><tr><td data-num=20></td><td><pre>可以写成`整型指针数组`，</pre></td></tr><tr><td data-num=21></td><td><pre>数组存储的类型是4个整型指针元素各自的`指针地址`。</pre></td></tr><tr><td data-num=22></td><td><pre>int a2 = 1;</pre></td></tr><tr><td data-num=23></td><td><pre>int b2 = 2;</pre></td></tr><tr><td data-num=24></td><td><pre>int c2 = 3;</pre></td></tr><tr><td data-num=25></td><td><pre>int d2 = 4;</pre></td></tr><tr><td data-num=26></td><td><pre></pre></td></tr><tr><td data-num=27></td><td><pre>int* pa2 = <span class="token punctuation">&amp;</span>a2;</pre></td></tr><tr><td data-num=28></td><td><pre>int* pb2 = <span class="token punctuation">&amp;</span>b2;</pre></td></tr><tr><td data-num=29></td><td><pre>int* pc2 = <span class="token punctuation">&amp;</span>c2;</pre></td></tr><tr><td data-num=30></td><td><pre>int* pd2 = <span class="token punctuation">&amp;</span>d2;</pre></td></tr><tr><td data-num=31></td><td><pre></pre></td></tr><tr><td data-num=32></td><td><pre>int* c<span class="token punctuation">[</span>4<span class="token punctuation">]</span> = <span class="token punctuation">&#123;</span>pa2, pb2, pc2, pd2<span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=33></td><td><pre></pre></td></tr><tr><td data-num=34></td><td><pre>4.假如有4个`存储整型指针数组的数组`元素需要储存在变量`d`中，</pre></td></tr><tr><td data-num=35></td><td><pre>可以写成`存储整型指针数组的指针数组`，</pre></td></tr><tr><td data-num=36></td><td><pre>数组存储的类型是4个存储整型指针数组的数组元素各自的`指针地址`。</pre></td></tr><tr><td data-num=37></td><td><pre>int a3<span class="token punctuation">[</span>4<span class="token punctuation">]</span> = <span class="token punctuation">&#123;</span>1,2,3,4<span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=38></td><td><pre>int b3<span class="token punctuation">[</span>4<span class="token punctuation">]</span> = <span class="token punctuation">&#123;</span>2,3,4,5<span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=39></td><td><pre>int c3<span class="token punctuation">[</span>4<span class="token punctuation">]</span> = <span class="token punctuation">&#123;</span>3,4,5,6<span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=40></td><td><pre>int d3<span class="token punctuation">[</span>4<span class="token punctuation">]</span> = <span class="token punctuation">&#123;</span>4,5,6,7<span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=41></td><td><pre></pre></td></tr><tr><td data-num=42></td><td><pre>int* pa3<span class="token punctuation">[</span>2<span class="token punctuation">]</span> = <span class="token punctuation">&#123;</span>a3, b3<span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=43></td><td><pre>int* pb3<span class="token punctuation">[</span>2<span class="token punctuation">]</span> = <span class="token punctuation">&#123;</span>b3, a3<span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=44></td><td><pre>int* pc3<span class="token punctuation">[</span>2<span class="token punctuation">]</span> = <span class="token punctuation">&#123;</span>c3, b3<span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=45></td><td><pre>int* pd3<span class="token punctuation">[</span>2<span class="token punctuation">]</span> = <span class="token punctuation">&#123;</span>d3, a3<span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=46></td><td><pre></pre></td></tr><tr><td data-num=47></td><td><pre>int** d<span class="token punctuation">[</span>4<span class="token punctuation">]</span> = <span class="token punctuation">&#123;</span>pa3, pb3, pc3, pd3<span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=48></td><td><pre></pre></td></tr><tr><td data-num=49></td><td><pre>5.假如有4个`函数`元素需要储存在变量`e`中，</pre></td></tr><tr><td data-num=50></td><td><pre>可以写成`储存函数的数组`，</pre></td></tr><tr><td data-num=51></td><td><pre>数组存储的类型是4个函数元素各自的`临时指针地址`。</pre></td></tr><tr><td data-num=52></td><td><pre>int Add(int, int);</pre></td></tr><tr><td data-num=53></td><td><pre>int Sub(int, int);</pre></td></tr><tr><td data-num=54></td><td><pre>int Mul(int, int);</pre></td></tr><tr><td data-num=55></td><td><pre>int Div(int, int);</pre></td></tr><tr><td data-num=56></td><td><pre></pre></td></tr><tr><td data-num=57></td><td><pre>int (*e<span class="token punctuation">[</span>4<span class="token punctuation">]</span>)(int, int) = <span class="token punctuation">&#123;</span>Add, Sub, Mul, Div<span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=58></td><td><pre></pre></td></tr><tr><td data-num=59></td><td><pre>6.假如有4个`函数指针`元素需要储存在变量`f`中，</pre></td></tr><tr><td data-num=60></td><td><pre>可以写成`储存函数的数组`，</pre></td></tr><tr><td data-num=61></td><td><pre>数组存储的类型是4个函数指针元素各自的`指针地址`。</pre></td></tr><tr><td data-num=62></td><td><pre>int Add1(int, int);</pre></td></tr><tr><td data-num=63></td><td><pre>int Sub1(int, int);</pre></td></tr><tr><td data-num=64></td><td><pre>int Mul1(int, int);</pre></td></tr><tr><td data-num=65></td><td><pre>int Div1(int, int);</pre></td></tr><tr><td data-num=66></td><td><pre></pre></td></tr><tr><td data-num=67></td><td><pre>int (*A1)(int, int) = Add1;</pre></td></tr><tr><td data-num=68></td><td><pre>int (*S1)(int, int) = Sub1;</pre></td></tr><tr><td data-num=69></td><td><pre>int (*M1)(int, int) = Mul1;</pre></td></tr><tr><td data-num=70></td><td><pre>int (*D1)(int, int) = Div1;</pre></td></tr><tr><td data-num=71></td><td><pre></pre></td></tr><tr><td data-num=72></td><td><pre>int (*f<span class="token punctuation">[</span>4<span class="token punctuation">]</span>)(int, int) = <span class="token punctuation">&#123;</span> A1, S1 , M1 , D1 <span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=73></td><td><pre></pre></td></tr><tr><td data-num=74></td><td><pre>7.假如有4个`存储函数指针的数组`元素需要储存在变量`f`中，</pre></td></tr><tr><td data-num=75></td><td><pre>可以写成`储存函数指针数组指针的数组`，</pre></td></tr><tr><td data-num=76></td><td><pre>数组存储的类型是4个存储函数指针数组的数组元素各自的`函数指针数组的地址`。</pre></td></tr><tr><td data-num=77></td><td><pre>int Add2(int, int);</pre></td></tr><tr><td data-num=78></td><td><pre>int Sub2(int, int);</pre></td></tr><tr><td data-num=79></td><td><pre>int Mul2(int, int);</pre></td></tr><tr><td data-num=80></td><td><pre>int Div2(int, int);</pre></td></tr><tr><td data-num=81></td><td><pre></pre></td></tr><tr><td data-num=82></td><td><pre>int (*A2)(int, int) = Add2;</pre></td></tr><tr><td data-num=83></td><td><pre>int (*S2)(int, int) = Sub2;</pre></td></tr><tr><td data-num=84></td><td><pre>int (*M2)(int, int) = Mul2;</pre></td></tr><tr><td data-num=85></td><td><pre>int (*D2)(int, int) = Div2;</pre></td></tr><tr><td data-num=86></td><td><pre></pre></td></tr><tr><td data-num=87></td><td><pre>int (*a4<span class="token punctuation">[</span>2<span class="token punctuation">]</span>)(int, int) = <span class="token punctuation">&#123;</span> A2, S2 <span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=88></td><td><pre>int (*b4<span class="token punctuation">[</span>2<span class="token punctuation">]</span>)(int, int) = <span class="token punctuation">&#123;</span> S2, M2 <span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=89></td><td><pre>int (*c4<span class="token punctuation">[</span>2<span class="token punctuation">]</span>)(int, int) = <span class="token punctuation">&#123;</span> M2, D2 <span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=90></td><td><pre>int (*d4<span class="token punctuation">[</span>2<span class="token punctuation">]</span>)(int, int) = <span class="token punctuation">&#123;</span> D2, A2 <span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=91></td><td><pre></pre></td></tr><tr><td data-num=92></td><td><pre>int (*(*f<span class="token punctuation">[</span>4<span class="token punctuation">]</span>)<span class="token punctuation">[</span>2<span class="token punctuation">]</span>)(int, int) = <span class="token punctuation">&#123;</span> a4, b4, c4, d4 <span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=93></td><td><pre></pre></td></tr><tr><td data-num=94></td><td><pre>----</pre></td></tr><tr><td data-num=95></td><td><pre>指针</pre></td></tr><tr><td data-num=96></td><td><pre>------------------------------------------------------</pre></td></tr><tr><td data-num=97></td><td><pre>1.假如有1个`整型数组的地址`需要储存在变量`pa`中，</pre></td></tr><tr><td data-num=98></td><td><pre>可以写成`数组指针`，</pre></td></tr><tr><td data-num=99></td><td><pre>指针存储的类型是`数组首地址`。</pre></td></tr><tr><td data-num=100></td><td><pre>int a<span class="token punctuation">[</span><span class="token punctuation">]</span> = <span class="token punctuation">&#123;</span>1,2,3,4<span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=101></td><td><pre>int* pa = a;</pre></td></tr><tr><td data-num=102></td><td><pre></pre></td></tr><tr><td data-num=103></td><td><pre>2.假如有1个`存储整型指针的数组的地址`需要储存在变量`pb`中，</pre></td></tr><tr><td data-num=104></td><td><pre>可以写成`指向整型指针的数组的指针`，</pre></td></tr><tr><td data-num=105></td><td><pre>指针存储的类型是`传入的指针数组的地址`。</pre></td></tr><tr><td data-num=106></td><td><pre>int a = 1;</pre></td></tr><tr><td data-num=107></td><td><pre>int b = 2;</pre></td></tr><tr><td data-num=108></td><td><pre>int c = 3;</pre></td></tr><tr><td data-num=109></td><td><pre>int d = 4;</pre></td></tr><tr><td data-num=110></td><td><pre></pre></td></tr><tr><td data-num=111></td><td><pre>int* p_a = <span class="token punctuation">&amp;</span>a;</pre></td></tr><tr><td data-num=112></td><td><pre>int* p_b = <span class="token punctuation">&amp;</span>b;</pre></td></tr><tr><td data-num=113></td><td><pre>int* p_c = <span class="token punctuation">&amp;</span>c;</pre></td></tr><tr><td data-num=114></td><td><pre>int* p_d = <span class="token punctuation">&amp;</span>d;</pre></td></tr><tr><td data-num=115></td><td><pre>int* e<span class="token punctuation">[</span>4<span class="token punctuation">]</span> = <span class="token punctuation">&#123;</span>p_a, p_b, p_c, p_d<span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=116></td><td><pre></pre></td></tr><tr><td data-num=117></td><td><pre>int* (*pb)<span class="token punctuation">[</span>4<span class="token punctuation">]</span> = e;</pre></td></tr><tr><td data-num=118></td><td><pre></pre></td></tr><tr><td data-num=119></td><td><pre>3.假如有1个`函数的地址`需要储存在变量`pc`中，</pre></td></tr><tr><td data-num=120></td><td><pre>可以写成`函数指针`，</pre></td></tr><tr><td data-num=121></td><td><pre>指针存储的类型是`指针的地址`。</pre></td></tr><tr><td data-num=122></td><td><pre>int Add(int, int);</pre></td></tr><tr><td data-num=123></td><td><pre>int (*pc)(int, int) = Add;</pre></td></tr><tr><td data-num=124></td><td><pre></pre></td></tr><tr><td data-num=125></td><td><pre>4.假如有`1`个`存储函数指针的数组的地址`需要储存在变量`pd`中，</pre></td></tr><tr><td data-num=126></td><td><pre>可以写成`指向函数指针的数组的指针`，</pre></td></tr><tr><td data-num=127></td><td><pre>指针存储的类型是`传入指针的地址`。</pre></td></tr><tr><td data-num=128></td><td><pre>int Add(int, int);</pre></td></tr><tr><td data-num=129></td><td><pre>int Sub(int, int);</pre></td></tr><tr><td data-num=130></td><td><pre>int Mul(int, int);</pre></td></tr><tr><td data-num=131></td><td><pre>int Div(int, int);</pre></td></tr><tr><td data-num=132></td><td><pre></pre></td></tr><tr><td data-num=133></td><td><pre>int (*A)(int, int) = Add;</pre></td></tr><tr><td data-num=134></td><td><pre>int (*S)(int, int) = Sub;</pre></td></tr><tr><td data-num=135></td><td><pre>int (*M)(int, int) = Mul;</pre></td></tr><tr><td data-num=136></td><td><pre>int (*D)(int, int) = Div;</pre></td></tr><tr><td data-num=137></td><td><pre></pre></td></tr><tr><td data-num=138></td><td><pre>int (*p<span class="token punctuation">[</span>4<span class="token punctuation">]</span>)(int, int) = <span class="token punctuation">&#123;</span> A, S, M , D <span class="token punctuation">&#125;</span>;</pre></td></tr><tr><td data-num=139></td><td><pre></pre></td></tr><tr><td data-num=140></td><td><pre>int (*(*pd)<span class="token punctuation">[</span>4<span class="token punctuation">]</span>)(int, int) = <span class="token punctuation">&amp;</span>p;</pre></td></tr></table></figure><h2 id=自定义数据类型><a class=anchor href=#自定义数据类型>#</a> 自定义数据类型</h2><h3 id=结构体><a class=anchor href=#结构体>#</a> 结构体</h3><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// sturct关键字为结构体声明，tag为结构体的名字</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token comment">// 结构体的类型为struct tag</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">tag</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    member<span class="token operator">-</span>list<span class="token punctuation">;</span><span class="token comment">// 成员列表</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span>variable<span class="token operator">-</span>list<span class="token punctuation">;</span><span class="token comment">// 可选，结构体的别名，可多个，以逗号分隔</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token comment">// 注意分号</span></pre></td></tr><tr><td data-num=8></td><td><pre></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token comment">// 例子</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">stu</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token keyword">int</span> age<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token keyword">char</span> sex<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token keyword">char</span> id<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">stu</span> s<span class="token punctuation">;</span><span class="token comment">// 结构体声明</span></pre></td></tr><tr><td data-num=19></td><td><pre>s<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token comment">// 结构体通过`.`成员访问运算符来访问结构体成员</span></pre></td></tr><tr><td data-num=20></td><td><pre></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">stu</span> s2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"xxx"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token string">"xxxx"</span><span class="token punctuation">,</span><span class="token string">"xxxx"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 声明并初始化</span></pre></td></tr><tr><td data-num=22></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">stu</span><span class="token operator">*</span> ps <span class="token operator">=</span> <span class="token operator">&amp;</span>s2<span class="token punctuation">;</span><span class="token comment">// 结构体指针</span></pre></td></tr><tr><td data-num=23></td><td><pre>ps<span class="token operator">-></span>age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span><span class="token comment">// 结构体指针通过`->`成员访问运算符来访问结构体成员</span></pre></td></tr></table></figure><h3 id=结构体-内存对齐memory-alignment><a class=anchor href=#结构体-内存对齐memory-alignment>#</a> 结构体-内存对齐(Memory Alignment)</h3><p>结构体存在内存对齐规则，并且不同编译器都有不同的对齐数，对于其存在的原因可能有这两种。</p><p><strong>一是程序使用平台的可移植性</strong><br>当已写好的程序在其他硬件平台上使用时，要考虑硬件对内存的调用方法，可能存在硬件不能访问某些特定内存区间而导致异常反馈。</p><p><strong>二是时效性的缘故</strong><br>通用寄存器通常一次能访问4个字节，倘若结构体中的内存摆放是紧凑的，寄存器读取一段后再读取了一个变量和另一个变量的四分之一字节，这时寄存器需要再放回(寄存器需要重新定位到之前读取的四分之一字节的首地址处)，并再从这四分之一字节的首地址处再读取一次，倘若此时结构体的内存摆放是遵循内存对齐规则，则寄存器能一次性读取，不需要再往返读取。</p><p><strong>对齐规则</strong></p><ul><li>结构体中第一个变量内存存储从偏移量为0的地方开始</li><li>除第一个变量外，其他变量需存储在其对齐数的<code>整数倍的位置</code></li><li><code>对齐数</code> = 取(变量类型字节与编译器规定的对齐数)的最小值。vs编译器的默认对齐数为8(不确定，vs2022测试为4)，gcc编译器没有对齐数，因此gcc中结构体的默认对齐数等于变量类型的字节大小</li><li>如果结构体内含有数组，对齐数通常是由数组中元素的类型来确定的</li><li>结构体的总字节大小为结构体中最大对齐数的整数倍</li><li>当结构体1中存在结构体2时，结构体2从其最大对齐数的整数倍数开始存储其总字节数(计算完成后的字节数)</li></ul><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">T1</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>	<span class="token keyword">char</span> a<span class="token punctuation">;</span><span class="token comment">// 0		(1比4 -> 1为对齐数)</span></pre></td></tr><tr><td data-num=6></td><td><pre>	<span class="token comment">// 1~3为浪费的内存空间</span></pre></td></tr><tr><td data-num=7></td><td><pre>	<span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token comment">// 4-7		(4比4 -> 4为对齐数)</span></pre></td></tr><tr><td data-num=8></td><td><pre>	<span class="token keyword">char</span> c<span class="token punctuation">;</span><span class="token comment">// 8		(1比4 -> 1为对齐数)</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token comment">// 结构体中最大对齐数为4，理论值为0~8，即9个字节，</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token comment">// 按规则要求最后得，12字节</span></pre></td></tr><tr><td data-num=12></td><td><pre></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">T2</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=15></td><td><pre>	<span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token comment">// 0~3  (4比4 -> 4为对齐数)</span></pre></td></tr><tr><td data-num=16></td><td><pre>	<span class="token keyword">char</span> b<span class="token punctuation">;</span><span class="token comment">// 4   (1比4 -> 1为对齐数)</span></pre></td></tr><tr><td data-num=17></td><td><pre>	<span class="token keyword">char</span> c<span class="token punctuation">;</span><span class="token comment">// 5   (1比4 -> 1为对齐数)</span></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token comment">// 结构体中最大对齐数为4，理论值为0~5，即6个字节，</span></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token comment">// 按规则要求最后得，8字节</span></pre></td></tr><tr><td data-num=21></td><td><pre></pre></td></tr><tr><td data-num=22></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">T3</span></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=24></td><td><pre>	<span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token comment">// 0~3		(4比4 -> 4为对齐数)</span></pre></td></tr><tr><td data-num=25></td><td><pre>	<span class="token keyword">struct</span> <span class="token class-name">T2</span> t2<span class="token punctuation">;</span><span class="token comment">// 4~11	(8比4 -> 4为对齐数)</span></pre></td></tr><tr><td data-num=26></td><td><pre>	<span class="token keyword">struct</span> <span class="token class-name">T1</span> t1<span class="token punctuation">;</span><span class="token comment">// 12~23	(12比4 -> 4为对齐数)</span></pre></td></tr><tr><td data-num=27></td><td><pre>	<span class="token keyword">char</span> b<span class="token punctuation">;</span><span class="token comment">// 24		(1比4 -> 1为对齐数)</span></pre></td></tr><tr><td data-num=28></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=29></td><td><pre><span class="token comment">// 结构体中最大对齐数为4，理论值为0~24，即25个字节，按规则要求得</span></pre></td></tr><tr><td data-num=30></td><td><pre><span class="token comment">// 按规则要求最后得，28字节</span></pre></td></tr><tr><td data-num=31></td><td><pre></pre></td></tr><tr><td data-num=32></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=33></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=34></td><td><pre>	<span class="token keyword">struct</span> <span class="token class-name">T1</span> t1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=35></td><td><pre>	<span class="token keyword">struct</span> <span class="token class-name">T2</span> t2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=36></td><td><pre></pre></td></tr><tr><td data-num=37></td><td><pre>	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=38></td><td><pre>	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=39></td><td><pre>	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>t3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=40></td><td><pre></pre></td></tr><tr><td data-num=41></td><td><pre>	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=42></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=43></td><td><pre></pre></td></tr><tr><td data-num=44></td><td><pre><span class="token comment">/*********************************************************************/</span></pre></td></tr><tr><td data-num=45></td><td><pre></pre></td></tr><tr><td data-num=46></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=47></td><td><pre><span class="token comment"> * 倘若需要自己定义编译器的对齐数时，</span></pre></td></tr><tr><td data-num=48></td><td><pre><span class="token comment"> * Visual Studio可通过`#pragma pack(对齐数)`来实现；</span></pre></td></tr><tr><td data-num=49></td><td><pre><span class="token comment"> * GCC可通过`__attribute__((对齐数))`来实现</span></pre></td></tr><tr><td data-num=50></td><td><pre><span class="token comment">**/</span></pre></td></tr><tr><td data-num=51></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=52></td><td><pre></pre></td></tr><tr><td data-num=53></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span></span><span class="token comment">// 设置默认对齐数为2</span></span></pre></td></tr><tr><td data-num=54></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">T1</span></pre></td></tr><tr><td data-num=55></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=56></td><td><pre>    <span class="token keyword">char</span> a<span class="token punctuation">;</span><span class="token comment">// 0   (1比2 -> 1为对齐数)</span></pre></td></tr><tr><td data-num=57></td><td><pre>    <span class="token comment">// 1内存空间被浪费</span></pre></td></tr><tr><td data-num=58></td><td><pre>    <span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token comment">// 2~5  (4比2 -> 2为对齐数)</span></pre></td></tr><tr><td data-num=59></td><td><pre>    <span class="token keyword">char</span> c<span class="token punctuation">;</span><span class="token comment">// 6   (1比2 -> 1为对齐数)</span></pre></td></tr><tr><td data-num=60></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=61></td><td><pre><span class="token comment">// 结构体中最大对齐数为2，理论值为0~6，即7个字节，</span></pre></td></tr><tr><td data-num=62></td><td><pre><span class="token comment">// 按规则要求最后得，8字节</span></pre></td></tr><tr><td data-num=63></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </span><span class="token comment">// 此处作用为取消设置对齐数</span></span></pre></td></tr><tr><td data-num=64></td><td><pre></pre></td></tr><tr><td data-num=65></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=66></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=67></td><td><pre>	<span class="token keyword">struct</span> <span class="token class-name">T1</span> t1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=68></td><td><pre>	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=69></td><td><pre>	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=70></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><details class=info><summary>结构体为什么要字节对齐？(内存对齐的作用是什么？)</summary><div><p>结构体字节对齐是为了提高内存访问效率和对齐数据存储的需求。当在结构体中包含不同类型的数据成员时，编译器会为了对齐数据而在结构体中插入一些填充字节，使得结构体的起始地址和每个数据成员的地址都是某个特定对齐值的倍数。字节对齐的原因主要有以下几点</p><ul><li><p><strong>硬件要求</strong> - 很多计算机体系结构对特定数据类型的内存访问有对齐的要求。例如，有些处理器要求访问特定数据类型的地址是其大小的倍数，否则可能导致性能下降甚至错误。通过进行字节对齐，可以确保结构体的每个成员都按照合适的字节边界对齐，从而满足硬件对齐要求</p></li><li><p><strong>提高访问速度</strong> - 处理器通常能更快地访问对齐的内存地址。如果结构体的成员按照自然对齐原则排列，那么处理器在读取结构体中的数据时能够更加高效，不需要额外的操作来处理非对齐的数据</p></li><li><p><strong>优化内存使用</strong> - 对齐规则还可以帮助优化内存的使用。通过对齐，可以减少填充字节的数量，从而节省内存空间。这对于内存受限的系统或需要高性能的应用程序来说尤其重要</p></li></ul><p>字节对齐的具体规则和默认对齐值(alignment)取决于编译器和编译器选项。在<code>C/C++</code>中，可以使用<code>#pragma pack</code>(Visual Studio编译器)、<code>__attribute__((packed))</code>(GCC、Clang等编译器)等指令来改变默认的对齐方式，但这样做可能会影响性能和可移植性。</p></div></details><h3 id=联合体共用体><a class=anchor href=#联合体共用体>#</a> 联合体/共用体</h3><p><code>union</code>(联合体)是一种特殊的数据结构，类似于结构体，都需要内存对齐，其允许在相同的内存位置存储不同类型的数据。联合体中的值为最后被赋值的那个成员的值。</p><p><code>union</code>中的内存空间是共用的，所有成员共享同一块内存，联合体的字节大小至少是联合体中具有最大字节的成员的大小，并且为该联合体中最大对齐数的整数倍。</p><p>匿名联合体没有名字，可以在定义的时候创建匿名联合体变量(编译器有可能不支持，Linux支持)，也可嵌入到结构体中。</p><p><strong>应用场景</strong></p><ul><li>当数据项使用两种或多种数据类型(但不会同时使用)时，可节省空间(嵌入式系统)</li><li>用于回调函数的参数(相当于支持多种数据类型)</li></ul><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">union</span> T1</pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>	<span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token comment">// 最大成员与最大对齐数 4</span></pre></td></tr><tr><td data-num=6></td><td><pre>	<span class="token keyword">char</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>	<span class="token keyword">short</span> c<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token keyword">union</span> T2</pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=12></td><td><pre>	<span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token comment">// 最大对齐数 4</span></pre></td></tr><tr><td data-num=13></td><td><pre>	<span class="token keyword">char</span> b<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 最大成员 5</span></pre></td></tr><tr><td data-num=14></td><td><pre>	<span class="token keyword">short</span> c<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=16></td><td><pre></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=19></td><td><pre>	<span class="token keyword">union</span> T1 t1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=20></td><td><pre>	<span class="token keyword">union</span> T2 t2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=21></td><td><pre>	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4</span></pre></td></tr><tr><td data-num=22></td><td><pre>	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 8，最大字节成员的最大对齐数的整数倍</span></pre></td></tr><tr><td data-num=23></td><td><pre></pre></td></tr><tr><td data-num=24></td><td><pre>	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=25></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id=位段位域bit-fields><a class=anchor href=#位段位域bit-fields>#</a> 位段/位域(Bit Fields)</h3><p>位段与结构体的形式相似，用于将数据结构中的多个成员压缩到一个或多个字节中，位段可以有效利用所给的内存空间，不过位段中的元素类型必须是整型家族成员，此外位段大小不应该超过其数据类型的最大字节。</p><p>当程序考虑可移植性的问题时，由于位段的不确定性因素，不推荐使用位段。</p><p>当位段程序进行跨平台时，具有以下几个问题</p><ul><li>int类型被当成有符号或无符号类型是不确定的</li><li>所跨平台操作系统的位数是不确定的，例如16位或32位</li><li>由于大小端操作系统的缘故，内存分配是从右向左还是相反都不确定</li><li>当开辟的第一个数据类型空间无法容纳第二个变量时，内存是会重新开辟空间或者是填充完第一个数据类型空间后再开辟空间填充，对于这两种情况是不确定的</li></ul><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">/*</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token comment">位段的表示形式</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token comment">struct tag</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment">	变量类型 变量名 : 所占的比特位空间</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment">&#125;;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token comment">*/</span></pre></td></tr><tr><td data-num=8></td><td><pre></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=10></td><td><pre></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">T1</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=13></td><td><pre>	<span class="token comment">// int为4个字节即32个比特位</span></pre></td></tr><tr><td data-num=14></td><td><pre>	<span class="token keyword">int</span> a <span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">// 占用int类型的4个字节中的4个比特位 </span></pre></td></tr><tr><td data-num=15></td><td><pre>	<span class="token keyword">int</span> b <span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">// 占用int类型的4个字节中的4个比特位</span></pre></td></tr><tr><td data-num=16></td><td><pre>	<span class="token comment">// 由于上方int空间不足32个字节，创建新的int空间</span></pre></td></tr><tr><td data-num=17></td><td><pre>	<span class="token keyword">int</span> c <span class="token operator">:</span> <span class="token number">32</span><span class="token punctuation">;</span><span class="token comment">// 占用新int类型的4个字节中的32个比特位</span></pre></td></tr><tr><td data-num=18></td><td><pre>	<span class="token comment">// 由于上方int空间不足6个字节，创建新的int空间</span></pre></td></tr><tr><td data-num=19></td><td><pre>	<span class="token keyword">int</span> d <span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token comment">// 占用更新int类型的4个字节中的6个比特位 </span></pre></td></tr><tr><td data-num=20></td><td><pre></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=22></td><td><pre></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=24></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=25></td><td><pre>	<span class="token keyword">struct</span> <span class="token class-name">T1</span> t1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=26></td><td><pre>	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 12</span></pre></td></tr><tr><td data-num=27></td><td><pre>	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=28></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=29></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=30></td><td><pre><span class="token comment"> * 由于变量a与变量b之和为1个字节，但变量c需要存储32个比特位，故重新开辟了一个int内存空间，</span></pre></td></tr><tr><td data-num=31></td><td><pre><span class="token comment"> * 变量a与变量b所处的int内存空间的空闲空间被浪费，</span></pre></td></tr><tr><td data-num=32></td><td><pre><span class="token comment"> * 此外，变量d由于变量c所处int内存空间不足，故又重新开辟一块int内存空间，</span></pre></td></tr><tr><td data-num=33></td><td><pre><span class="token comment"> * 因此总共开辟了3个int内存空间，</span></pre></td></tr><tr><td data-num=34></td><td><pre><span class="token comment"> * 故占了12个字节。</span></pre></td></tr><tr><td data-num=35></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><h3 id=枚举><a class=anchor href=#枚举>#</a> 枚举</h3><p><code>enum</code>(枚举类型)是一种用于定义一组命名的整数常量的数据类型。通过使用<code>enum</code>，可以为一组相关的常量分配有意义的名称，使代码更加清晰、易读，并且有助于减少硬编码的数字常量。</p><p>枚举可以一次性创建多个常量的特性明显优于<code>#define</code>，此外由于<code>#define</code>的操作是完全替换，当维护代码时枚举的修改操作次数会少于<code>#define</code>的修改操作次数，这使代码调试时更加方便。</p><p><code>#define</code>指令的标识符是全局替换，而枚举常量是有类型检查，并且不会影响工程中的其他重名变量或函数，这有效的避免了命名污染。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token comment">// 枚举类型，可列举的常量</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">enum</span> <span class="token class-name">T1</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>	A<span class="token punctuation">,</span></pre></td></tr><tr><td data-num=7></td><td><pre>	B<span class="token punctuation">,</span></pre></td></tr><tr><td data-num=8></td><td><pre>	C<span class="token punctuation">,</span></pre></td></tr><tr><td data-num=9></td><td><pre>	D</pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token comment">// 自定义顺序</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token keyword">enum</span> <span class="token class-name">T2</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=15></td><td><pre>	A<span class="token punctuation">,</span></pre></td></tr><tr><td data-num=16></td><td><pre>	B <span class="token operator">=</span> <span class="token number">255</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=17></td><td><pre>	C<span class="token punctuation">,</span></pre></td></tr><tr><td data-num=18></td><td><pre>	D <span class="token operator">=</span> <span class="token number">244</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=19></td><td><pre>	E</pre></td></tr><tr><td data-num=20></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=21></td><td><pre></pre></td></tr><tr><td data-num=22></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=24></td><td><pre>	<span class="token keyword">enum</span> <span class="token class-name">T1</span> t1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=25></td><td><pre>	<span class="token comment">// 0 1 2 3</span></pre></td></tr><tr><td data-num=26></td><td><pre>	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d %d\n"</span><span class="token punctuation">,</span> A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>C<span class="token punctuation">,</span>D<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=27></td><td><pre>    </pre></td></tr><tr><td data-num=28></td><td><pre>	<span class="token keyword">enum</span> <span class="token class-name">T2</span> t2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=29></td><td><pre>	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d %d %d\n"</span><span class="token punctuation">,</span> A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>C<span class="token punctuation">,</span>D<span class="token punctuation">,</span>E<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 0 255 256 244 245</span></pre></td></tr><tr><td data-num=30></td><td><pre>	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=31></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id=文件操作><a class=anchor href=#文件操作>#</a> 文件操作</h2><h3 id=概述><a class=anchor href=#概述>#</a> 概述</h3><p>文件是指存储在磁盘或其他存储介质上的数据集合，在程序设计中，一般谈及的文件有两种，程序文件和数据文件。</p><p><strong>程序文件</strong> - 包括源程序文件(后缀为<code>.c</code>)，目标文件(windows环境后缀为<code>.obj</code>)，可执行程序(windows环境后缀为<code>.exe</code>)</p><p><strong>数据文件</strong> - 文件的内容不一定是程序，而是程序运行时读写的数据，比如程序运行需要从中读取数据的文件或者输出内容的文件</p><p><strong>文件名</strong></p><p>一个文件要有一个唯一的文件标识，以便用户识别和引用。</p><p>文件名包含3部分，文件路径、文件名主干和文件后缀，例如：<code>c:\code\test.txt</code></p><p>为了方便起见，文件标识常被称为文件名。</p><p><strong>文件类型</strong></p><p>根据数据的组织形式，数据文件被称为<strong>文本文件</strong>或<strong>二进制文件</strong>。</p><p>数据在内存中以二进制的形式存储，如果不转换再输出到外存，就是二进制文件。</p><p>如果要求在外存上以ASCII码的形式存储，则需要在存储前转换。以ASCII字符的形式存储的文件就是文本文件。</p><p><strong>一个数据在内存中是怎样存储的？</strong></p><p>字符一律以ASCII码形式存储，数值型数据即可以用ASCII码形式存储，也可以使用二进制形式存储。</p><p>假如有整数10000，如果以ASCII码的形式输出到磁盘，则磁盘中占用5个字节(每个字符一个字节)，如果以二进制形式输出，则在磁盘上只占4个字节(VS2013测试结果)。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    </pre></td></tr><tr><td data-num=7></td><td><pre>    FILE<span class="token operator">*</span> pf <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span><span class="token string">"wb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>pf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 以二进制形式写到文件中</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token function">fclose</span><span class="token punctuation">(</span>pf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    pf <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>文件缓冲区</strong></p><p><code>ANSI C</code>标准采用缓冲文件系统来处理数据文件，所谓缓冲文件系统是指系统自动地在内存中为程序中每一个正在使用的文件开辟一块文件缓冲区。从内存向磁盘输出数据会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘上。如果从磁盘向计算机读取数据，则从磁盘文件中读取数据输入到内存缓冲区(充满缓冲区)，然后再从缓冲区逐个地将数据送到程序数据区(程序变量等)。</p><p>缓冲区的大小由C编译系统决定。</p><p><strong>文件指针</strong></p><p>缓冲文件系统中，关键的概念是文件类型指针，简称文件指针。</p><p>每个被使用的文件都在内存中开辟了一个相应的文件信息区，用来存放文件的相关信息(如文件的名字/状态/当前的位置等)。这些信息是保存在一个结构体变量中的，该结构体类型是由系统声明的，取名为<strong>FILE</strong></p><p>例如，VS2008编译环境提供的<code>stdio.h</code>头文件中有关文件类型的声明</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">_iobuf</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">char</span><span class="token operator">*</span> _ptr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">int</span> _cnt<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">char</span><span class="token operator">*</span> _base<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">int</span> _flag<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">int</span> _file<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">int</span> _charbuf<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">int</span> _bufsiz<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token keyword">char</span><span class="token operator">*</span> _tmpfname<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_iobuf</span> FILE<span class="token punctuation">;</span></pre></td></tr></table></figure><p>不同C编译器的FILE类型包含的内容不完全相同，但是大同小异。</p><p>每当打开一个文件的时候，系统会根据文件的情况自动创建一个FILE结构的变量并填充其中的信息，使用者不必关心细节。</p><p>一般都是通过一个FILE类型的指针来维护这个FILE结构的变量。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre>FILE<span class="token operator">*</span> pf<span class="token punctuation">;</span><span class="token comment">// 文件类型指针变量</span></pre></td></tr></table></figure><p>定义pf是一个指向FILE类型数据的指针变量。可以使pf指向某个文件的文件信息区(是一个结构体变量)。通过该文件信息区中的信息就能够访问该文件，即通过文件指针变量就能够找到与它关联的文件。</p><h3 id=文件的打开和关闭><a class=anchor href=#文件的打开和关闭>#</a> 文件的打开和关闭</h3><p>文件在<strong>读写之前</strong>应该先<strong>打开</strong>文件，在<strong>使用之后</strong>应该<strong>关闭</strong>文件。</p><p>在打开文件的同时，会返回一个<code>FILE*</code>的指针变量指向该文件，相当于建立了指针与文件的关系。</p><p><code>ANSI C</code>规定使用fopen函数来打开文件，fclose来关闭文件。</p><ul><li><p><code>FILE* fopen(const char* filename,const char* mode)</code></p></li><li><p><code>int fclose(FILE* stream)</code></p></li></ul><p><strong>打开方式</strong></p><table><thead><tr><th>文件打开方式</th><th style=text-align:left>描述</th><th style=text-align:left>如果指定文件不存在</th></tr></thead><tbody><tr><td>“r”(只读)</td><td style=text-align:left>为了输入数据，打开一个已经存在的文本文件</td><td style=text-align:left>出错</td></tr><tr><td>“w”(只写)</td><td style=text-align:left>为了输出数据，打开一个文本文件</td><td style=text-align:left>建立一个新文件</td></tr><tr><td>“a”(追加)</td><td style=text-align:left>向文本文件尾部添加数据</td><td style=text-align:left>出错</td></tr><tr><td>“rb”(只读)</td><td style=text-align:left>为了输入数据，打开一个二进制文件</td><td style=text-align:left>出错</td></tr><tr><td>“wb”(只写)</td><td style=text-align:left>为了输出数据，打开一个二进制文件</td><td style=text-align:left>建立一个新的文件</td></tr><tr><td>“ab”(追加)</td><td style=text-align:left>向一个二进制文件尾部添加数据</td><td style=text-align:left>出错</td></tr><tr><td>“r+”(读写)</td><td style=text-align:left>为了读和写，打开一个文本文件</td><td style=text-align:left>出错</td></tr><tr><td>“w+”(读写)</td><td style=text-align:left>为了读和写，建立一个新的文件</td><td style=text-align:left>建立一个新的文件</td></tr><tr><td>“a+”(读写)</td><td style=text-align:left>打开一个文件，在尾部进行读写</td><td style=text-align:left>建立一个新的文件</td></tr><tr><td>“rb+”(读写)</td><td style=text-align:left>为了读和写，打开一个二进制文件</td><td style=text-align:left>出错</td></tr><tr><td>“wb+”(读写)</td><td style=text-align:left>为了读和写，新建一个二进制文件</td><td style=text-align:left>建立一个新的文件</td></tr><tr><td>“ab+”(读写)</td><td style=text-align:left>打开一个二进制文件，在文件尾部进行读和写</td><td style=text-align:left>建立一个新的文件</td></tr></tbody></table><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;errno.h></span></span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token comment">// 打开文件test.txt</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token comment">// 相对路径写法，`.`表示当前路径，`..`表示上一级路径</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token comment">//fopen("../../test.tex","r");</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token comment">//fopen("test.txt","r");</span></pre></td></tr><tr><td data-num=11></td><td><pre></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token comment">// 绝对路径的写法</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token comment">//fopen("c:\\2020_code\\test_5_6\\test.txt","r");</span></pre></td></tr><tr><td data-num=14></td><td><pre>    FILE<span class="token operator">*</span> pf <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 打开文件</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> pf<span class="token punctuation">)</span><span class="token comment">// 打开失败</span></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=17></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span><span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=18></td><td><pre>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=19></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=20></td><td><pre></pre></td></tr><tr><td data-num=21></td><td><pre>    <span class="token function">fclose</span><span class="token punctuation">(</span>pf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 关闭文件</span></pre></td></tr><tr><td data-num=22></td><td><pre>    pf <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=23></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=24></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id=文件的顺序读写><a class=anchor href=#文件的顺序读写>#</a> 文件的顺序读写</h3><table><thead><tr><th style=text-align:left>函数名</th><th style=text-align:left>功能</th><th style=text-align:left>适用范围</th></tr></thead><tbody><tr><td style=text-align:left>fgetc</td><td style=text-align:left>字符输入函数</td><td style=text-align:left>所有输入流</td></tr><tr><td style=text-align:left>fputc</td><td style=text-align:left>字符输出函数</td><td style=text-align:left>所有输出流</td></tr><tr><td style=text-align:left>fgets</td><td style=text-align:left>文本行输入函数</td><td style=text-align:left>所有输入流</td></tr><tr><td style=text-align:left>fputs</td><td style=text-align:left>文本行输出函数</td><td style=text-align:left>所有输出流</td></tr><tr><td style=text-align:left>fscanf</td><td style=text-align:left>格式化输入函数</td><td style=text-align:left>所有输入流</td></tr><tr><td style=text-align:left>fprintf</td><td style=text-align:left>格式化输出函数</td><td style=text-align:left>所有输出流</td></tr><tr><td style=text-align:left>fread</td><td style=text-align:left>二进制输入</td><td style=text-align:left>文件</td></tr><tr><td style=text-align:left>fwrite</td><td style=text-align:left>二进制输出</td><td style=text-align:left>文件</td></tr></tbody></table><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">main1</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    FILE<span class="token operator">*</span> pfWrite <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> pfWrite<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token comment">// 向文件写入</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token char">'b'</span><span class="token punctuation">,</span>pfWrite<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token char">'i'</span><span class="token punctuation">,</span>pfWrite<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token char">'c'</span><span class="token punctuation">,</span>pfWrite<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    </pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token function">fclose</span><span class="token punctuation">(</span>pfWrite<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    pfWrite <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=14></td><td><pre></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token keyword">int</span> <span class="token function">main2</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=17></td><td><pre>    FILE<span class="token operator">*</span> pfRead <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=18></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> pfWrite<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=19></td><td><pre>    <span class="token comment">// 读文件</span></pre></td></tr><tr><td data-num=20></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span><span class="token function">fgetc</span><span class="token punctuation">(</span>pfRead<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=21></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span><span class="token function">fgetc</span><span class="token punctuation">(</span>pfRead<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=22></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span><span class="token function">fgetc</span><span class="token punctuation">(</span>pfRead<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=23></td><td><pre>    </pre></td></tr><tr><td data-num=24></td><td><pre>    <span class="token function">fclose</span><span class="token punctuation">(</span>pfRead<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=25></td><td><pre>    pfRead <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=26></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=27></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token comment"> * 从键盘输入，输出到屏幕，键盘和屏幕是外部设备，是程序默认打开的两个流设备。</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token comment"> * 键盘 - 标准输入设备 - stdin</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment"> * 屏幕 - 标准输出设备 - stdout</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment"> * 程序运行起来就会默认打开三个流，</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment"> * stdin - FILE*</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token comment"> * stdout - FILE*</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token comment"> * stderr - FILE*</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token comment"> * 这三个流的类型都是FILE*</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token comment">**/</span></pre></td></tr><tr><td data-num=11></td><td><pre></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token keyword">int</span> <span class="token function">main0</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token keyword">int</span> ch <span class="token operator">=</span> <span class="token function">fgetc</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token function">fputc</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=18></td><td><pre></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token keyword">int</span> <span class="token function">main1</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=21></td><td><pre>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token char">'\0'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=22></td><td><pre></pre></td></tr><tr><td data-num=23></td><td><pre>    FILE<span class="token operator">*</span> pf <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=24></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> pf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=25></td><td><pre></pre></td></tr><tr><td data-num=26></td><td><pre>    <span class="token function">fgets</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token number">1024</span><span class="token punctuation">,</span>pf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 读文件</span></pre></td></tr><tr><td data-num=27></td><td><pre>    <span class="token comment">//printf("%s\n",buf);</span></pre></td></tr><tr><td data-num=28></td><td><pre>    <span class="token function">puts</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=29></td><td><pre></pre></td></tr><tr><td data-num=30></td><td><pre>    <span class="token function">fclose</span><span class="token punctuation">(</span>pf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=31></td><td><pre>    pf <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=32></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=33></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=34></td><td><pre></pre></td></tr><tr><td data-num=35></td><td><pre><span class="token keyword">int</span> <span class="token function">main2</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=36></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=37></td><td><pre>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token char">'\0'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=38></td><td><pre></pre></td></tr><tr><td data-num=39></td><td><pre>    FILE<span class="token operator">*</span> pf <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=40></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> pf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=41></td><td><pre></pre></td></tr><tr><td data-num=42></td><td><pre>    <span class="token comment">// 向文件写入</span></pre></td></tr><tr><td data-num=43></td><td><pre>    <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span>pf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=44></td><td><pre>    <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">,</span>pf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=45></td><td><pre></pre></td></tr><tr><td data-num=46></td><td><pre>    <span class="token function">fclose</span><span class="token punctuation">(</span>pf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=47></td><td><pre>    pf <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=48></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=49></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=50></td><td><pre></pre></td></tr><tr><td data-num=51></td><td><pre><span class="token keyword">int</span> <span class="token function">main3</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=52></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=53></td><td><pre>    <span class="token comment">// 从键盘读取一行文本信息</span></pre></td></tr><tr><td data-num=54></td><td><pre>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=55></td><td><pre>    <span class="token comment">//fgets(buf,1024,stdin);// 从标准输入流读取</span></pre></td></tr><tr><td data-num=56></td><td><pre>    <span class="token comment">//fputs(buf,stdout);// 输出到标准输出流</span></pre></td></tr><tr><td data-num=57></td><td><pre>    </pre></td></tr><tr><td data-num=58></td><td><pre>    <span class="token function">gets</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=59></td><td><pre>    <span class="token function">puts</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=60></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=61></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">S</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">int</span> n<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">float</span> score<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">char</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token keyword">int</span> <span class="token function">main1</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">S</span> s <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">3.14f</span><span class="token punctuation">,</span><span class="token string">"bit"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    FILE<span class="token operator">*</span> pf <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    </pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> pf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    </pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token comment">// 格式化形式的写文件</span></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token function">fprintf</span><span class="token punctuation">(</span>pf<span class="token punctuation">,</span><span class="token string">"%d %f %s"</span><span class="token punctuation">,</span>s<span class="token punctuation">.</span>n<span class="token punctuation">,</span>s<span class="token punctuation">.</span>score<span class="token punctuation">,</span>s<span class="token punctuation">.</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre>    </pre></td></tr><tr><td data-num=18></td><td><pre>    <span class="token function">fclose</span><span class="token punctuation">(</span>pf<span class="token punctuation">)</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=19></td><td><pre>    pf <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=20></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=22></td><td><pre></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token keyword">int</span> <span class="token function">main2</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=24></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=25></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">S</span> s <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=26></td><td><pre>    FILE<span class="token operator">*</span> pf <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=27></td><td><pre>    </pre></td></tr><tr><td data-num=28></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> pf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=29></td><td><pre>    </pre></td></tr><tr><td data-num=30></td><td><pre>    <span class="token comment">// 格式化形式的输入数据</span></pre></td></tr><tr><td data-num=31></td><td><pre>    <span class="token function">fscanf</span><span class="token punctuation">(</span>pf<span class="token punctuation">,</span><span class="token string">"%d %f %d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>score<span class="token punctuation">)</span><span class="token punctuation">,</span>s<span class="token punctuation">.</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=32></td><td><pre>    </pre></td></tr><tr><td data-num=33></td><td><pre>    <span class="token comment">//printf("%d %f %s",s.n,s.score,s.arr);</span></pre></td></tr><tr><td data-num=34></td><td><pre>    <span class="token function">fclose</span><span class="token punctuation">(</span>pf<span class="token punctuation">)</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=35></td><td><pre>    pf <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=36></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=37></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=38></td><td><pre></pre></td></tr><tr><td data-num=39></td><td><pre><span class="token keyword">int</span> <span class="token function">main3</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=40></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=41></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">S</span> s <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=42></td><td><pre>    FILE<span class="token operator">*</span> pf <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=43></td><td><pre>    </pre></td></tr><tr><td data-num=44></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> pf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=45></td><td><pre>    </pre></td></tr><tr><td data-num=46></td><td><pre>    <span class="token comment">// 格式化形式的输入数据</span></pre></td></tr><tr><td data-num=47></td><td><pre>    <span class="token function">fscanf</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">,</span><span class="token string">"%d %f %d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>score<span class="token punctuation">)</span><span class="token punctuation">,</span>s<span class="token punctuation">.</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=48></td><td><pre>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span><span class="token string">"%d %f %d"</span><span class="token punctuation">,</span>s<span class="token punctuation">.</span>n<span class="token punctuation">,</span>s<span class="token punctuation">.</span>score<span class="token punctuation">,</span>s<span class="token punctuation">.</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=49></td><td><pre>    </pre></td></tr><tr><td data-num=50></td><td><pre>    <span class="token function">fclose</span><span class="token punctuation">(</span>pf<span class="token punctuation">)</span><span class="token operator">:</span></pre></td></tr><tr><td data-num=51></td><td><pre>    pf <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=52></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=53></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>输入/输出流函数的各区别</strong></p><p>scanf / fscanf / sscanf</p><p>printf / fprint / sprintf</p><p><code>scanf/printf</code> - 是针对标准输入流/标准输出流的格式化输入/输出语句。</p><p><code>fscanf/fprintf</code> - 是针对所有输入流/所有输出流的格式化输入/输出语句。</p><p><code>sscanf</code> - 是从字符串中读取格式化的数据。</p><p><code>sprintf</code> - 是把格式化数据输出(存储到)字符串。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">S</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">int</span> n<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">float</span> score<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">char</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">S</span> s <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">3.14f</span><span class="token punctuation">,</span><span class="token string">"abcdef"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">S</span> tmp <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    </pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token comment">// 把格式化的数据转换成字符串存储到buf</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token string">"%d %f %s"</span><span class="token punctuation">,</span>s<span class="token punctuation">.</span>n<span class="token punctuation">.</span>s<span class="token punctuation">.</span>score<span class="token punctuation">,</span>s<span class="token punctuation">.</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre>    </pre></td></tr><tr><td data-num=18></td><td><pre>    <span class="token comment">// 从buf中读取格式化的数据到tmp中</span></pre></td></tr><tr><td data-num=19></td><td><pre>    <span class="token function">sscanf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token string">"%d %f %s"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>score<span class="token punctuation">)</span><span class="token punctuation">,</span>tmp<span class="token punctuation">.</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=20></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %f %s\n"</span><span class="token punctuation">,</span>tmp<span class="token punctuation">.</span>n<span class="token punctuation">,</span>tmp<span class="token punctuation">.</span>score<span class="token punctuation">,</span>tmp<span class="token punctuation">.</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=21></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=22></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id=文件的随机读写><a class=anchor href=#文件的随机读写>#</a> 文件的随机读写</h3><p><code>int fseek(FILE* stream,long int offset,int origin)</code> - 根据文件指针的位置和偏移量来定位文件指针</p><p><code>long int ftell(FILE* stream)</code> - 返回文件指针相对于起始位置的偏移量</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    FILE<span class="token operator">*</span> pf <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> pf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    </pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token comment">// 定位文件指针</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token function">fseek</span><span class="token punctuation">(</span>pf<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token constant">SEEK_END</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token function">ftell</span><span class="token punctuation">(</span>pf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    </pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token function">fclose</span><span class="token punctuation">(</span>pf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    pf <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    </pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>void rewind(FILE* stream)</code> - 让文件指针的位置回到文件的起始位置</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    FILE<span class="token operator">*</span> pf <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> pf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">int</span> ch <span class="token operator">=</span> <span class="token function">fgetc</span><span class="token punctuation">(</span>pf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    </pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token function">rewind</span><span class="token punctuation">(</span>pf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    ch <span class="token operator">=</span> <span class="token function">fgetc</span><span class="token punctuation">(</span>pf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    </pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token function">fclose</span><span class="token punctuation">(</span>pf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    pf <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    </pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id=文件结束判定><a class=anchor href=#文件结束判定>#</a> 文件结束判定</h3><p><strong>被错误使用的feof</strong></p><p>在文件读取过程中，不能用feof函数的返回值直接来判断文件的相关过程是否结束，而是将其用于当文件读取结束的时候，判断是读取失败结束，还是已到达文件尾部而结束。</p><p>文本文件读取是否结束，可通过</p><ul><li><code>fgetc</code>函数判断是否为EOF</li><li><code>fgets</code>函数判断返回值是否为NULL</li></ul><p>二进制文件的读取结束判断，判断返回值是否小于实际需要读取的个数，fread判断返回值是否小于实际要读的个数。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">int</span> c<span class="token punctuation">;</span><span class="token comment">// int，非char，要处理EOF</span></pre></td></tr><tr><td data-num=4></td><td><pre>    FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> fp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token comment">// fgetc 当读取失败的时候或者遇到文件结束的时候，都会返回EOF</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token constant">EOF</span> <span class="token operator">!=</span> <span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token function">fgetc</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token function">putchar</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">// 标准C I/O读取文件循环</span></pre></td></tr><tr><td data-num=9></td><td><pre></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token comment">// 判断是什么原因结束的</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">ferror</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"I/O error when reading"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    ese <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">feof</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"End of file reached successfully"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=13></td><td><pre></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>char *strerror(int errnum)</code> - 把错误码对应的错误信息的字符串地址返回</p><p><code>strerror</code>函数用于将错误码(<code>errnum</code>)转换为相应的错误消息字符串，并返回该字符串的指针。通常情况下，<code>errnum</code>是通过调用系统或库函数产生的错误码，然后使用<code>strerror</code>函数将其转换为人可读的错误消息。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">main2</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token comment">//printf("%s\n",strerror(errno));</span></pre></td></tr><tr><td data-num=4></td><td><pre>    </pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token comment">// perror</span></pre></td></tr><tr><td data-num=6></td><td><pre>    FILE<span class="token operator">*</span> pf <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test2.txt"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    </pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token comment">// 打印open file tset2.txt: No such file or directory</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> pf<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=11></td><td><pre>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open file tset2.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    </pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token function">fclose</span><span class="token punctuation">(</span>pf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id=c语言程序的预处理过程><a class=anchor href=#c语言程序的预处理过程>#</a> C语言程序的预处理过程</h2><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>| test.c        --编译--链接-->     test.exe              | --运行--></pre></td></tr><tr><td data-num=2></td><td><pre>| 源文件(源程序)                二进制的信息(二进制文件)   |</pre></td></tr><tr><td data-num=3></td><td><pre>|    --编译器--     编译环境    --链接器--                | 运行环境</pre></td></tr></table></figure><p>在<code>ANSI C</code>中的任何一种实现，都存在两个不同的环境。</p><ul><li><p>第一种是<strong>翻译环境</strong>，在这个环境中源代码被转换为可执行的机器指令</p></li><li><p>第二种是<strong>执行环境</strong>，它用于实际执行代码</p></li></ul><h3 id=翻译环境><a class=anchor href=#翻译环境>#</a> 翻译环境</h3><p><img data-src=https://cdn.jsdelivr.net/gh/ReverseSacle/Gallery@latest/programming/c/basic/2.webp alt="" height=80% width=80%></p><p>由编译器处理的过程叫<strong>编译</strong>，由链接器处理的过程叫<strong>链接</strong>。</p><p>组成一个程序的每个源文件通过编译过程分别转换成目标代码(object code)。</p><p>每个目标文件由链接器(linker)捆绑在一起，形成一个单一而完整的可执行程序。</p><p>链接器同时也会引入标准C函数库中任何被该程序所用到的函数，而且它可以搜索个人定制的程序库，将其需要的函数也链接到程序中。</p><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>|    test.c            ------>         test.exe          |  ----></pre></td></tr><tr><td data-num=2></td><td><pre>| --编译器(编译)--     |编译环境|    --连接器(链接)--    |  运行环境 </pre></td></tr><tr><td data-num=3></td><td><pre>|                      |目标文件|</pre></td></tr><tr><td data-num=4></td><td><pre>|  预编译-编译-汇编        ||</pre></td></tr></table></figure><p>Linux环境下默认生成<code>a.out</code>可执行文件。</p><p><strong>预编译</strong></p><p><code>gcc -E test.c &gt; test.i</code> - 预编译/预处理，<code>&gt;</code>表示为重定向，生成以<code>.i</code>结尾的文件，过程包括</p><ul><li><p>头文件的包含</p></li><li><p>删除注释</p></li><li><p><code>#define</code>预编译指令的全局替换</p></li></ul><p><strong>编译</strong></p><p><code>gcc -S test.i &gt; test.s</code> - 生成以<code>.s</code>结尾的文件，过程包括</p><ul><li><p>把c语言代码翻译成汇编代码</p></li><li><p>语法分析，词法分析，语义分析，符号汇总(函数名，全局变量)</p></li></ul><p><strong>汇编</strong></p><p><code>gcc -c test.s &gt; test.o</code> - 生成以<code>.o</code>结尾的文件，过程包括</p><ul><li><p>把汇编代码转换为二进制代码</p></li><li><p>生成可重定向目标文件</p></li><li><p>形成符号表</p><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>int Add(int x,int y)</pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>	return x + y;</pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=5></td><td><pre> __________</pre></td></tr><tr><td data-num=6></td><td><pre>|Add |0x100|</pre></td></tr><tr><td data-num=7></td><td><pre> __________</pre></td></tr></table></figure></li></ul><p><strong>链接</strong></p><p>过程包括，合并段表与符号表的合并和符号表的重定向。</p><details class=info><summary>程序的编译连接，静态链接和动态链接，分别什么时候链接的？</summary><div><p>静态链接的时机是在程序的编译阶段完成后，但在程序生成最终可执行文件之前发生，这通常发生在链接阶段。</p><p>动态链接的时机是在程序运行时发生，在程序启动时由操作系统的动态链接器完成。</p></div></details><h3 id=运行环境><a class=anchor href=#运行环境>#</a> 运行环境</h3><p>程序执行的过程</p><ul><li><p><strong>程序(必须)载入内存中</strong> - 当在有操作系统的环境中执行，一般由操作系统完成；在独立环境中，程序的载入必须手动安排，也可能通过可执行代码置入只读内存来完成</p></li><li><p><strong>程序的执行开始</strong> - 接着便是调用main函数</p></li><li><p><strong>开始执行程序代码</strong> - 这个时候程序将使用一个运行时堆栈(stack)，存储函数的局部变量和返回地址。程序同时也可以使用静态(static)内存，存储于静态内存中的变量在程序的整个执行过程中一直保留它们的值</p></li><li><p><strong>终止程序</strong> - 正常终止main函数，也有可能是意外终止</p></li></ul><h3 id=预处理详解><a class=anchor href=#预处理详解>#</a> 预处理详解</h3><p>预处理指令，<code>#</code>开头的都叫预处理指令。</p><table><thead><tr><th style=text-align:left>预定义符号</th><th style=text-align:left>含义</th></tr></thead><tbody><tr><td style=text-align:left><code>__FILE__</code></td><td style=text-align:left>进行编译的源文件</td></tr><tr><td style=text-align:left><code>__LINE__</code></td><td style=text-align:left>文件当前的行号</td></tr><tr><td style=text-align:left><code>__DATE__</code></td><td style=text-align:left>文件被编译的日期</td></tr><tr><td style=text-align:left><code>__TIME__</code></td><td style=text-align:left>文件被编译的时间</td></tr><tr><td style=text-align:left><code>__STDC__</code></td><td style=text-align:left>如果编译器遵循<code>ANSI C</code>标准，其值为1，否则为未定义</td></tr></tbody></table><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"file:%s line:%d\n"</span><span class="token punctuation">,</span><span class="token constant">__FILE__</span><span class="token punctuation">,</span><span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>#define预处理指令</strong></p><p>定义<strong>标识符</strong>。</p><p>定义<strong>宏</strong>，<code>#define</code>机制有一个规定，允许把参数替换到文本中，这种实现通常称为宏(macro)或定义宏(define macro)。</p><figure class="highlight c"><figcaption data-lang=c><span>宏的声明方式</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">name</span><span class="token expression"><span class="token punctuation">(</span>parament<span class="token operator">-</span>list<span class="token punctuation">)</span> stuff</span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token comment"> * parament-list是一个由逗号隔开的符号表，它们可能出现在stuff中。</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment"> * 参数列表左括号必须与name紧邻，</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment"> * 如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分。</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><p><code>#define</code><strong>替换规则</strong></p><p>在程序扩展<code>#define</code>定义符号和宏时，需要涉及几个步骤。</p><ul><li>在调用宏时，首先对参数进行检查，看看是否包含任何由<code>#define</code>定义的符号。如果是，它们首先被替换</li><li>替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被它们的值替换</li><li>最后，再次对结果文件进行扫描，看看它是否包含任何由<code>#define</code>定义的符号。如果是，重复上述过程</li></ul><p>宏参数和<code>#define</code>定义中可以出现其他<code>#define</code>定义的变量，但是对于宏，不能出现递归。</p><p>当预处理器搜索<code>#define</code>定义的符号时，字符串常量的内容不会被搜索。</p><p><strong>#和##</strong></p><p>将参数名插入到字符串中。</p><p>使用<code>#</code>，可把一个参数名变成对应的字符串。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PRINT</span><span class="token expression"><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">"the value of "</span><span class="token directive-hash">#</span><span class="token expression">X</span><span class="token string">" is %d\n"</span><span class="token expression"><span class="token punctuation">,</span>X<span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token function">PRINT</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 相当于printf("the value of " "a" " is %d\n",a)</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token function">PRINT</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 相当于printf("the value of " "b" " is %d\n",b)</span></pre></td></tr><tr><td data-num=9></td><td><pre>    </pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>##</code>可以把位于它两边的符号合成一个符号。它允许宏定义从分离的文本片段创建标识符。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ADD_TO_SUM</span><span class="token expression"><span class="token punctuation">(</span>num<span class="token punctuation">,</span>value<span class="token punctuation">)</span> sum</span><span class="token punctuation">##</span><span class="token expression">num <span class="token operator">+=</span> value</span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token comment">// 这样的连接必须产生一个合法的标识符，否则其结果就是未定义的</span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">CAT</span><span class="token expression"><span class="token punctuation">(</span>X<span class="token punctuation">,</span>Y<span class="token punctuation">)</span> X</span><span class="token punctuation">##</span><span class="token expression">Y</span></span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">int</span> CLASS84 <span class="token operator">=</span> <span class="token number">2019</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">CAT</span><span class="token punctuation">(</span>CLASS<span class="token punctuation">,</span><span class="token number">84</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 结果为2019，等价于printf("%d\n",CLASS84);</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>带副作用的宏参数</strong></p><p>当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，那么在使用这个宏的时候就可能导致不可预测的后果。副作用就是表达式求值的时候出现的永久性效果。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token comment"> * x+1;// 不带副作用</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token comment"> * x++;// 带有副作用</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment"> * MAX宏可以证明具有副作用的参数所引起的问题。</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment">**/</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MAX</span><span class="token expression"><span class="token punctuation">(</span>X<span class="token punctuation">,</span>Y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span>Y<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>Y<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num=8></td><td><pre></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span>b <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token function">MAX</span><span class="token punctuation">(</span>a<span class="token operator">++</span><span class="token punctuation">,</span>b<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//12</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//11</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//13</span></pre></td></tr><tr><td data-num=16></td><td><pre>    </pre></td></tr><tr><td data-num=17></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>宏和函数的对比</strong></p><p>宏通常被应用于执行简单的运算，比如在两个数中找出较大的一个。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MAX</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MIN</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span></pre></td></tr></table></figure><p>那为什么不用函数来完成这个呢？原因有</p><ul><li>用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。所以宏比函数在程序的规模和速度方面更胜一筹</li><li>更为重要的是函数的参数必须声明为特定类型，所以函数只能在类型合适的表达式上使用。反之宏可以适用于整型，长整型，浮点型等可用比较运算符<code>&gt;</code>来比较的类型。即，宏是类型无关的</li></ul><p>宏相比于函数劣势的地方</p><ul><li>每次使用宏的时候，一份宏定义的代码将插入到程序中，除非宏比较短，否则可能大幅度增加程序的长度</li><li>宏是没法调试的</li><li>宏由于类型无关，也就不够严谨</li><li>宏可能会带来运算符优先级的问题，导致容易出错</li></ul><p>宏有时候可以做到函数做不到的事，例如，宏的参数可以是出现的类型。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MALLOC</span><span class="token expression"><span class="token punctuation">(</span>num<span class="token punctuation">,</span>type<span class="token punctuation">)</span> <span class="token punctuation">(</span>type<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>num <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token comment">// ....</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token function">MALLOC</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 类型作为参数</span></pre></td></tr></table></figure><table><thead><tr><th style=text-align:left>属性</th><th style=text-align:left>#define定义宏</th><th style=text-align:left>函数</th></tr></thead><tbody><tr><td style=text-align:left>代码长度</td><td style=text-align:left>每次使用时，宏代码都会被插入到程序中。除了非常小的宏之外，程序的长度会大幅度增长。</td><td style=text-align:left>函数代码只出现于一个地方；每次使用这个函数时，都调用那个地方的同一份代码。</td></tr><tr><td style=text-align:left>执行速度</td><td style=text-align:left>更快</td><td style=text-align:left>存在函数的调用和返回的额外开销，所以相对慢一些。</td></tr><tr><td style=text-align:left>运算符优先级</td><td style=text-align:left>宏参数的求值是在所以周围表达式的上下文环境中，除非加上括号，否则邻近运算符的优先级可能会产生不可预料的后果，所以建议宏在书写的时候多些括号。</td><td style=text-align:left>函数参数只在函数调用的时候求值一次，它的结果值传递给函数。表达式的求值结果更容易预测。</td></tr><tr><td style=text-align:left>带有的副作用</td><td style=text-align:left>参数可能被替换到宏体中的多个位置，所以带有副作用的参数求值可能会产生不可预料的后果。</td><td style=text-align:left>函数参数只在传参的时候求值一次，结果更容易控制。</td></tr><tr><td style=text-align:left>参数类型</td><td style=text-align:left>宏的参数与类型无关，只要对参数的操作是合法的，它就可以使用与任何参数类型。</td><td style=text-align:left>函数的参数是与类型有关的，如果参数的类型不同，就需要不同的函数，即使它们执行的任务是不同的。</td></tr><tr><td style=text-align:left>调试</td><td style=text-align:left>宏是不方便调试的</td><td style=text-align:left>函数是可以逐语句调试的</td></tr><tr><td style=text-align:left>递归</td><td style=text-align:left>宏是不能递归的</td><td style=text-align:left>函数是可以递归的</td></tr></tbody></table><p><strong>命名约定</strong></p><p>一般来讲函数与宏的使用语法很相似。所以语言本身没法区分二者，为此就有一个习惯，把宏名写成大写，函数名不要全部写成大写。</p><p><strong>#undef</strong></p><p>这条指令用于移除一个宏定义。</p><h3 id=命令行定义><a class=anchor href=#命令行定义>#</a> 命令行定义</h3><p>许多C编译器提供了一种能力，允许在命令行中定义符号。用于启动编译过程。例如，当同一个源文件要编译出不同的一个程序的不同版本时，这个特性是有用的。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token comment"> * 假设某个程序中声明了一个某个长度的数组，</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token comment"> * 如果机器内存有限，需要一个很小的数组，</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment"> * 但是另外一个机器内存大一点，需要一个大一点的数组</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment">**/</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=7></td><td><pre></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">int</span> array<span class="token punctuation">[</span>ARRAY_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> ARRAY_SIZE<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    </pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> ARRAY_SIZE<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=15></td><td><pre>    	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=17></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=18></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token comment"> * 命令行指定符号值</span></pre></td></tr><tr><td data-num=22></td><td><pre><span class="token comment"> * gcc test.c -D ARRAY_SIZE=10</span></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><h3 id=条件编译><a class=anchor href=#条件编译>#</a> 条件编译</h3><p>在编译一个程序的时候，如果要将一条(组)语句编译或放弃是很方便的，因为有条件编译指令。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__DEBUG__</span></span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__DEBUG__</span></span></pre></td></tr><tr><td data-num=12></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 为了观察数组是否赋值成功</span></pre></td></tr><tr><td data-num=13></td><td><pre>        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>常见的条件编译指令</strong></p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">常量表达式</span></span></pre></td></tr><tr><td data-num=2></td><td><pre>	<span class="token comment">// ...</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment">// 多分支的条件编译</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">常量表达式</span></span></pre></td></tr><tr><td data-num=7></td><td><pre>	<span class="token comment">// ....</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression">常量表达式</span></span></pre></td></tr><tr><td data-num=9></td><td><pre>	<span class="token comment">// ....</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span></pre></td></tr><tr><td data-num=11></td><td><pre>	<span class="token comment">// ....</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr><tr><td data-num=13></td><td><pre></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token comment">// 判断是否被定义</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>symbol<span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">symbol</span></span></pre></td></tr><tr><td data-num=17></td><td><pre></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token comment">// 判断是否未被定义</span></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token operator">!</span><span class="token function">defined</span><span class="token punctuation">(</span>symbol<span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">symbol</span></span></pre></td></tr><tr><td data-num=21></td><td><pre></pre></td></tr><tr><td data-num=22></td><td><pre></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token comment">// 嵌套指令</span></pre></td></tr><tr><td data-num=24></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>OS_UNIX<span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num=25></td><td><pre>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">OPTION1</span></span></pre></td></tr><tr><td data-num=26></td><td><pre>        <span class="token function">unix_version_option1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=27></td><td><pre>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr><tr><td data-num=28></td><td><pre>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">OPTION2</span></span></pre></td></tr><tr><td data-num=29></td><td><pre>    	<span class="token function">unix_version_option2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=30></td><td><pre>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr><tr><td data-num=31></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>OS_MSDOS<span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num=32></td><td><pre>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">OPTION2</span></span></pre></td></tr><tr><td data-num=33></td><td><pre>        <span class="token function">msdos_version_option2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=34></td><td><pre>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr><tr><td data-num=35></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr></table></figure><p><strong>解决头文件代码重复包含问题</strong></p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 方法一</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_XXX</span></span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_XXX</span></span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token comment">// 代码内容</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token comment">// 方法二</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span></pre></td></tr></table></figure><h3 id=文件包含><a class=anchor href=#文件包含>#</a> 文件包含</h3><p><code>#define</code>指令可以使另一个文件被编译，这种替换的方式很简单，预处理器先删除这条指令，并用包含文件的内容替换，这样一个源文件被包含10次，那就实际被编译10次。</p><p><strong>头文件被包含的方式</strong></p><p>linux环境的标准头文件路径<code>/usr/include</code>。</p><p>本地文件包含 - <code>#include &quot;filename&quot;</code> - 查找策略</p><p>先在源文件所在目录下查找，如果该头文件未找到，编译器就像查找库函数头文件一样的方式在标准位置查找头文件。如果找不到就提示编译错误。</p><p>库文件包含 - <code>#include&lt;filename.h&gt;</code> - 查找策略</p><p>直接取标准路径下查找，如果找不到就提示编译错误。</p><hr><p>可嵌套文件包含，但会导致文件被多次引用，解决方法</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 方法一</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__TEST_H__</span></span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__TEST_H__</span></span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment">// ...</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr><tr><td data-num=8></td><td><pre></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token comment">// 方法二</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span></pre></td></tr></table></figure><p><strong>计算结构体中某变量相对于首地址的偏移</strong></p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stddef.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">S</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">char</span> c1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">int</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">char</span> c2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token keyword">int</span> <span class="token function">main1</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token function">pirntf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">offsetof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">S</span><span class="token punctuation">,</span>c1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// c1相对于首地址的偏移</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token function">pirntf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">offsetof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">S</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// a相对于首地址的偏移</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token function">pirntf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">offsetof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">S</span><span class="token punctuation">,</span>c2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// c2相对于首地址的偏移</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=17></td><td><pre></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token comment">// 模拟实现offsetof宏</span></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token comment">// 把0强制类型转为struct_name指针来访问成员，获取该成员地址后转为整型</span></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">OFFSETOF</span><span class="token expression"><span class="token punctuation">(</span>struct_name<span class="token punctuation">,</span>member_name<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>struct_name<span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-></span>member_name<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token keyword">int</span> <span class="token function">main2</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=22></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=23></td><td><pre>    <span class="token function">pirntf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">OFFSETOF</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">S</span><span class="token punctuation">,</span>c1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// c1相对于首地址的偏移</span></pre></td></tr><tr><td data-num=24></td><td><pre>    <span class="token function">pirntf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">OFFSETOF</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">S</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// a相对于首地址的偏移</span></pre></td></tr><tr><td data-num=25></td><td><pre>    <span class="token function">pirntf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">OFFSETOF</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">S</span><span class="token punctuation">,</span>c2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// c2相对于首地址的偏移</span></pre></td></tr><tr><td data-num=26></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=27></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id=通用性编程处理><a class=anchor href=#通用性编程处理>#</a> 通用性编程处理</h2><p>由于各编译器的规则的不同，可能导致逻辑上的错误，因此需避免复杂的表达式。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">int</span> nums1<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">int</span> nums2<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    </pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token comment">//while(i &lt; 5)&#123; nums2[i++] = nums1[i]; &#125;// 由编译器的不同可能会导致逻辑错误的地方</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">++</span>i<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">// 防御性编程写法</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token comment"> * 当使用gcc编译时，</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token comment"> * 由于结合性与其他编译器不同，导致先执行了nums2[i++]中</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token comment"> * i的相关操作，而导致i向后偏移了一位，这造成了逻辑上的错误</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><h2 id=常用c语言标准库><a class=anchor href=#常用c语言标准库>#</a> 常用C语言标准库</h2><p><font size=4><ins><strong>limits.h</strong></ins></font></p><p>提供了一些基本的数据类型大小信息，如整数类型的取值范围、字符类型的取值范围等。</p><p>定义了宏(macros)，这些宏表示了编译器支持的不同数据类型的极限值。</p><table><thead><tr><th style=text-align:left>宏</th><th style=text-align:left>描述</th></tr></thead><tbody><tr><td style=text-align:left>INT_MAX</td><td style=text-align:left>有符号整数的最大值</td></tr><tr><td style=text-align:left>INT_MIN</td><td style=text-align:left>有符号整数的最小值</td></tr><tr><td style=text-align:left>LONG_MAX</td><td style=text-align:left>有符号长整数的最大值</td></tr><tr><td style=text-align:left>LONG_MIN</td><td style=text-align:left>有符号长整数的最小值</td></tr></tbody></table><p><font size=4><ins><strong>stddef.h</strong></ins></font></p><p>定义了一些常用的类型和宏。</p><p>这个头文件通常被包含在其他标准头文件中，如<code>&lt;stdio.h&gt;</code>和<code>&lt;stdlib.h&gt;</code>。</p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token class-name">size_t</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token class-name">size_t</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token class-name">ptrdiff_t</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token class-name">ptrdiff_t</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">offsetof</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">,</span> member<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>type <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-></span>member<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span></pre></td></tr></table></figure><h2 id=相关补充项><a class=anchor href=#相关补充项>#</a> 相关补充项</h2><details class=info><summary>I/O是什么？</summary><div><p>I/O是输入/输出(Input/Output)的缩写，是计算机领域中用于描述数据的传输与交流的术语。I/O涵盖了计算机系统中与外部环境(例如硬件设备、文件系统、网络等)进行数据交换的所有操作。输入通常是指从外部环境传输数据到计算机系统，而输出是指将数据从计算机系统传输到外部环境。常见的I/O类型和场景有</p><ul><li><p><strong>文件I/O</strong> - 与文件系统进行交互，包括读取文件内容和写入数据到文件。在<code>C/C++</code>中，使用标准库函数如 <code>fopen</code>、<code>fwrite</code>、<code>fread</code> 等来进行文件I/O操作</p></li><li><p><strong>控制台I/O</strong> - 与终端进行交互，包括从用户输入获取数据和将数据输出到屏幕。在<code>C/C++</code>中，使用 <code>printf</code>、<code>scanf</code> 等函数进行控制台I/O</p></li><li><p><strong>网络I/O</strong> - 通过网络进行数据传输，包括与远程计算机通信。在网络编程中，使用套接字(socket)等机制进行网络I/O</p></li><li><p><strong>设备I/O</strong> - 与硬件设备进行交互，包括读写磁盘、控制打印机、与传感器通信等。在操作系统层面，设备驱动程序负责管理设备I/O</p></li><li><p><strong>内存I/O</strong> - 将数据从内存写入磁盘或从磁盘读取到内存，通常涉及文件系统和缓存管理</p></li><li><p><strong>图形界面I/O</strong> - 与图形用户界面进行交互，包括接收鼠标点击、键盘输入等，以及在屏幕上显示图形和文本</p></li></ul><p>在计算机系统中，I/O是一个关键的概念，因为计算机系统通常需要与外部环境进行数据交互。高效的I/O操作对于系统性能和用户体验都至关重要。在编程中，开发人员需要使用适当的API和函数来处理各种类型的I/O操作，确保数据的正确传输和处理。</p></div></details><div class=tags><a href=/tags/programming-language/ rel=tag><i class="ic i-tag"></i> 编程语言</a></div></div><footer><div class=meta><span class=item><span class=icon><i class="ic i-calendar-check"></i></span> <span class=text>更新于</span> <time title="修改时间：2025-09-19 22:24:59" itemprop=dateModified datetime=2025-09-19T22:24:59+08:00>2025-09-19</time></span><span class=item data-path=/computer-science/programming/c-language/basis/c/cpart2/ title=阅读次数><span class=icon><i class="ic i-eye"></i></span> <span class=text>阅读次数</span><span class=waline-pageview-count></span> <span class=text>次</span></span></div><div id=copyright><ul><li class=author><strong>本文作者：</strong> ReverseSacle <i class="ic i-at"><em>@</em></i>逆转天平</li><li class=link><strong>本文链接：</strong> <a href=https://www.reversesacle.com/computer-science/programming/c-language/basis/c/cpart2/ title=C语言基础-第二部分-C89&#x2F;C90标准>https://www.reversesacle.com/computer-science/programming/c-language/basis/c/cpart2/</a></li><li class=license><strong>版权声明：</strong> 本站所有文章除特别声明外，均采用 <span class=exturl data-url=aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class=post-nav><div class="item left"><a href=/computer-science/programming/c-language/basis/c/cpart1/ itemprop=url rel=prev data-background-image=https:&#x2F;&#x2F;resa-imgs.oss-accelerate.aliyuncs.com&#x2F;img&#x2F;acg8.webp title=C语言基础-第一部分-C89&#x2F;C90标准><span class=type>上一篇</span><span class=category><i class="ic i-flag"></i> C语言基础</span><h3>C语言基础-第一部分-C89/C90标准</h3></a></div><div class="item right"><a href=/computer-science/programming/c-language/basis/c/cpart3/ itemprop=url rel=next data-background-image=https:&#x2F;&#x2F;resa-imgs.oss-accelerate.aliyuncs.com&#x2F;img&#x2F;acg12.webp title=C语言基础-第三部分-C99标准><span class=type>下一篇</span><span class=category><i class="ic i-flag"></i> C语言基础</span><h3>C语言基础-第三部分-C99标准</h3></a></div></div><div class=wrap id=comments><div id=waline-comment></div></div></div><div id=sidebar><div class=inner><div class=panels><div class=inner><div class="contents panel pjax" data-title=文章目录><ol class=toc><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%AE%A1%E7%90%86><span class=toc-number>1.</span> <span class=toc-text>内存操作与管理</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80><span class=toc-number>1.1.</span> <span class=toc-text>系统内存布局</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E5%92%8C%E9%87%8A%E6%94%BE><span class=toc-number>1.2.</span> <span class=toc-text>内存申请和释放</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%B8%B8%E8%A7%81%E4%B8%8E%E5%86%85%E5%AD%98%E6%9C%89%E5%85%B3%E7%9A%84%E9%94%99%E8%AF%AF%E6%93%8D%E4%BD%9C><span class=toc-number>1.3.</span> <span class=toc-text>常见与内存有关的错误操作</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92><span class=toc-number>1.4.</span> <span class=toc-text>指针作为参数传递</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0><span class=toc-number>1.5.</span> <span class=toc-text>字符串相关的内存操作函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84%E5%92%8C%E5%87%BD%E6%95%B0><span class=toc-number>2.</span> <span class=toc-text>指针与数组和函数</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%BB%84%E5%90%8D%E8%AF%A6%E8%A7%A3><span class=toc-number>2.1.</span> <span class=toc-text>一维数组的数组名详解</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%BB%84%E5%90%8D%E8%AF%A6%E8%A7%A3><span class=toc-number>2.2.</span> <span class=toc-text>二维数组的数组名详解</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88%E8%BF%9B%E9%98%B6><span class=toc-number>2.3.</span> <span class=toc-text>数组的指针进阶</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E6%95%B0%E7%BB%84%E8%BF%9B%E9%98%B6><span class=toc-number>2.4.</span> <span class=toc-text>函数与指针的数组进阶</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9B%E9%98%B6><span class=toc-number>2.5.</span> <span class=toc-text>数组与指针与函数的进阶</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B><span class=toc-number>3.</span> <span class=toc-text>自定义数据类型</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%BB%93%E6%9E%84%E4%BD%93><span class=toc-number>3.1.</span> <span class=toc-text>结构体</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%BB%93%E6%9E%84%E4%BD%93-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90memory-alignment><span class=toc-number>3.2.</span> <span class=toc-text>结构体-内存对齐(Memory Alignment)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%81%94%E5%90%88%E4%BD%93%E5%85%B1%E7%94%A8%E4%BD%93><span class=toc-number>3.3.</span> <span class=toc-text>联合体&#x2F;共用体</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%BD%8D%E6%AE%B5%E4%BD%8D%E5%9F%9Fbit-fields><span class=toc-number>3.4.</span> <span class=toc-text>位段&#x2F;位域(Bit Fields)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%9E%9A%E4%B8%BE><span class=toc-number>3.5.</span> <span class=toc-text>枚举</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C><span class=toc-number>4.</span> <span class=toc-text>文件操作</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%A6%82%E8%BF%B0><span class=toc-number>4.1.</span> <span class=toc-text>概述</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD><span class=toc-number>4.2.</span> <span class=toc-text>文件的打开和关闭</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%96%87%E4%BB%B6%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99><span class=toc-number>4.3.</span> <span class=toc-text>文件的顺序读写</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%96%87%E4%BB%B6%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99><span class=toc-number>4.4.</span> <span class=toc-text>文件的随机读写</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9D%9F%E5%88%A4%E5%AE%9A><span class=toc-number>4.5.</span> <span class=toc-text>文件结束判定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B><span class=toc-number>5.</span> <span class=toc-text>C语言程序的预处理过程</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%BF%BB%E8%AF%91%E7%8E%AF%E5%A2%83><span class=toc-number>5.1.</span> <span class=toc-text>翻译环境</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83><span class=toc-number>5.2.</span> <span class=toc-text>运行环境</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E9%A2%84%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3><span class=toc-number>5.3.</span> <span class=toc-text>预处理详解</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9A%E4%B9%89><span class=toc-number>5.4.</span> <span class=toc-text>命令行定义</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91><span class=toc-number>5.5.</span> <span class=toc-text>条件编译</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB><span class=toc-number>5.6.</span> <span class=toc-text>文件包含</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E9%80%9A%E7%94%A8%E6%80%A7%E7%BC%96%E7%A8%8B%E5%A4%84%E7%90%86><span class=toc-number>6.</span> <span class=toc-text>通用性编程处理</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%B8%B8%E7%94%A8c%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93><span class=toc-number>7.</span> <span class=toc-text>常用C语言标准库</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%9B%B8%E5%85%B3%E8%A1%A5%E5%85%85%E9%A1%B9><span class=toc-number>8.</span> <span class=toc-text>相关补充项</span></a></li></ol></div><div class="related panel pjax" data-title=系列文章><ul><li><a href=/computer-science/programming/c-language/basis/c/cpart1/ rel=bookmark title=C语言基础-第一部分-C89/C90标准>C语言基础-第一部分-C89/C90标准</a></li><li class=active><a href=/computer-science/programming/c-language/basis/c/cpart2/ rel=bookmark title=C语言基础-第二部分-C89/C90标准>C语言基础-第二部分-C89/C90标准</a></li><li><a href=/computer-science/programming/c-language/basis/c/cpart3/ rel=bookmark title=C语言基础-第三部分-C99标准>C语言基础-第三部分-C99标准</a></li><li><a href=/computer-science/programming/c-language/basis/c/code-optimization/ rel=bookmark title=代码优化>代码优化</a></li></ul></div><div class="overview panel" data-title=站点概览><div class=author itemprop=author itemscope itemtype=http://schema.org/Person><img class=image itemprop=image alt=ReverseSacle data-src=/images/avatar.webp><p class=name itemprop=name>ReverseSacle</p><div class=description itemprop=description>知识书库 & 学习点滴</div></div><nav class=state><div class="item posts"><a href=/archives/ ><span class=count>186</span> <span class=name>文章</span></a></div><div class="item categories"><a href=/categories/ ><span class=count>52</span> <span class=name>分类</span></a></div><div class="item tags"><a href=/tags/ ><span class=count>18</span> <span class=name>标签</span></a></div></nav><div class=social><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JldmVyc2VTYWNsZQ==" title=https:&#x2F;&#x2F;github.com&#x2F;ReverseSacle><i class="ic i-github"></i></span><span class="exturl item email" data-url="bWFpbHRvOnByaXZhdGVAcmV2ZXJzZXNhY2xlLmNvbQ==" title=mailto:private@reversesacle.com><i class="ic i-envelope"></i></span></div><ul class=menu><li class=item><a href=/ rel=section><i class="ic i-home"></i> 首页</a></li><li class="item dropdown"><a href=javascript:void(0);><i class="ic i-feather"></i> 文章</a><ul class=submenu><li class=item><a href=/archives/ rel=section><i class="ic i-list-alt"></i> 归档</a></li><li class=item><a href=/categories/ rel=section><i class="ic i-th"></i> 分类</a></li><li class=item><a href=/tags/ rel=section><i class="ic i-tags"></i> 标签</a></li></ul></li><li class=item><a href=/about/ rel=section><i class="ic i-user"></i> 关于</a></li><li class=item><a href=/friend-links/ rel=section><i class="ic i-heart"></i> 友链</a></li></ul></div></div></div><ul id=quick><li class="prev pjax"><a href=/computer-science/programming/c-language/basis/c/cpart1/ rel=prev title=上一篇><i class="ic i-chevron-left"></i></a></li><li class=up><i class="ic i-arrow-up"></i></li><li class=down><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href=/computer-science/programming/c-language/basis/c/cpart3/ rel=next title=下一篇><i class="ic i-chevron-right"></i></a></li><li class=percent></li></ul></div></div><div class=dimmer></div></div></main><footer id=footer><div class=inner><div class=widgets><div class="rpost pjax"><h2>随机文章</h2><ul><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/rust/ title="分类于 Rust">Rust</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/rust/rust-basic/ title="分类于 Rust基础">Rust基础</a></div><span><a href=/computer-science/programming/rust/rust-basic/rustpart2/ title=Rust语言-基础-第二部分>Rust语言-基础-第二部分</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/network-programming/ title="分类于 网络编程">网络编程</a></div><span><a href=/computer-science/programming/network-programming/http/ title=HTTP网络通信基础>HTTP网络通信基础</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/dynamic-program/ title="分类于 动态规划">动态规划</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/dynamic-program/nums/pascals-triangle/ title=帕斯卡三角>帕斯卡三角</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/algorithm/ title="分类于 算法">算法</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/algorithm/sort/ title="分类于 序列重组">序列重组</a></div><span><a href=/computer-science/programming/algorithm/sort/radix-sort/ title=基数排序>基数排序</a></span></li><li class=item><div class=breadcrumb><a href=/categories/general-science-and-technology/ title="分类于 通用科学技术">通用科学技术</a><i class="ic i-angle-right"></i> <a href=/categories/general-science-and-technology/pc/ title="分类于 通用技术之PC端">通用技术之PC端</a><i class="ic i-angle-right"></i> <a href=/categories/general-science-and-technology/pc/router/ title="分类于 路由器">路由器</a></div><span><a href=/general-science-and-technology/pc/router/side-router-setting/ title=副路由的设置方法>副路由的设置方法</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a></div><span><a href=/computer-science/programming/c-language/c-data-structure/linear-structure/link-stack/ title=C语言-链栈>C语言-链栈</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/c-data-structure/ title="分类于 C语言数据结构">C语言数据结构</a></div><span><a href=/computer-science/programming/c-language/c-data-structure/generalized-table/ title=线性表进阶之广义表(列表)>线性表进阶之广义表(列表)</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/c-data-structure/ title="分类于 C语言数据结构">C语言数据结构</a></div><span><a href=/computer-science/programming/c-language/c-data-structure/hashtable/ title=查找之哈希表>查找之哈希表</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/binary-tree/ title="分类于 二叉树">二叉树</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/binary-tree/sort/ title=二叉树-序列重组>二叉树-序列重组</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/computer-basic/ title="分类于 计算机基础">计算机基础</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/computer-basic/computer-composition-principles/ title="分类于 计算机组成原理">计算机组成原理</a></div><span><a href=/computer-science/computer-basic/composition/ccppart3/ title=计算机组成原理-CSAPP-第三部分>计算机组成原理-CSAPP-第三部分</a></span></li></ul></div><div><h2>最新评论</h2><ul id=waline-recent></ul></div></div><div class=status><div class=copyright>&copy; 2021 – <span itemprop=copyrightYear>2025</span><span class=with-love><i class="ic i-sakura rotate"></i></span> <span class=author itemprop=copyrightHolder>ReverseSacle @ ReverseSacle-Blog</span></div><div class=count><i class="ic i-clock" aria-hidden=true></i> <span id=time align=center>载入时间中...<script defer>var now=new Date;function createtime(){var n=new Date("2021-11-16 22:30:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("time").innerHTML="已经过 "+dnum+" 天 "+hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></span><span class=post-meta-item-icon>|&nbsp<i class="ic i-chart-area"></i></span> <span title=站点总字数>2.1m 字</span> <span class=post-meta-item-icon>|&nbsp<i class="ic i-coffee"></i></span> <span title=站点阅读时长>40:40</span></div></div></div></footer></div><script data-config>var LOCAL={path:"computer-science/programming/c-language/basis/c/cpart2/",favicon:{show:"ReverseSacle-Blog",hide:"ReverseSacle-Blog"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},waline:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src=https://polyfill.alicdn.com/v3/polyfill.min.js></script><script src=https://cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1.16.0/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js></script><script src=/js/app.js></script></body></html>