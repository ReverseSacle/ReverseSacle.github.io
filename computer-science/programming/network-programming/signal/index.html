<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content=#222><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=icon type=image/ico sizes=48x48 href=/images/favicon.ico><link rel=alternate type=application/rss+xml title=逆转天平 href=https://www.reversesacle.com/rss.xml><link rel=alternate type=application/atom+xml title=逆转天平 href=https://www.reversesacle.com/atom.xml><link rel=alternate type=application/json title=逆转天平 href=https://www.reversesacle.com/feed.json><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel=stylesheet href=/css/app.css><meta name=description content=网络编程><link rel=canonical href=https://www.reversesacle.com/computer-science/programming/network-programming/signal/ ><title>Linux的信号(signal) - 网络编程 - 编程 - 计算机科学 | ReverseSacle-Blog</title><meta name=generator content="Hexo 6.3.0"></head><body itemscope itemtype=http://schema.org/WebPage><div id=loading><div class=dotloader><div class=dot></div><div class=dot></div><div class=dot></div><div class=dot></div><div class=dot></div></div></div><div id=container><header id=header itemscope itemtype=http://schema.org/WPHeader><div class=inner><div id=brand><div class=pjax><h1 itemprop="name headline">Linux的信号(signal)</h1><div class=meta><span class=item title="创建时间：2023-07-31 15:31:55"><span class=icon><i class="ic i-calendar"></i></span> <span class=text>发表于</span> <time itemprop="dateCreated datePublished" datetime=2023-07-31T15:31:55+08:00>2023-07-31</time></span><span class=item title=本文字数><span class=icon><i class="ic i-pen"></i></span> <span class=text>本文字数</span> <span>4.3k</span> <span class=text>字</span></span><span class=item title=阅读时长><span class=icon><i class="ic i-clock"></i></span> <span class=text>阅读时长</span> <span>5 分钟</span></span></div></div></div><nav id=nav><div class=inner><div class=toggle><div class=lines role=navigation aria-label=切换导航栏><span class=line></span><span class=line></span><span class=line></span></div></div><ul class=menu><li class="item title"><a href=/ rel=start>ReverseSacle-Blog</a></li></ul><ul class=right><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id=imgs class=pjax><ul><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg14.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg6.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg9.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg19.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg15.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg8.webp></li></ul></div></header><div id=waves><svg class=waves xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink viewBox="0 24 150 28" preserveAspectRatio=none shape-rendering=auto><defs><path id=gentle-wave d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352z"/></defs><g class=parallax><use xlink:href=#gentle-wave x=48 y=0 /><use xlink:href=#gentle-wave x=48 y=3 /><use xlink:href=#gentle-wave x=48 y=5 /><use xlink:href=#gentle-wave x=48 y=7 /></g></svg></div><main><div class=inner><div id=main class=pjax><div class="article wrap"><div class=breadcrumb itemscope itemtype=https://schema.org/BreadcrumbList><i class="ic i-home"></i> <span><a href=/ >首页</a></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/ itemprop=item rel=index title="分类于 计算机科学"><span itemprop=name>计算机科学</span></a><meta itemprop=position content=1></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/programming/ itemprop=item rel=index title="分类于 编程"><span itemprop=name>编程</span></a><meta itemprop=position content=2></span><i class="ic i-angle-right"></i> <span class=current itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/programming/network-programming/ itemprop=item rel=index title="分类于 网络编程"><span itemprop=name>网络编程</span></a><meta itemprop=position content=3></span></div><article itemscope itemtype=http://schema.org/Article class="post block" lang=zh-CN><link itemprop=mainEntityOfPage href=https://www.reversesacle.com/computer-science/programming/network-programming/signal/ ><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content=/images/avatar.webp><meta itemprop=name content=ReverseSacle><meta itemprop=description content="所见即所得，所思即所行, 知识书库 & 学习点滴"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content=逆转天平></span><div class="body md" itemprop=articleBody><h2 id=概述><a class=anchor href=#概述>#</a> 概述</h2><p>想让程序在后台运行，有两种方法</p><ul><li><p>在执行程序命令的时候，在命令最后面<strong>加上<code>&amp;</code>符号</strong></p><ul><li>在后台运行的程序，无法用<code>Ctrl c</code>退出</li><li>当用户退出shell界面，程序仍在后台运行并由shell托管(父进程编号为1即表示由shell托管)。</li></ul></li><li><p><strong>采用fork</strong>，主程序执行fork，生成一个子进程，然后父进程退出，留下子进程继续运行，子进程将由系统托管</p></li></ul><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul><li>终止后台运行的程序，即强行终止正在运行的程序<ul><li><code>killall 运行中的程序名</code></li><li><code>kill 进程编号</code></li></ul></li></ul><h2 id=程序运行捕获信号><a class=anchor href=#程序运行捕获信号>#</a> 程序运行捕获信号</h2><p>程序在运行的过程中，用<code>Ctrl c</code>，kill，killall中止，其本质是向程序发送信号，程序对这两个信号的缺省行为是程序中止运行。</p><p>在程序中，可以捕获信号，编写信息处理函数，即收到信号后执行的代码。</p><p>需包含头文件 - <code>#include&lt;signal.h&gt;</code></p><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;signal.h></span></span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 键盘中断Ctrl c</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token function">signal</span><span class="token punctuation">(</span>SIGTERM<span class="token punctuation">,</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 采用`kill 进程编号`或`killall 程序名`通知程序</span></pre></td></tr></table></figure><p>在程序中设置完signal与其相应执行函数后，原来的signal行为将会被覆盖，在程序执行过程中，当使用键盘输入信号按键，此时程序会执行程序中的signal相应的执行函数。</p><h2 id=信号signal><a class=anchor href=#信号signal>#</a> ! 信号(signal)</h2><ul><li>信号是进程之间互相传递消息的一种方法，信号全称为<strong>软中断信号</strong>，也有人称作软中断，实质与使用中断很像</li><li>软中断信号用来通知进程发什么了什么事件，进程之间可以通过调用kill库函数发送软中断信号</li><li>Linux内核也可能给进程发送信号，通知进程发生了某个事件，如内存越界</li><li>信号无法给进程传递任何数据，进程对信号的处理方式有三种<ul><li>第一种 - 忽略某个信号，对该信号不做任何处理，就像未发生过一样</li><li>第二种 - 设置中断的处理函数，收到信号后，由处理函数来处理</li><li>第三种 - 对该信号的处理采用系统的默认操作，大部分的信号的默认操作是终止进程</li></ul></li></ul><h2 id=信号的类型><a class=anchor href=#信号的类型>#</a> 信号的类型</h2><ul><li>信号名相当于宏定义</li></ul><table><thead><tr><th style=text-align:center>信号名</th><th style=text-align:center>信号值</th><th style=text-align:center>默认处理动作</th><th style=text-align:center>发出信号的原因</th></tr></thead><tbody><tr><td style=text-align:center>SIGHUP</td><td style=text-align:center>1</td><td style=text-align:center>A</td><td style=text-align:center>终端挂起或控制进程终止</td></tr><tr><td style=text-align:center><strong>SIGINT</strong></td><td style=text-align:center><strong>2</strong></td><td style=text-align:center><strong>A</strong></td><td style=text-align:center><strong>键盘中断Ctrl c</strong></td></tr><tr><td style=text-align:center>SIGQUIT</td><td style=text-align:center>3</td><td style=text-align:center>C</td><td style=text-align:center>键盘的退出键被按下</td></tr><tr><td style=text-align:center>SIGILL</td><td style=text-align:center>4</td><td style=text-align:center>C</td><td style=text-align:center>非法指令</td></tr><tr><td style=text-align:center>SIGABRT</td><td style=text-align:center>6</td><td style=text-align:center>C</td><td style=text-align:center>由abort(3)发出的退出指令</td></tr><tr><td style=text-align:center>SIGFPE</td><td style=text-align:center>8</td><td style=text-align:center>C</td><td style=text-align:center>浮点异常</td></tr><tr><td style=text-align:center><strong>SIGKILL</strong></td><td style=text-align:center><strong>9</strong></td><td style=text-align:center><strong>AEF</strong></td><td style=text-align:center><strong>采用<code>kill -9 进程编号</code>方式强制杀死程序</strong></td></tr><tr><td style=text-align:center><strong>SIGSEGV</strong></td><td style=text-align:center><strong>11</strong></td><td style=text-align:center><strong>C</strong></td><td style=text-align:center><strong>无效的内存引用(core dump)</strong></td></tr><tr><td style=text-align:center>SIGPIPE</td><td style=text-align:center>13</td><td style=text-align:center>A</td><td style=text-align:center>管道破裂，写了一个没有读端口的管道</td></tr><tr><td style=text-align:center>SIGALRM</td><td style=text-align:center>14</td><td style=text-align:center>A</td><td style=text-align:center>由alarm(2)发出的信号</td></tr><tr><td style=text-align:center><strong>SIGTERM</strong></td><td style=text-align:center><strong>15</strong></td><td style=text-align:center><strong>A</strong></td><td style=text-align:center><strong>采用<code>kill 程序名</code>或<code>killall 程序名</code>通知程序</strong></td></tr><tr><td style=text-align:center>SIGUSR1</td><td style=text-align:center>30,10,16</td><td style=text-align:center>A</td><td style=text-align:center>用户自定义信号1</td></tr><tr><td style=text-align:center>SIGUSR2</td><td style=text-align:center>31,12,17</td><td style=text-align:center>A</td><td style=text-align:center>用户自定义信号2</td></tr><tr><td style=text-align:center><strong>SIGCHLD</strong></td><td style=text-align:center><strong>20,17,18</strong></td><td style=text-align:center><strong>B</strong></td><td style=text-align:center><strong>子进程结束信号</strong></td></tr><tr><td style=text-align:center>SIGCONT</td><td style=text-align:center>19,18,25</td><td style=text-align:center></td><td style=text-align:center>进程继续(曾被停止的进程)</td></tr><tr><td style=text-align:center>SIGSTOP</td><td style=text-align:center>17,19,23</td><td style=text-align:center>DEF</td><td style=text-align:center>终止进程</td></tr><tr><td style=text-align:center>SIGTSTP</td><td style=text-align:center>18,20,24</td><td style=text-align:center>D</td><td style=text-align:center>控制终端(tty)上按下停止键</td></tr><tr><td style=text-align:center>SIGTTIN</td><td style=text-align:center>21,21,26</td><td style=text-align:center>D</td><td style=text-align:center>后台进程企图控制终端读</td></tr><tr><td style=text-align:center>SIGTTOU</td><td style=text-align:center>22,22,27</td><td style=text-align:center>D</td><td style=text-align:center>后台进程企图控制终端写</td></tr></tbody></table><p><strong>默认处理动作</strong></p><ul><li>A - 缺省的动作是终止进程</li><li>B - 缺省的动作是忽略此信号，将该信号丢弃，不做处理</li><li>C - 缺省的动作是终止进程并进行内核映像转储(core dump)<ul><li><strong>内核映像转储</strong>是指将进程数据在内存的映射和进程在内核结构种的部分内容以一定格式存储到文件系统，并且进程退出执行。这样做可使开发者得到进程当时执行的数据值，运行他们确定转储的原因，以此来调试程序</li></ul></li><li>D - 缺省的动作是停止进程，进入停止状况后还能重新进行下去</li><li>E - 信号不能被捕获</li><li>F - 信号不能被忽略</li></ul><p><strong>一个进程接收到一个信号后，可以有三种方式处理？</strong></p><ul><li><p>忽略这个信号</p></li><li><p>捕捉这个信号。一旦一个进程决定要捕捉某种信号，就需要提供一个函数，这个函数被称为信号处理程序。当这种信号发给该进程时，内核就运行该信号处理程序</p></li><li><p>执行默认操作</p></li></ul><p><strong>系统如何将一个信号通知到进程？</strong></p><ul><li><p>内核会修改进程上下文信息，并设置标识表明收到信号</p></li><li><p>当进程再次被调度执行时，它会先检查是否有未处理的信号，如果有，就调用相应的信号处理函数</p></li><li><p>如果没有为该信号指定处理函数或者信号被阻塞，那么就执行系统默认的操作，可能是忽略、停止进程或者终止进程等</p></li></ul><h2 id=信号signal库函数><a class=anchor href=#信号signal库函数>#</a> 信号(signal)库函数</h2><ul><li>signal库函数可以设置程序对信号的处理方式</li><li>函数声明 - <code>sighandler_t signal(int signum, sighandler_t handler)</code><ul><li>signum - 信号的编号，可使用信号名或信号值</li><li>handler - 信号的处理方式，有三种情况<ul><li>SIG_IGN - 忽略参数signum所指的信号</li><li>一个自定义的处理信号的函数，信号的编号为这个自定义函数的参数</li><li>SIG_DFL - 恢复参数signum所指信号的处理方式为默认值</li></ul></li><li>一般不关心返回值</li></ul></li></ul><h2 id=信号的应用><a class=anchor href=#信号的应用>#</a> 信号的应用</h2><ul><li>服务程序运行在后台，如果想中止它，强行杀掉不是各好办法，因为程序被杀的时候，是突然死掉，没有释放内存资源，会影响系统稳定。<code>Ctrl c</code>中止与杀程序都是相同效果</li><li>如果能向后台程序发送一个信号，后台程序收到信号后，调用一个函数，在函数中编写释放资源的代码，程序就可以有计划的退出，安全还体面</li><li>信号还可以用于网络服务程序抓包</li></ul><p><strong>应用示例</strong></p><ul><li>在实际开发中，在main函数开始的位置，会先屏蔽掉全部的信号</li></ul><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token function">signal</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>SIG_IGN<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul><li>这么做是不希望程序被干扰，之后再设置开发者关心的信号的处理函数<ul><li>SIGINT</li><li>SIGTERM</li><li>SIGKILL</li></ul></li><li>SIGKILL信号无法被忽略，也无法捕获。只需要设置SIGINT和SIGTERM两个信号的处理函数就可以了，这两个信号可以使用同一个处理函数，函数的代码时释放资源</li></ul><figure class="highlight cpp"><figcaption data-lang=C++></figcaption><table><tr><td data-num=1></td><td><pre><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 程序退出，任何地方都可以使用</span></pre></td></tr></table></figure><ul><li>将信号内容放到一个文件里，其他进程读取文件并根据里面的内容作出相应操作</li></ul><h2 id=发送信号><a class=anchor href=#发送信号>#</a> 发送信号</h2><ul><li>Linux系统提供了kill命令向程序发送信号，C语言也提供了kill库函数，用于在程序中向其他进程或线程发送信号</li><li>函数声明 - <code>int kill(pid_t pid, int sig)</code><ul><li>pid - 有几种情况<ul><li><code>pid &gt; 0</code> - 将信号传给进程号为pid的进程</li><li><code>pid = 0</code> - 将信号传给和目前进程相同进程组的所有进程，常用于父进程给子进程发送信号，注意，发送信号者进程也会收到自己发出的信号</li><li><code>pid = -1</code> - 将信号广播传送给系统内所有进程，例如系统关机时会向所有的登录窗口广播关机信息</li></ul></li><li>sig - 准备发送的信号代码<ul><li>假如值为0则没有任何信号发出，但是系统会执行错误检查，通常会利用sig值为0来检查某个进程是否仍在运行</li></ul></li><li>返回值 - 成功执行返回0，失败返回-1，errno被设为已下的某个值<ul><li>EINVAL - 指定的信号码无效(参数sig不合法)</li><li>EPERM - 权限不够，无法传送信号给指定进程</li><li>ESRCH - 参数pid所指定的进程或进程组不存在</li></ul></li></ul></li></ul><h2 id=可靠信号与不可靠信号><a class=anchor href=#可靠信号与不可靠信号>#</a> 可靠信号与不可靠信号</h2><p>信号分为不可靠信号(1 ~ 32)与可靠信号(34 ~ 64)。</p><p>不可靠信号存在以下问题</p><ul><li>每次信号处理完成后，就会恢复成默认处理行为(早期的signal函数，linux2.6.35.6已修复，不会再恢复了)</li><li>存在信号丢失的问题(进程收到的信号不作排队处理，相同的信号多次到来会合并为一个)</li></ul><p>不可靠的主要问题就是<strong>信号丢失</strong>。</p><h2 id=信号处理函数被中断><a class=anchor href=#信号处理函数被中断>#</a> 信号处理函数被中断</h2><p>当一个信号到达后便调用处理函数，如果这时候有其他的信号发生，会中断之前的处理函数，等新的信号处理函数执行完成后再继续执行之前的处理函数。但是，同一个信号会排队阻塞。</p><h2 id=信号的阻塞><a class=anchor href=#信号的阻塞>#</a> 信号的阻塞</h2><p>如果不希望在接收到信号时中断当前的处理函数，也不希望忽略另外发来的信号，而是延时一段时间再处理这个信号，这种情况可以通过<strong>阻塞信号</strong>来实现。</p><p>信号的阻塞和忽略信号不相同，被阻塞的信号也不会影响进程的行为，信号只是暂时被阻止传递。</p><p>当进程忽略一个信号时，信号会被传递出去，但进程会将信号丢弃。</p><p>执行信号的处理动作称为<strong>信号递达</strong>(Delivery)，信号从产生到递达之间的状态，称为<strong>信号未决</strong>(Pending)。</p><h2 id=信号集库函数><a class=anchor href=#信号集库函数>#</a> 信号集库函数</h2><ul><li>需要头文件 - <code>#include&lt;signal.h&gt;</code></li><li><code>sigset_t set</code> - 定义一个信号集结构</li><li><code>int sigemptyset(sigset_t* set)</code> - 清空信号集</li><li><code>int sigfillset(sigset_t* set)</code> - 全部的信号中再加入到信号集中</li><li><code>int sigaddset(sigset_t* set,int signum)</code> - 把某一个信号加入到信号集</li><li><code>int sigdelset(sigset_t* set,int signum)</code> - 删除某一个信号</li><li><code>int sigismember(const sigset_t* set,int signum)</code> - 判断当前信号是否在信号集中</li></ul><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token class-name">sigset_t</span> set<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token function">sigaddset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>set<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span><span class="token operator">&amp;</span>set<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 延迟信号集里面的信号</span></pre></td></tr></table></figure><h2 id=sigaction><a class=anchor href=#sigaction>#</a> sigaction</h2><p>可用于实现信号的阻塞功能</p><p>sigaction函数声明</p><ul><li><code>int sigaction(int signum,const struct sigaction* act,struct sigaction* oldact)</code></li></ul><figure class="highlight c"><figcaption data-lang=c><span>内置的sigaction结构体</span></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">sigaction</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sa_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 信号的处理函数</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sa_sigaction<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token class-name">siginfo_t</span><span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 相较于旧的信号发送，这个可传输数据</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token class-name">sigset_t</span> sa_mask<span class="token punctuation">;</span><span class="token comment">// 用于触发信号阻塞</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">int</span> sa_flags<span class="token punctuation">;</span><span class="token comment">// 标志位</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sa_restorer<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><figure class="highlight c"><figcaption data-lang=c></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">sigaction</span> stact<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stact<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>stact<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 初始化</span></pre></td></tr><tr><td data-num=3></td><td><pre>stact<span class="token punctuation">.</span>sa_handler <span class="token operator">=</span> <span class="token function">hdfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 指定信号处理函数</span></pre></td></tr><tr><td data-num=4></td><td><pre>stact<span class="token punctuation">.</span>sa_flags <span class="token operator">=</span> SA_RESTART<span class="token punctuation">;</span><span class="token comment">// 如果信号中断了进程的某个系统调用，则系统自动启用该系统调用</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token function">sigaddset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stact<span class="token punctuation">.</span>sa_mask<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 指定需阻塞的信号</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token function">sigaction</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>stact<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置信号2的处理行为</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token function">sigaction</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>stact<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置信号15的处理行为</span></pre></td></tr></table></figure><div class=tags><a href=/tags/network-programming/ rel=tag><i class="ic i-tag"></i> 网络编程</a></div></div><footer><div class=meta><span class=item><span class=icon><i class="ic i-calendar-check"></i></span> <span class=text>更新于</span> <time title="修改时间：2024-03-08 16:14:19" itemprop=dateModified datetime=2024-03-08T16:14:19+08:00>2024-03-08</time></span><span class=item data-path=/computer-science/programming/network-programming/signal/ title=阅读次数><span class=icon><i class="ic i-eye"></i></span> <span class=text>阅读次数</span><span class=waline-pageview-count></span> <span class=text>次</span></span></div><div id=copyright><ul><li class=author><strong>本文作者：</strong> ReverseSacle <i class="ic i-at"><em>@</em></i>逆转天平</li><li class=link><strong>本文链接：</strong> <a href=https://www.reversesacle.com/computer-science/programming/network-programming/signal/ title=Linux的信号(signal)>https://www.reversesacle.com/computer-science/programming/network-programming/signal/</a></li><li class=license><strong>版权声明：</strong> 本站所有文章除特别声明外，均采用 <span class=exturl data-url=aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class=post-nav><div class="item left"><a href=/computer-science/programming/dev-tool/vcpkg/ itemprop=url rel=prev data-background-image=https:&#x2F;&#x2F;resa-imgs.oss-accelerate.aliyuncs.com&#x2F;img&#x2F;acg4.webp title=C&#x2F;C++包管理工具vcpkg><span class=type>上一篇</span><span class=category><i class="ic i-flag"></i> 开发工具</span><h3>C/C++包管理工具vcpkg</h3></a></div><div class="item right"><a href=/computer-science/programming/network-programming/multiprocessing/ itemprop=url rel=next data-background-image=https:&#x2F;&#x2F;resa-imgs.oss-accelerate.aliyuncs.com&#x2F;img&#x2F;acg16.webp title=Linux多进程><span class=type>下一篇</span><span class=category><i class="ic i-flag"></i> 网络编程</span><h3>Linux多进程</h3></a></div></div><div class=wrap id=comments><div id=waline-comment></div></div></div><div id=sidebar><div class=inner><div class=panels><div class=inner><div class="contents panel pjax" data-title=文章目录><ol class=toc><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%A6%82%E8%BF%B0><span class=toc-number>1.</span> <span class=toc-text>概述</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%8D%95%E8%8E%B7%E4%BF%A1%E5%8F%B7><span class=toc-number>2.</span> <span class=toc-text>程序运行捕获信号</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E4%BF%A1%E5%8F%B7signal><span class=toc-number>3.</span> <span class=toc-text>! 信号(signal)</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%B1%BB%E5%9E%8B><span class=toc-number>4.</span> <span class=toc-text>信号的类型</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E4%BF%A1%E5%8F%B7signal%E5%BA%93%E5%87%BD%E6%95%B0><span class=toc-number>5.</span> <span class=toc-text>信号(signal)库函数</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%BA%94%E7%94%A8><span class=toc-number>6.</span> <span class=toc-text>信号的应用</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7><span class=toc-number>7.</span> <span class=toc-text>发送信号</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7%E4%B8%8E%E4%B8%8D%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7><span class=toc-number>8.</span> <span class=toc-text>可靠信号与不可靠信号</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E8%A2%AB%E4%B8%AD%E6%96%AD><span class=toc-number>9.</span> <span class=toc-text>信号处理函数被中断</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E4%BF%A1%E5%8F%B7%E7%9A%84%E9%98%BB%E5%A1%9E><span class=toc-number>10.</span> <span class=toc-text>信号的阻塞</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%BA%93%E5%87%BD%E6%95%B0><span class=toc-number>11.</span> <span class=toc-text>信号集库函数</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#sigaction><span class=toc-number>12.</span> <span class=toc-text>sigaction</span></a></li></ol></div><div class="related panel pjax" data-title=系列文章><ul><li><a href=/computer-science/programming/network-programming/linux-environment/ rel=bookmark title=虚拟机-Linux环境配置>虚拟机-Linux环境配置</a></li><li><a href=/computer-science/programming/network-programming/Linux-basic/ rel=bookmark title="Linux基础(CentOS 7)">Linux基础(CentOS 7)</a></li><li><a href=/computer-science/programming/network-programming/gcc-compiler/ rel=bookmark title=GCC编译器>GCC编译器</a></li><li><a href=/computer-science/programming/network-programming/gdb-debugging-tool/ rel=bookmark title=GDB调试工具>GDB调试工具</a></li><li><a href=/computer-science/programming/network-programming/make-compiler-tool/ rel=bookmark title=make编译工具>make编译工具</a></li><li><a href=/computer-science/programming/network-programming/clibrary/ rel=bookmark title=C/C++静态库与动态库的制作和使用>C/C++静态库与动态库的制作和使用</a></li><li><a href=/computer-science/programming/network-programming/executable-program/ rel=bookmark title=在C/C++程序中调用可执行程序>在C/C++程序中调用可执行程序</a></li><li class=active><a href=/computer-science/programming/network-programming/signal/ rel=bookmark title=Linux的信号(signal)>Linux的信号(signal)</a></li><li><a href=/computer-science/programming/network-programming/multiprocessing/ rel=bookmark title=Linux多进程>Linux多进程</a></li><li><a href=/computer-science/programming/network-programming/log/ rel=bookmark title=C/C++服务程序的运行日志>C/C++服务程序的运行日志</a></li><li><a href=/computer-science/programming/network-programming/multithreading/ rel=bookmark title=Linux多线程>Linux多线程</a></li><li><a href=/computer-science/programming/network-programming/thread-synchronization/ rel=bookmark title=Linux线程同步>Linux线程同步</a></li><li><a href=/computer-science/programming/network-programming/programming/ rel=bookmark title=C/C++网络编程>C/C++网络编程</a></li><li><a href=/computer-science/programming/network-programming/http/ rel=bookmark title=HTTP网络通信基础>HTTP网络通信基础</a></li><li><a href=/computer-science/programming/network-programming/ubuntu-obs-server/ rel=bookmark title="Ubuntu服务器OBS Studio配置">Ubuntu服务器OBS Studio配置</a></li></ul></div><div class="overview panel" data-title=站点概览><div class=author itemprop=author itemscope itemtype=http://schema.org/Person><img class=image itemprop=image alt=ReverseSacle data-src=/images/avatar.webp><p class=name itemprop=name>ReverseSacle</p><div class=description itemprop=description>知识书库 & 学习点滴</div></div><nav class=state><div class="item posts"><a href=/archives/ ><span class=count>186</span> <span class=name>文章</span></a></div><div class="item categories"><a href=/categories/ ><span class=count>52</span> <span class=name>分类</span></a></div><div class="item tags"><a href=/tags/ ><span class=count>18</span> <span class=name>标签</span></a></div></nav><div class=social><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JldmVyc2VTYWNsZQ==" title=https:&#x2F;&#x2F;github.com&#x2F;ReverseSacle><i class="ic i-github"></i></span><span class="exturl item email" data-url="bWFpbHRvOnByaXZhdGVAcmV2ZXJzZXNhY2xlLmNvbQ==" title=mailto:private@reversesacle.com><i class="ic i-envelope"></i></span></div><ul class=menu><li class=item><a href=/ rel=section><i class="ic i-home"></i> 首页</a></li><li class="item dropdown"><a href=javascript:void(0);><i class="ic i-feather"></i> 文章</a><ul class=submenu><li class=item><a href=/archives/ rel=section><i class="ic i-list-alt"></i> 归档</a></li><li class=item><a href=/categories/ rel=section><i class="ic i-th"></i> 分类</a></li><li class=item><a href=/tags/ rel=section><i class="ic i-tags"></i> 标签</a></li></ul></li><li class=item><a href=/about/ rel=section><i class="ic i-user"></i> 关于</a></li><li class=item><a href=/friend-links/ rel=section><i class="ic i-heart"></i> 友链</a></li></ul></div></div></div><ul id=quick><li class="prev pjax"><a href=/computer-science/programming/dev-tool/vcpkg/ rel=prev title=上一篇><i class="ic i-chevron-left"></i></a></li><li class=up><i class="ic i-arrow-up"></i></li><li class=down><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href=/computer-science/programming/network-programming/multiprocessing/ rel=next title=下一篇><i class="ic i-chevron-right"></i></a></li><li class=percent></li></ul></div></div><div class=dimmer></div></div></main><footer id=footer><div class=inner><div class=widgets><div class="rpost pjax"><h2>随机文章</h2><ul><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/c-algorithm/ title="分类于 C版算法">C版算法</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/nums/ title=数理>数理</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a></div><span><a href=/computer-science/programming/c-language/c-data-structure/nonlinear-structure/binary-tree/ title=C语言-二叉树(二叉链表)>C语言-二叉树(二叉链表)</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/link-list/ title="分类于 链表">链表</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/link-list/sort/ title=链表-序列重组>链表-序列重组</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/binary-tree/ title="分类于 二叉树">二叉树</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/binary-tree/search/ title=二叉树-查找>二叉树-查找</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/rust/ title="分类于 Rust">Rust</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/rust/rust-basic/ title="分类于 Rust基础">Rust基础</a></div><span><a href=/computer-science/programming/rust/rust-basic/rustpart1/ title=Rust语言-基础-第一部分>Rust语言-基础-第一部分</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/network-programming/ title="分类于 网络编程">网络编程</a></div><span><a href=/computer-science/programming/network-programming/make-compiler-tool/ title=make编译工具>make编译工具</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/c-basic/ title="分类于 C语言基础">C语言基础</a></div><span><a href=/computer-science/programming/c-language/basis/c/code-optimization/ title=代码优化>代码优化</a></span></li><li class=item><div class=breadcrumb><a href=/categories/general-science-and-technology/ title="分类于 通用科学技术">通用科学技术</a><i class="ic i-angle-right"></i> <a href=/categories/general-science-and-technology/pc/ title="分类于 通用技术之PC端">通用技术之PC端</a><i class="ic i-angle-right"></i> <a href=/categories/general-science-and-technology/pc/laptop/ title="分类于 笔记本">笔记本</a></div><span><a href=/general-science-and-technology/pc/laptop/occupied-cpu-by-lenovo-isf/ title=占用CPU的Lenovo-ISFramework>占用CPU的Lenovo-ISFramework</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/simulation/ title="分类于 模拟">模拟</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/simulation/pattern/ title=模拟-模式>模拟-模式</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/binary-tree/ title="分类于 二叉树">二叉树</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/binary-tree/modify/ title=二叉树-改动>二叉树-改动</a></span></li></ul></div><div><h2>最新评论</h2><ul id=waline-recent></ul></div></div><div class=status><div class=copyright>&copy; 2021 – <span itemprop=copyrightYear>2025</span><span class=with-love><i class="ic i-sakura rotate"></i></span> <span class=author itemprop=copyrightHolder>ReverseSacle @ ReverseSacle-Blog</span></div><div class=count><i class="ic i-clock" aria-hidden=true></i> <span id=time align=center>载入时间中...<script defer>var now=new Date;function createtime(){var n=new Date("2021-11-16 22:30:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("time").innerHTML="已经过 "+dnum+" 天 "+hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></span><span class=post-meta-item-icon>|&nbsp<i class="ic i-chart-area"></i></span> <span title=站点总字数>2.1m 字</span> <span class=post-meta-item-icon>|&nbsp<i class="ic i-coffee"></i></span> <span title=站点阅读时长>40:40</span></div></div></div></footer></div><script data-config>var LOCAL={path:"computer-science/programming/network-programming/signal/",favicon:{show:"ReverseSacle-Blog",hide:"ReverseSacle-Blog"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},waline:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src=https://polyfill.alicdn.com/v3/polyfill.min.js></script><script src=https://cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1.16.0/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js></script><script src=/js/app.js></script></body></html>