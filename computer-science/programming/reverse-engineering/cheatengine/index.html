<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content=#222><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=icon type=image/ico sizes=48x48 href=/images/favicon.ico><link rel=alternate type=application/rss+xml title=逆转天平 href=https://www.reversesacle.com/rss.xml><link rel=alternate type=application/atom+xml title=逆转天平 href=https://www.reversesacle.com/atom.xml><link rel=alternate type=application/json title=逆转天平 href=https://www.reversesacle.com/feed.json><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel=stylesheet href=/css/app.css><meta name=description content=逆向工程><link rel=canonical href=https://www.reversesacle.com/computer-science/programming/reverse-engineering/cheatengine/ ><title>CheatEngine基础 - 逆向工程 - 编程 - 计算机科学 | ReverseSacle-Blog</title><meta name=generator content="Hexo 6.3.0"></head><body itemscope itemtype=http://schema.org/WebPage><div id=loading><div class=dotloader><div class=dot></div><div class=dot></div><div class=dot></div><div class=dot></div><div class=dot></div></div></div><div id=container><header id=header itemscope itemtype=http://schema.org/WPHeader><div class=inner><div id=brand><div class=pjax><h1 itemprop="name headline">CheatEngine基础</h1><div class=meta><span class=item title="创建时间：2023-09-20 12:56:13"><span class=icon><i class="ic i-calendar"></i></span> <span class=text>发表于</span> <time itemprop="dateCreated datePublished" datetime=2023-09-20T12:56:13+08:00>2023-09-20</time></span><span class=item title=本文字数><span class=icon><i class="ic i-pen"></i></span> <span class=text>本文字数</span> <span>9.3k</span> <span class=text>字</span></span><span class=item title=阅读时长><span class=icon><i class="ic i-clock"></i></span> <span class=text>阅读时长</span> <span>11 分钟</span></span></div></div></div><nav id=nav><div class=inner><div class=toggle><div class=lines role=navigation aria-label=切换导航栏><span class=line></span><span class=line></span><span class=line></span></div></div><ul class=menu><li class="item title"><a href=/ rel=start>ReverseSacle-Blog</a></li></ul><ul class=right><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id=imgs class=pjax><ul><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg8.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg17.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg5.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg6.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg7.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg14.webp></li></ul></div></header><div id=waves><svg class=waves xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink viewBox="0 24 150 28" preserveAspectRatio=none shape-rendering=auto><defs><path id=gentle-wave d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352z"/></defs><g class=parallax><use xlink:href=#gentle-wave x=48 y=0 /><use xlink:href=#gentle-wave x=48 y=3 /><use xlink:href=#gentle-wave x=48 y=5 /><use xlink:href=#gentle-wave x=48 y=7 /></g></svg></div><main><div class=inner><div id=main class=pjax><div class="article wrap"><div class=breadcrumb itemscope itemtype=https://schema.org/BreadcrumbList><i class="ic i-home"></i> <span><a href=/ >首页</a></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/ itemprop=item rel=index title="分类于 计算机科学"><span itemprop=name>计算机科学</span></a><meta itemprop=position content=1></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/programming/ itemprop=item rel=index title="分类于 编程"><span itemprop=name>编程</span></a><meta itemprop=position content=2></span><i class="ic i-angle-right"></i> <span class=current itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/programming/reverse-engineering/ itemprop=item rel=index title="分类于 逆向工程"><span itemprop=name>逆向工程</span></a><meta itemprop=position content=3></span></div><article itemscope itemtype=http://schema.org/Article class="post block" lang=zh-CN><link itemprop=mainEntityOfPage href=https://www.reversesacle.com/computer-science/programming/reverse-engineering/cheatengine/ ><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content=/images/avatar.webp><meta itemprop=name content=ReverseSacle><meta itemprop=description content="所见即所得，所思即所行, 知识书库 & 学习点滴"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content=逆转天平></span><div class="body md" itemprop=articleBody><h2 id=概述><a class=anchor href=#概述>#</a> 概述</h2><p>CheatEngine(CE)是一个主要用于修改游戏和应用程序的<strong>开发环境</strong>。</p><p>CE是一个和修改器很接近的东西，但并不是能做到一步到位的修改器，而是一个开发环境，学习成本高，但功能非常强大。在CE中执行的各种修改，可以用CT(Cheat Table)的形式保存并可用于分享。</p><p><span class=exturl data-url="aHR0cHM6Ly93d3cuY2hlYXRlbmdpbmUub3JnLw==">CheatEngine下载官网</span></p><h2 id=计算机是如何运行游戏的><a class=anchor href=#计算机是如何运行游戏的>#</a> 计算机是如何运行游戏的</h2><p>计算机的核心部件CPU(中央处理器，可简单理解为整个计算机中的其他部件都是附加在CPU之上的)，其本质是逻辑电路(用电路的形式描述逻辑运算)。</p><p>逻辑运算可简单理解为一种简单的数学运算(数值只有真和假，简单记为1和0)，包含【与/或/非】三种运算。</p><p>CPU可以做到一些简单的事情，CPU想做的事情不能由其自身决定，需要人来决定，这种指示方式称为<strong>指令</strong>。可以将需要做的事情分解为一堆指令，并将这些指令提供给CPU，并且每一条指令不仅告诉CPU现在该做什么，也告诉它接下来该去执行哪一条指令，以此重复，CPU就可以自动地工作下去。更加准确的描述为，CPU的工作方式是一条一条地执行准备好的指令，根据指令对一些数据进行读或写。</p><p>CPU是只能做简单事情的逻辑电路，逻辑电路里面只有0和1这两个值，而指令和数据都是要直接送人CPU这个逻辑电路中进行运算的，所以，指令和数据也必须由0和1这两个值构成。也就是说，假如有一个数102，需要将这个数用一串0和1表示出来，或者是把【将A和B加起来然后存到C】这个指令用一串0和1表示出来，这个过程就称为<strong>编码</strong>。</p><p><strong>数据的编码</strong> - 即数据的二进制编码</p><p><strong>指令的编码</strong></p><p>例如指令：将A和B加起来然后存到C</p><p>其中<strong>加</strong>为操作，A/B/C为<strong>数据的来源</strong>和<strong>结果存储</strong>的位置，这两部分信息是相互独立的。</p><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>例如</pre></td></tr><tr><td data-num=2></td><td><pre>11 01 00 0110</pre></td></tr><tr><td data-num=3></td><td><pre>用后面的0110表示做什么操作，</pre></td></tr><tr><td data-num=4></td><td><pre>接着用前面固定数目的0和1表示第一个数据来源，第二个数据来源，结果存储的位置。</pre></td></tr></table></figure><p>数据编码和指令编码太过于相似，CPU是靠<strong>上下文信息</strong>来判断编码的含义。</p><p>指令是从内存中取出来的，数据也是从内存中取出来的，进行运算之后，结果也会存储在内存中。</p><h2 id=数据修改><a class=anchor href=#数据修改>#</a> 数据修改</h2><p>CE的使用思路，一共分为两步：找到在哪里修改，然后执行修改。</p><p>CE主界面的上半部分是<strong>内存扫描器</strong>，它的工作方式是根据输入指定的条件先圈定一些有可能是目标的内存位置，然后在后续扫描中，根据指定的条件不断排除错误选项，直到最终成功找到目标。</p><p>CE主界面的下半部分是<code>CheatTable(CT)</code>，不管要做什么修改，都首先要把一个内存位置添加到CT里面，在上半部分的内存扫描器里面双击就可以向CT添加一个条目，添加之后，添加记录的位置会显示内存位置的实时内容，可以通过双击<code>Value</code>位置打开修改值界面，这样的修改是一次性的，游戏本身会正常地改动游戏中对应的位置。还可以通过点击<code>Active</code>位置的框，以此切换到激活状态，这个内存位置的内容就被冻结了，只要发生变化，CE就会立即把它改回来。</p><h3 id=寻找数据位置模糊搜索><a class=anchor href=#寻找数据位置模糊搜索>#</a> 寻找数据位置(模糊搜索)</h3><p>基本原则 - 根据各内存单元内容的<strong>行为</strong>进行筛选。</p><p>筛选思路 - 直接给定筛选条件或先圈定初始目标范围，然后逐步缩小范围。</p><p><strong>操作方法</strong></p><ul><li><p>点击<code>New Scan</code> → 输入数值 → <code>First Scan</code> → <code>Next Scan</code> → <code>Next Scan</code> ...</p></li><li><p>每次扫描前都需指定条件，先在游戏中做些操作改变目标单元的行为，然后进行扫描。</p></li></ul><p><strong>实际操作流程</strong>，先点左边的按钮开始一组新的扫描，然后指定条件执行首次扫描，圈定初始范围，之后在游戏中进行一些行为操作让相关数值发生变化，然后通过指定新的条件来描述刚才这个目标数值的行为，并执行后续扫描，依次循环来不断缩小范围，最终锁定目标。</p><h3 id=内存布局和内存数据结构><a class=anchor href=#内存布局和内存数据结构>#</a> 内存布局和内存数据结构</h3><p>将内存看成一个连续的长条形状，高处表示高地址，低处表示低地址。</p><p>最下面的表示为<strong>存储指令的区域(text)</strong>。一般情况下，每次重新运行游戏，指令都会加载到内存的固定位置。</p><p>往上的两个区域(<code>initialized data</code>，<code>uninitialized data(bss)</code>)是<strong>全局变量段</strong>，保存的是数据，并且每次运行时这些数据的位置也是固定的，和指令一样。</p><p>在往上就是<strong>堆(heap)</strong>，堆里面的数据并不是完整，连续的，而是一大堆碎片，这些碎片化的数据都是在游戏运行过程中根据真实的需求现场分配的，用完之后会被回收，因此堆里面的数据并没有固定的位置，每次运行甚至同一次运行的不同时刻，都可能不同。</p><p>最上面的是栈(stack)，栈本身是连续存储的数据，但是栈的起始位置一般是随机的，这主要是出于安全考虑，这确实导致栈里面的数据在每次运行中的位置都不一样。</p><p><img data-src=https://jd.reversesacle.com/gh/ReverseSacle/Gallery@latest/programming/cheatengine/1.webp alt="" height="300px,width=&quot;200px&quot;"></p><p>数据保存在堆和栈里面就会乱序存储，游戏程序又是如何知道它在哪里呢？肯定有什么东西在指路，这个东西也是一个数据，而它的内容则是某个内存地址，这样游戏就可以看看它的内容是什么，然后去那个内存地址找到现在的血量，这种东西就被称为<strong>指针</strong>。</p><p>如果有些数据之间存在联系，但是联系比较松散，没有那么紧密，那么就可以用指针把两者连起来。而更加紧密关联的数据，比如说血条和蓝条，就可以存储在连续的位置，这就是内存中数据之间位置的两种组织方式。</p><p>所谓的<strong>内存数据结构</strong>，本质上其实就是把指针和连续存储着两种方式按一定方式结合起来。</p><p>实际游戏中，指针和连续存储可能用各种方式结合起来，一般来讲，这些中间和末端的连续存储位置，要么在堆里面，要么在栈里面，但是最源头的那个指针，有可能保存在全局变量里面，要是如此，那么这个源头指针的位置是固定的，其每次都能被找到，同时在每个连续存储段落中，各个数据之间的位置关系也是固定的，因此，可以通过从源头指针开始一路找到目标数据的路径。</p><h3 id=指针追溯><a class=anchor href=#指针追溯>#</a> 指针追溯</h3><p>指针数据类型(32位4字节，64位8字节)</p><h4 id=普通追溯操作><a class=anchor href=#普通追溯操作>#</a> 普通追溯操作</h4><p>先通过<strong>基本寻找数据位置</strong>的基本方法找到数据，找到后双击添加到CT表中，在表对应的位置右键，点击<code>Find out what writes to this address</code>(会打开一个小窗口)，之后通过游戏行为改变对应数值，点击<code>Replace</code>，输入相关指令后保存，点击下面的stop再点击close，接着在表对应的位置右键点击<code>Show as decimal</code>，之后即可通过修改<code>Value</code>位置的值来修改游戏中对应的数据了。</p><h4 id=一级指针追溯操作><a class=anchor href=#一级指针追溯操作>#</a> 一级指针追溯操作</h4><p>先通过<strong>基本寻找数据位置</strong>的基本方法找到数据，找到后双击添加到CT表中，在表对应的位置右键，点击<code>Find out what writes to this address</code>(会打开一个小窗口)，之后通过游戏行为改变对应数值，之后可在新打开的窗口中看到出现一些指令，包含了读数据的来源和结果的存储位置，如果某条指令的数据来源或结果位置与当前正在观察的这个地址一样，那么该指令就会被CE列在这个窗口里面。指令(即汇编代码)，双击其中一条指令，会打开一个小窗口，里面写着CE猜测的指针内容，标红<code>[]</code>里<code>+</code>后面的就是当前地址的<strong>偏移量</strong>，而<code>copy memory</code>下一行末尾就是猜测的<strong>源地址</strong>，将其复制，返回内存扫描器，点击<code>Value</code>位置的Hex打勾，将复制的指针地址输入到框中，再点击<code>New Scan</code>，通常源头地址一般会被标为<strong>绿色</strong>。</p><p><strong>方法一</strong></p><p>找到源头地址后，接着在表对应的位置的<code>Address</code>处双击，在新打开的窗口处点击Pointer，Pointer处的下面可左右调控的数值为该地址的偏移量，由于此处是一级指针，偏移量为之前看到的红色框里的偏移量，填入偏移量后点击OK确认，接着在表对应的位置右键点击<code>Show as decimal</code>，之后即可通过修改<code>Value</code>位置的值来修改游戏中对应的数据了。</p><p><strong>方法二</strong></p><p>找到源头地址后，双击添加到CT表中，接着复制其在CT表中对应位置的<code>Address</code>的值，再点击CT表右上角的<code>Add Address Manually</code>，在新打开的窗口处勾选Pointer框，在Pointer框下面最后一个可输入框中粘贴之前复制的地址，点击OK确认，之后即可通过修改<code>Value</code>位置的值来修改游戏中对应的数据了。</p><p><code>P-&gt;xxxx</code> - <code>p for pointer</code></p><h4 id=多级指针手动追溯操作><a class=anchor href=#多级指针手动追溯操作>#</a> 多级指针手动追溯操作</h4><p>以CE的Tutorial教程的第八关为例，</p><p>初始<code>Health</code>值为100，以该值进行<strong>基本寻找数据位置</strong>，找到唯一记录后，双击添加到CT表中，右键点击<code>Find out what accesses to this address</code>，返回Tutorial点击<code>Hit me</code>，之后返回之前新打开的指令窗口，双击其中一个，查看新打开窗口的<code>copy memory</code>下两行的(EAX，EBS....)，注意标红指令处<code>[]</code>里的，例如<code>[esi+18]</code>，其中的<code>e</code>si即偏移前的基码，<code>+18</code>为偏移量，注意比较<code>[]</code>的偏移基址在下面对应的十六进制，将其与CT表中之前记录的<code>Address</code>，值应该相近，接着复制<code>copy memory</code>下一行最后面的地址，将其复制到内存扫描器<code>Value</code>输入行中并勾选<code>Hex</code>，接着开始查找，以此往复。</p><p><img data-src=https://jd.reversesacle.com/gh/ReverseSacle/Gallery@latest/programming/cheatengine/2.webp alt=""></p><p><img data-src=https://jd.reversesacle.com/gh/ReverseSacle/Gallery@latest/programming/cheatengine/3.webp alt=""></p><p><img data-src=https://jd.reversesacle.com/gh/ReverseSacle/Gallery@latest/programming/cheatengine/4.webp alt=""></p><p>当遇到有多个地址可选时，需一个一个尝试，通过Tutorial点击<code>Hit me</code>，若有反应，则该地址追踪方向正确。</p><p><img data-src=https://jd.reversesacle.com/gh/ReverseSacle/Gallery@latest/programming/cheatengine/5.webp alt=""></p><p>直到内存扫描器找到<code>Address</code>标绿的地址</p><p><img data-src=https://jd.reversesacle.com/gh/ReverseSacle/Gallery@latest/programming/cheatengine/6.webp alt=""></p><p>双击绿色标记的地址至CT表中，在CT表中刚添加记录的Address处双击，反序添加之前追踪地址对应的偏移量(没有偏移量，即偏移量为0)</p><p><img data-src=https://jd.reversesacle.com/gh/ReverseSacle/Gallery@latest/programming/cheatengine/7.webp alt=""></p><p>之后点击OK后，再在该记录右键点击<code>Show as decimal</code>，将值改为5000，并点击记录<code>Active</code>框冻结该记录，再返回Tutorial点击<code>Change pointer</code>，即可通关。</p><h4 id=多级指针自动追溯操作><a class=anchor href=#多级指针自动追溯操作>#</a> 多级指针自动追溯操作</h4><p>以CE的Tutorial教程的第八关为例，</p><p>先按照<strong>寻找数据位置</strong>的查找方式找到记录，双击到CT表中后，在CT表中对应位置右键<code>Pointer scan for this address</code>，会弹出新的窗口点击OK并选择路径和填入文件名保存，之后返回Tutorail中点击<code>Change pointer</code>，再返回内存扫描器，按照<strong>寻找数据位置</strong>的查找方式找到记录，双击到CT表中后，再表中复制其地址，接着返回<code>Pointer scan</code>的窗口，点击顶栏<code>Pointer scanner</code>中的<code>Rescan memory</code>，将之前复制的地址输入到顶部的输入框中，点击OK，之后可看到只剩一条数据了，双击其可添加到CT表中(省去了查找和添加偏移量的操作)，之后再CT表中对应记录的<code>Value</code>处，修改数据为<code>5000</code>并点击<code>Active</code>框，返回Tutorail点击<code>Change pointer</code>即可通关。</p><h2 id=指令修改><a class=anchor href=#指令修改>#</a> 指令修改</h2><h3 id=x86指令集概述><a class=anchor href=#x86指令集概述>#</a> x86指令集概述</h3><p>每个指令最开始的部分表示做什么操作，长度为1到3个字节。</p><p>中间用逗号隔开的两部分表示为数据的来源和去向，结果的去向只有一个写在中间的开头，后面的是数据的来源，不同指令的数据来源数目可能不同。</p><p>CPU里面有一小部分区域用于做存储，该区域就是寄存器了。寄存器速度很快，数目很少。</p><p>x86指令集一共有16个寄存器。</p><p><code>[01350CB0]</code> - <code>[rax]</code> - <code>[rax+10]</code>，上述中括号就是访存，全称为<strong>访问内存</strong>，中括号里面的部分表示要访问的内存地址。</p><p>寄存器和中括号可以在任何位置使用，但一条指令最多有一处的访存。</p><p>CT表中条目的<code>Address</code>就是寄存器所存储的数值。</p><p><code>mov [rax],edx</code> - 把edx存储的值移动(mov)到rax所存储的内存地址上</p><h3 id=查找修改位置><a class=anchor href=#查找修改位置>#</a> 查找修改位置</h3><h4 id=基本操作><a class=anchor href=#基本操作>#</a> 基本操作</h4><p>在表对应的位置右键，点击<code>Find out what writes to this address</code>，通过游戏行为修改数值后，在之前新打开的窗口里选中一条指令并点击右边的<code>Show disassembler</code>(反汇编)来打开CE的内存视图，在内存视图中选中要执行修改的位置按下快捷键<code>Ctrl + A</code>(顶栏的Tools里的Auto Assemble)来打开脚本编写窗口，在窗口里面就是要手动添加修改指令脚本的地方了。这个脚本又是如何知道该修改哪里的指令呢？可以从<code>Auto Assemble</code>窗口的<code>Template</code>中选择<code>Full Injection</code>。</p><p>根据内存布局，指令的位置都是固定的，用这种方法进行指令定位，在每次重开游戏之后都能正常工作。</p><h4 id=aob技术><a class=anchor href=#aob技术>#</a> AOB技术</h4><p>倘若想制作的修改工具每次重开游戏都能使用，甚至还能在游戏更新后能继续使用。游戏版本更新后，一般都会改动一部分指令，其他指令的位置会受改动的指令的影响发生偏移，因此根据绝对位置直接定位的方法很可能失效，，这个时候就该使用AOB技术，全称Array of Bytes，即一串字节。</p><p>假如将移动前那一部分指令内容当做数据用内存扫描器来搜索【做法：将内存视图中对应指令<code>Bytes</code>处右键选<code>Copy to clipboard</code>后再选<code>Bytes only(no address)</code>，回到内存扫描器，点击<code>Writable</code>框为黑正方形(无要求)，<code>Value type</code>选<code>Array of byte</code>，勾选<code>Hex</code>框，将复制的值粘贴到输入框中开始搜索】。</p><p>先对扫描过程进行处理，x86指令前的1到3个字节是操作类型，后面的则是数据，版本更新时操作类型是固定的，而数据部分会发生变化，因此，执行AOB扫描时，只使用操作类型这部分作为依据，剩下的数据部分只要长度一样就行，具体内容如何都无所谓，只要在扫描条件里面，把不需要完全匹配的部分改成<code>x</code>即可(例如，<code>83xxxxxx48xxxxxE8xxxx8</code>)，这会时限制条件被放宽，扫描器可能会发现更多个匹配结果，因此需要不断调整AOB的写法，把附近更大范围的指令包含进去，直到扫描结果唯一即可。最后，就需要把这个手动执行扫码的过程移植到脚本里面，回到内存视图并重新打开一个<code>Auto Assemble</code>窗口，在<code>Template</code>中选择<code>AOB Injection</code>，小窗口确认后，再把刚才找到的那个能用的AOB复制到<code>aobscanmodule</code>的括号里即可(将十六进制表示的内容部分完全替换)。</p><h3 id=脚本编写><a class=anchor href=#脚本编写>#</a> 脚本编写</h3><p><code>Template</code>(模板)里面有两个带着中括号的ENABLE与DISABLE，这两个把模板划分成了两部分。</p><p>接着，可以在左上角<code>File</code>里选择<code>Assign to current cheat table</code>(把当前脚本加入到CT中)，之后CT表中会有一个新建的脚本CT条目，这个条目前面也有一个<code>Active</code>框，当勾选<code>Active</code>框表示进入激活状态，则脚本里面的ENABLE部分就会执行，不勾选<code>Active</code>框，则DISABLE部分就会执行，这表示真正的修改区域应该在<code>ENABLE</code>部分进行，而DISABLE部分是为了让指令保持原样，并且这部分由AOB模板自动编写。</p><p>CT表中的脚本CT条目，双击后可重新打开脚本窗口，当修改内容后需要点击下面的OK来关闭窗口，直接点右上角的<code>×</code>，则更改的内容不会同步到脚本CT条目中。</p><h4 id=标签与执行顺序><a class=anchor href=#标签与执行顺序>#</a> 标签与执行顺序</h4><p><strong>特殊标签</strong> - 先指定了地址，然后把写在它后面的这些汇编指令存放到之前指定的地址内存中</p><p><strong>普通标签</strong> - 地址是根据后面的指令的地址得到的</p><p><code>newmem</code>是CE主动将空闲空间进行分配而得到的空间。</p><p>自己指定名称的标签，实际上就是指向之前AOB扫描的结果位置，即指向要进行指令修改的地方。</p><p>如果在自己指定名称的标签后面随便写内容，就会把正常指令覆盖掉，这是非常危险的操作，因此，在没有特殊情况的条件下，就不需要碰<code>newmem</code>以外的内容了，只需要在<code>newmem</code>下写即可。</p><p><code>code</code>标签后面，就是CE把被替换成跳转的那些指令，用于修改的参考。</p><h2 id=实战思路><a class=anchor href=#实战思路>#</a> 实战思路</h2><h3 id=基本修改思路><a class=anchor href=#基本修改思路>#</a> 基本修改思路</h3><p>就实用性而言，现代的游戏基本只能用指令修改。需要先找到数据，根据数据找到与其关联的指令，最后再编写脚本。</p><h4 id=寻找数据><a class=anchor href=#寻找数据>#</a> 寻找数据</h4><p>过程分为两步直接寻找和间接寻找。</p><p><strong>直接寻找</strong> - 用内存扫描器进行扫描，寻找中需要使用各种设定条件</p><p><strong>指令间接寻找</strong></p><p>(<strong>条件</strong>)已知某个数据，寻找同类的其他数据。</p><p>(<strong>思考方向</strong>)同类的数据，行为应该是相似的，它们可能会受到同一组指令的控制。</p><p>(<strong>操作过程</strong>)通过指令修改的操作过程找到与已知数据关联的指令，右键选择<code>Find out what addresses this instruction accesses</code>(查看它访问的地址)，回到游戏中做一些操作，CE会检测出刚刚的操作中受到该指令影响的数据。</p><p><strong>所属对象间接寻找</strong></p><p>(<strong>条件</strong>)已知某个数据，寻找它所属对象的其他数据。</p><p>(<strong>思考方向</strong>)内存中的数据用连续存储和指针这两种方式组织在一起，如果是关联比较密切的数据，那就应该使用连续存储。如果查找某个已知数据所属对象的其他数据，就应该优先去找它附近的区域。</p><p>(<strong>操作过程</strong>)先找到一个数据，右键选择<code>Browsethis memory region</code>(查看该内存区域)，打开内存视图后，上半部分为反汇编器，下半部分与上半部分没什么关联。下半部分的右边一小块区域是把内存的内容直接当成字符进行解析的结果，下半部分的左边可以右键选择<code>Display Type</code>(可选择用什么数据类型来解读，默认直接显示十六进制内容)</p><p>两种间接寻找数据的方法可以找到不方便直接用扫描器寻找的数据，但是很多时候，个人觉得附近的数据很可能是相关的属性也看不懂它到底是什么意思，这需要依靠后面的获取辅助信息的技术了。</p><h4 id=查找关联指令><a class=anchor href=#查找关联指令>#</a> 查找关联指令</h4><h4 id=执行修改><a class=anchor href=#执行修改>#</a> 执行修改</h4><p>需确定指令的影响范围，避免产生副作用，然后寻找一些能用于消除副作用的辅助信息，获取这些信息后开始编写脚本。</p><p><strong>确定指令的影响范围</strong></p><p>跟指令间接寻找技术一样，以血量为例，当查看指令访问的地址时，找到主角的血量的同时要是敌人的血量也被查找到了，就需要消除这个副作用了，要是敌人的血量只影响主角的血量，编写脚本时会简单点。</p><h4 id=思路案例><a class=anchor href=#思路案例>#</a> 思路案例</h4><p>以CE的Tutorial教程的第九关为例，</p><p>小队作战，我方和对方各两个角色，所有角色共用一组伤害计算指令，需要在编写的脚本中区分两方角色，对我方角色锁血，将对方角色秒杀。</p><p>首先是如何区分两者，一般来说，游戏中的一个单位会有ID或者阵营标签，可以依靠这种数据来区分。还要依靠数据来辅助编写脚本。</p><p>接着是如何寻找有可能有助于区分的数据，CE提供了工具，可以很方便地对比多个不同来源的数据。选择查看指令访问的地址，然后做一些操作找到来自敌我双方的数据。选中一方，右键后选择<code>Find commonalities between addresses</code>中的<code>Mark selection as group 1</code>来标记为一组，接着把剩下的标记为另一组<code>Mark selection as group 2</code>，最后全选择右键选择<code>Find commonalities between addresses</code>中的<code>Scan for commonalities</code>(分析异同)【这里直接展示的是寄存器中的数据异同(所需的数据放在寄存器里面的情况是少数的)，可以选择那些标记出来可以做内存数据结构分析的寄存器来看一下内存里面的内容。CE默认给出的数据类型不一定是对的，如果自己有什么猜测，可以手动指定某部分的数据类型。】当发现可能是阵营标签的东西时，可以在脚本里面对内存这个位置的内容进行判断，然后分两种情况处理，具体写法是先执行cmp指令，然后执行跳转指令【je就是相等时跳转，jne是不相等时跳转，后面跟的东西是一个标签】，这里需要注册一个新的标签，用于处理不同的情况，编写脚本时要避免影响游戏的其他正常行为【cmp指令会对一部分特殊的寄存器产生影响】，在执行cmp之前写一个pushfq，执行完跳转之后写一个popfq，如果这两个指令在将脚本加入CT时报错，可以尝试改成pushfd和popfd，最后回到教程游戏中，选择重开战斗并自动操作，当取得胜利后即可通关。</p><h3 id=ce图形游戏><a class=anchor href=#ce图形游戏>#</a> CE图形游戏</h3><p>CE自带的三个关卡，这三关运用到的修改技术与真实的游戏比较接近。</p><p><strong>第一关</strong></p><p>可以按空格发射子弹攻击敌人，但是弹药量有限，每次换弹时敌人都会恢复到满血。修改路线应该是找到敌人的血量，然后找到影响血量的指令，最后将该指令替换为秒杀，这样就只需要一发子弹就可以通过，难点在于如何找到血量，敌人只有血条，没有具体的数字，也不显示伤害，因此首次扫描只能使用未知的初始值，然后在后续扫描中使用降低的数值，可以偶尔不攻击敌人，只是转动方向或空枪，然后扫描没有发生变化的数值，这样可以排除掉相当多的错误选项，最后还有一个技巧，可以在敌人血量恢复后，扫描未改变的数值，同时勾选上&quot;与首次扫描比较&quot;，有助于最终锁定目标。找到血量之后，只需找到与其关联的指令，然后找到能用的AOB，执行AOB注入。</p><p><strong>第二关</strong></p><p>难点主要在于敌我双方共用伤害计算指令，需要先找到敌我共三个对象的血量，根据之前的间接寻找数据的策略，应该从最容易找到的数据下手，主角的血量直接以数值的形式写出来，找到之后再通过指令中转，找到敌人的血量，接着寻找能区分敌我的辅助信息，假如看到的血量位于rax指向的位置，所以优先分析这里的数据。当找到后，开始编写脚本，给自己锁血然后秒杀敌人。</p><p><strong>第三关</strong></p><p>是一个平台跳跃游戏，需要把所有平台都点亮才能解锁右下角的出口，同时敌人都是一击秒杀的，里面也没有血量了。因此就先从坐标这种比较直观的数据入手，找到坐标之后再使用间接寻找方法。可以先找自己的坐标，坐标的数值并不知道(和第一关的隐藏血量差不多)，这里接着使用之前的&quot;与首次扫描相比无变化&quot;这个条件，但是横向移动的时候很难保证完美地回到出发点，因此应该选择扫描纵向的坐标，只要两次扫描都是站在地面上进行，就可以保证坐标一样，找到自己的纵坐标之后，就可以查看附近的内存，以此来找到横向坐标，不过与之关联的指令只会修改这一个位置，并不能查找到敌人的数据在哪里，但这个信息是有帮助的，当知道横向坐标是float类型并且向右走是变大，向左走是变小，可以重新用内存扫描器直接定位到敌人的横向坐标，找到横向坐标之后，可以找到关联的指令，进而找到全部三个敌人的信息，接下来尝试直接对指令进行修改，让敌人无法移动或者是通过坐标相关的指令找到负责碰撞检测的指令。</p><p>最简单的方案还是回到数据修改，直接锁定数值，为了保证下次进入游戏时修改方案依然能使用，这里要借助指令来定位数值，当找到修改敌人位置的指令后，就可以注册一些全局符号，每当这条指令执行的时候，都把敌人坐标的地址保存下来，这样当下次进入游戏时，只要启动这个脚本就可以自动获取到敌人的坐标。像这样找到的是横向坐标，更简单粗暴的方法是定位到纵向坐标，直接把敌人移出屏幕。</p><p>之后就可尝试做到只要激活一个平台就能打开出口，内存中存在一个位置保存了现在已经激活的平台数目，找到之后只需要进行简单的指令修改，让激活平台数目直接变成最大。</p><h2 id=使用经验><a class=anchor href=#使用经验>#</a> 使用经验</h2><h3 id=文本数据修改><a class=anchor href=#文本数据修改>#</a> 文本数据修改</h3><p>一个字节在十六进制中表示为两位。</p><p>将文本对应的每个字的十六进制列出并复制，在内存扫描器中，勾选Hex框，<code>Value Type</code>选<code>Array of byte</code>，找到唯一源地址后，将其<code>Value</code>的十六进制值修改为所希望修改的文本对应的十六进制。</p><h3 id=包裹空间中的数据修改><a class=anchor href=#包裹空间中的数据修改>#</a> 包裹空间中的数据修改</h3><p>当搜索到包裹空间中的两个位置的各唯一源地址后，可通过高地址减去低地址的方法的到相差量，此处假设包裹空间中左右相邻位置相差一个地址相差量，之后点击<code>Add Address Manually</code>(手动添加地址)，窗口打开后，在<code>Address</code>输入栏中添加【将上一个添加的CT表条目的地址加上相差量后的值】，之后通过修改该新添加的条目的值来测试假设是否正确。</p><div class=tags><a href=/tags/reverse-engineering/ rel=tag><i class="ic i-tag"></i> 逆向工程</a></div></div><footer><div class=meta><span class=item><span class=icon><i class="ic i-calendar-check"></i></span> <span class=text>更新于</span> <time title="修改时间：2025-01-09 17:58:14" itemprop=dateModified datetime=2025-01-09T17:58:14+08:00>2025-01-09</time></span><span class=item data-path=/computer-science/programming/reverse-engineering/cheatengine/ title=阅读次数><span class=icon><i class="ic i-eye"></i></span> <span class=text>阅读次数</span><span class=waline-pageview-count></span> <span class=text>次</span></span></div><div id=copyright><ul><li class=author><strong>本文作者：</strong> ReverseSacle <i class="ic i-at"><em>@</em></i>逆转天平</li><li class=link><strong>本文链接：</strong> <a href=https://www.reversesacle.com/computer-science/programming/reverse-engineering/cheatengine/ title=CheatEngine基础>https://www.reversesacle.com/computer-science/programming/reverse-engineering/cheatengine/</a></li><li class=license><strong>版权声明：</strong> 本站所有文章除特别声明外，均采用 <span class=exturl data-url=aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class=post-nav><div class="item left"><a href=/computer-science/programming/c-language/c-project/comment-system-mid/ itemprop=url rel=prev data-background-image=https:&#x2F;&#x2F;resa-imgs.oss-accelerate.aliyuncs.com&#x2F;img&#x2F;acg15.webp title=网站留言评论系统的设计与手动实现-中稿><span class=type>上一篇</span><span class=category><i class="ic i-flag"></i> C语言项目</span><h3>网站留言评论系统的设计与手动实现-中稿</h3></a></div><div class="item right"><a href=/computer-science/programming/web/nginx/ itemprop=url rel=next data-background-image=https:&#x2F;&#x2F;resa-imgs.oss-accelerate.aliyuncs.com&#x2F;img&#x2F;acg4.webp title=Nginx基础><span class=type>下一篇</span><span class=category><i class="ic i-flag"></i> web</span><h3>Nginx基础</h3></a></div></div><div class=wrap id=comments><div id=waline-comment></div></div></div><div id=sidebar><div class=inner><div class=panels><div class=inner><div class="contents panel pjax" data-title=文章目录><ol class=toc><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%A6%82%E8%BF%B0><span class=toc-number>1.</span> <span class=toc-text>概述</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E6%B8%B8%E6%88%8F%E7%9A%84><span class=toc-number>2.</span> <span class=toc-text>计算机是如何运行游戏的</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%95%B0%E6%8D%AE%E4%BF%AE%E6%94%B9><span class=toc-number>3.</span> <span class=toc-text>数据修改</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%AF%BB%E6%89%BE%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2><span class=toc-number>3.1.</span> <span class=toc-text>寻找数据位置(模糊搜索)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84><span class=toc-number>3.2.</span> <span class=toc-text>内存布局和内存数据结构</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%8C%87%E9%92%88%E8%BF%BD%E6%BA%AF><span class=toc-number>3.3.</span> <span class=toc-text>指针追溯</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E6%99%AE%E9%80%9A%E8%BF%BD%E6%BA%AF%E6%93%8D%E4%BD%9C><span class=toc-number>3.3.1.</span> <span class=toc-text>普通追溯操作</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E8%BF%BD%E6%BA%AF%E6%93%8D%E4%BD%9C><span class=toc-number>3.3.2.</span> <span class=toc-text>一级指针追溯操作</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88%E6%89%8B%E5%8A%A8%E8%BF%BD%E6%BA%AF%E6%93%8D%E4%BD%9C><span class=toc-number>3.3.3.</span> <span class=toc-text>多级指针手动追溯操作</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88%E8%87%AA%E5%8A%A8%E8%BF%BD%E6%BA%AF%E6%93%8D%E4%BD%9C><span class=toc-number>3.3.4.</span> <span class=toc-text>多级指针自动追溯操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%8C%87%E4%BB%A4%E4%BF%AE%E6%94%B9><span class=toc-number>4.</span> <span class=toc-text>指令修改</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#x86%E6%8C%87%E4%BB%A4%E9%9B%86%E6%A6%82%E8%BF%B0><span class=toc-number>4.1.</span> <span class=toc-text>x86指令集概述</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%9F%A5%E6%89%BE%E4%BF%AE%E6%94%B9%E4%BD%8D%E7%BD%AE><span class=toc-number>4.2.</span> <span class=toc-text>查找修改位置</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C><span class=toc-number>4.2.1.</span> <span class=toc-text>基本操作</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#aob%E6%8A%80%E6%9C%AF><span class=toc-number>4.2.2.</span> <span class=toc-text>AOB技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99><span class=toc-number>4.3.</span> <span class=toc-text>脚本编写</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E6%A0%87%E7%AD%BE%E4%B8%8E%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F><span class=toc-number>4.3.1.</span> <span class=toc-text>标签与执行顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%AE%9E%E6%88%98%E6%80%9D%E8%B7%AF><span class=toc-number>5.</span> <span class=toc-text>实战思路</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%9F%BA%E6%9C%AC%E4%BF%AE%E6%94%B9%E6%80%9D%E8%B7%AF><span class=toc-number>5.1.</span> <span class=toc-text>基本修改思路</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%AF%BB%E6%89%BE%E6%95%B0%E6%8D%AE><span class=toc-number>5.1.1.</span> <span class=toc-text>寻找数据</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E6%9F%A5%E6%89%BE%E5%85%B3%E8%81%94%E6%8C%87%E4%BB%A4><span class=toc-number>5.1.2.</span> <span class=toc-text>查找关联指令</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E6%89%A7%E8%A1%8C%E4%BF%AE%E6%94%B9><span class=toc-number>5.1.3.</span> <span class=toc-text>执行修改</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E6%80%9D%E8%B7%AF%E6%A1%88%E4%BE%8B><span class=toc-number>5.1.4.</span> <span class=toc-text>思路案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#ce%E5%9B%BE%E5%BD%A2%E6%B8%B8%E6%88%8F><span class=toc-number>5.2.</span> <span class=toc-text>CE图形游戏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C><span class=toc-number>6.</span> <span class=toc-text>使用经验</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E4%BF%AE%E6%94%B9><span class=toc-number>6.1.</span> <span class=toc-text>文本数据修改</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%8C%85%E8%A3%B9%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BF%AE%E6%94%B9><span class=toc-number>6.2.</span> <span class=toc-text>包裹空间中的数据修改</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title=系列文章><ul><li class=active><a href=/computer-science/programming/reverse-engineering/cheatengine/ rel=bookmark title=CheatEngine基础>CheatEngine基础</a></li><li><a href=/computer-science/programming/reverse-engineering/packet-sniffing/ rel=bookmark title="Fiddler Everywhere与Charles抓包">Fiddler Everywhere与Charles抓包</a></li></ul></div><div class="overview panel" data-title=站点概览><div class=author itemprop=author itemscope itemtype=http://schema.org/Person><img class=image itemprop=image alt=ReverseSacle data-src=/images/avatar.webp><p class=name itemprop=name>ReverseSacle</p><div class=description itemprop=description>知识书库 & 学习点滴</div></div><nav class=state><div class="item posts"><a href=/archives/ ><span class=count>186</span> <span class=name>文章</span></a></div><div class="item categories"><a href=/categories/ ><span class=count>52</span> <span class=name>分类</span></a></div><div class="item tags"><a href=/tags/ ><span class=count>18</span> <span class=name>标签</span></a></div></nav><div class=social><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JldmVyc2VTYWNsZQ==" title=https:&#x2F;&#x2F;github.com&#x2F;ReverseSacle><i class="ic i-github"></i></span><span class="exturl item email" data-url="bWFpbHRvOnByaXZhdGVAcmV2ZXJzZXNhY2xlLmNvbQ==" title=mailto:private@reversesacle.com><i class="ic i-envelope"></i></span></div><ul class=menu><li class=item><a href=/ rel=section><i class="ic i-home"></i> 首页</a></li><li class="item dropdown"><a href=javascript:void(0);><i class="ic i-feather"></i> 文章</a><ul class=submenu><li class=item><a href=/archives/ rel=section><i class="ic i-list-alt"></i> 归档</a></li><li class=item><a href=/categories/ rel=section><i class="ic i-th"></i> 分类</a></li><li class=item><a href=/tags/ rel=section><i class="ic i-tags"></i> 标签</a></li></ul></li><li class=item><a href=/about/ rel=section><i class="ic i-user"></i> 关于</a></li><li class=item><a href=/friend-links/ rel=section><i class="ic i-heart"></i> 友链</a></li></ul></div></div></div><ul id=quick><li class="prev pjax"><a href=/computer-science/programming/c-language/c-project/comment-system-mid/ rel=prev title=上一篇><i class="ic i-chevron-left"></i></a></li><li class=up><i class="ic i-arrow-up"></i></li><li class=down><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href=/computer-science/programming/web/nginx/ rel=next title=下一篇><i class="ic i-chevron-right"></i></a></li><li class=percent></li></ul></div></div><div class=dimmer></div></div></main><footer id=footer><div class=inner><div class=widgets><div class="rpost pjax"><h2>随机文章</h2><ul><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/c-algorithm/ title="分类于 C版算法">C版算法</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/nums/ title=数理>数理</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/backtracking/ title="分类于 回溯">回溯</a></div><span><a href=/computer-science/programming/c-language/c-algorithm/backtracking/combination/ title=回溯-组合>回溯-组合</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/network-programming/ title="分类于 网络编程">网络编程</a></div><span><a href=/computer-science/programming/network-programming/thread-synchronization/ title=Linux线程同步>Linux线程同步</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/network-programming/ title="分类于 网络编程">网络编程</a></div><span><a href=/computer-science/programming/network-programming/ubuntu-obs-server/ title="Ubuntu服务器OBS Studio配置">Ubuntu服务器OBS Studio配置</a></span></li><li class=item><div class=breadcrumb><a href=/categories/general-science-and-technology/ title="分类于 通用科学技术">通用科学技术</a><i class="ic i-angle-right"></i> <a href=/categories/general-science-and-technology/smartphone/ title="分类于 通用技术之手机端">通用技术之手机端</a></div><span><a href=/general-science-and-technology/smartphone/flash-for-mI9/ title=MI-9刷机实操案例>MI-9刷机实操案例</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/rust/ title="分类于 Rust">Rust</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/rust/rust-example/ title="分类于 Rust案例">Rust案例</a></div><span><a href=/computer-science/programming/rust/rust-example/web-application/ title=Rust在Linux(CentOS7)虚拟机中的Web基础运用>Rust在Linux(CentOS7)虚拟机中的Web基础运用</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/web/ title="分类于 web">web</a></div><span><a href=/computer-science/programming/web/json/ title=轻量级的数据交换格式JSON>轻量级的数据交换格式JSON</a></span></li><li class=item><div class=breadcrumb><a href=/categories/general-science-and-technology/ title="分类于 通用科学技术">通用科学技术</a><i class="ic i-angle-right"></i> <a href=/categories/general-science-and-technology/pc/ title="分类于 通用技术之PC端">通用技术之PC端</a><i class="ic i-angle-right"></i> <a href=/categories/general-science-and-technology/pc/router/ title="分类于 路由器">路由器</a></div><span><a href=/general-science-and-technology/pc/router/side-router-setting/ title=副路由的设置方法>副路由的设置方法</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/network-programming/ title="分类于 网络编程">网络编程</a></div><span><a href=/computer-science/programming/network-programming/log/ title=C&#x2F;C++服务程序的运行日志>C/C++服务程序的运行日志</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/network-programming/ title="分类于 网络编程">网络编程</a></div><span><a href=/computer-science/programming/network-programming/executable-program/ title=在C&#x2F;C++程序中调用可执行程序>在C/C++程序中调用可执行程序</a></span></li></ul></div><div><h2>最新评论</h2><ul id=waline-recent></ul></div></div><div class=status><div class=copyright>&copy; 2021 – <span itemprop=copyrightYear>2025</span><span class=with-love><i class="ic i-sakura rotate"></i></span> <span class=author itemprop=copyrightHolder>ReverseSacle @ ReverseSacle-Blog</span></div><div class=count><i class="ic i-clock" aria-hidden=true></i> <span id=time align=center>载入时间中...<script defer>var now=new Date;function createtime(){var n=new Date("2021-11-16 22:30:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("time").innerHTML="已经过 "+dnum+" 天 "+hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></span><span class=post-meta-item-icon>|&nbsp<i class="ic i-chart-area"></i></span> <span title=站点总字数>2.1m 字</span> <span class=post-meta-item-icon>|&nbsp<i class="ic i-coffee"></i></span> <span title=站点阅读时长>40:40</span></div></div></div></footer></div><script data-config>var LOCAL={path:"computer-science/programming/reverse-engineering/cheatengine/",favicon:{show:"ReverseSacle-Blog",hide:"ReverseSacle-Blog"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},waline:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src=https://polyfill.alicdn.com/v3/polyfill.min.js></script><script src=https://jd.reversesacle.com/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1.16.0/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js></script><script src=/js/app.js></script></body></html>