<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content=#222><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=icon type=image/ico sizes=48x48 href=/images/favicon.ico><link rel=alternate type=application/rss+xml title=逆转天平 href=https://www.reversesacle.com/rss.xml><link rel=alternate type=application/atom+xml title=逆转天平 href=https://www.reversesacle.com/atom.xml><link rel=alternate type=application/json title=逆转天平 href=https://www.reversesacle.com/feed.json><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel=stylesheet href=/css/app.css><meta name=description content=编程语言><link rel=canonical href=https://www.reversesacle.com/computer-science/programming/rust/rust-basic/rustpart2/ ><title>Rust语言-基础-第二部分 - Rust基础 - Rust - 编程 - 计算机科学 | ReverseSacle-Blog</title><meta name=generator content="Hexo 6.3.0"></head><body itemscope itemtype=http://schema.org/WebPage><div id=loading><div class=dotloader><div class=dot></div><div class=dot></div><div class=dot></div><div class=dot></div><div class=dot></div></div></div><div id=container><header id=header itemscope itemtype=http://schema.org/WPHeader><div class=inner><div id=brand><div class=pjax><h1 itemprop="name headline">Rust语言-基础-第二部分</h1><div class=meta><span class=item title="创建时间：2023-10-14 19:54:20"><span class=icon><i class="ic i-calendar"></i></span> <span class=text>发表于</span> <time itemprop="dateCreated datePublished" datetime=2023-10-14T19:54:20+08:00>2023-10-14</time></span><span class=item title=本文字数><span class=icon><i class="ic i-pen"></i></span> <span class=text>本文字数</span> <span>41k</span> <span class=text>字</span></span><span class=item title=阅读时长><span class=icon><i class="ic i-clock"></i></span> <span class=text>阅读时长</span> <span>47 分钟</span></span></div></div></div><nav id=nav><div class=inner><div class=toggle><div class=lines role=navigation aria-label=切换导航栏><span class=line></span><span class=line></span><span class=line></span></div></div><ul class=menu><li class="item title"><a href=/ rel=start>ReverseSacle-Blog</a></li></ul><ul class=right><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id=imgs class=pjax><ul><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg6.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg20.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg13.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg11.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg17.webp></li><li class=item data-background-image=https://resa-imgs.oss-accelerate.aliyuncs.com/img/acg16.webp></li></ul></div></header><div id=waves><svg class=waves xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink viewBox="0 24 150 28" preserveAspectRatio=none shape-rendering=auto><defs><path id=gentle-wave d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352z"/></defs><g class=parallax><use xlink:href=#gentle-wave x=48 y=0 /><use xlink:href=#gentle-wave x=48 y=3 /><use xlink:href=#gentle-wave x=48 y=5 /><use xlink:href=#gentle-wave x=48 y=7 /></g></svg></div><main><div class=inner><div id=main class=pjax><div class="article wrap"><div class=breadcrumb itemscope itemtype=https://schema.org/BreadcrumbList><i class="ic i-home"></i> <span><a href=/ >首页</a></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/ itemprop=item rel=index title="分类于 计算机科学"><span itemprop=name>计算机科学</span></a><meta itemprop=position content=1></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/programming/ itemprop=item rel=index title="分类于 编程"><span itemprop=name>编程</span></a><meta itemprop=position content=2></span><i class="ic i-angle-right"></i> <span itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/programming/rust/ itemprop=item rel=index title="分类于 Rust"><span itemprop=name>Rust</span></a><meta itemprop=position content=3></span><i class="ic i-angle-right"></i> <span class=current itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/categories/computer-science/programming/rust/rust-basic/ itemprop=item rel=index title="分类于 Rust基础"><span itemprop=name>Rust基础</span></a><meta itemprop=position content=4></span></div><article itemscope itemtype=http://schema.org/Article class="post block" lang=zh-CN><link itemprop=mainEntityOfPage href=https://www.reversesacle.com/computer-science/programming/rust/rust-basic/rustpart2/ ><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content=/images/avatar.webp><meta itemprop=name content=ReverseSacle><meta itemprop=description content="所见即所得，所思即所行, 知识书库 & 学习点滴"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content=逆转天平></span><div class="body md" itemprop=articleBody><h2 id=所有权转移><a class=anchor href=#所有权转移>#</a> 所有权转移</h2><h3 id=基本><a class=anchor href=#基本>#</a> 基本</h3><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment"> * 将5绑定到变量x；接着拷贝x的值赋给y，最终x和y都等于5，</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment"> * 因为整数是Rust基本数据类型，是固定大小的简单值，</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment"> * 因此这两个值都是通过自动拷贝的方式来赋值的，</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token comment"> * 都被存在栈中，完全无需在堆上分配内存。</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><p>这种栈上的数据足够简单，而且拷贝速度非常快，只需要复制一个整数大小(<code>i32</code>，4个字节)的内存即可。在这种情况下，拷贝的速度远比在堆上创建内存来得快的多。Rust的基本类型都是通过自动拷贝的方式来赋值的。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span></pre></td></tr></table></figure><p><code>String</code>不是基本类型，而且是存储在堆上的，因此不能自动拷贝。</p><p><code>String</code>类型由存储在栈中的堆指针**、<strong>字符串长度</strong>、<strong>字符串容量共同组成，其中</strong>堆指针**指向了真实存储字符串内容的堆内存，容量是堆内存分配空间的大小，长度是目前已经使用的大小。</p><p>假设一个String类型的值可以拥有两个所有者(s1和s2)，当其中一个变量离开作用域后，Rust会自动调用<code>drop</code>函数清理变量的堆内存。由于两个<code>String</code>变量指向了同一位置。当<code>s1</code>和<code>s2</code>离开作用域时，两者都会尝试释放相同的内存，这会导致**二次释放(double free)**错误。而实际上，Rust的处理机制为，当<code>s1</code>值被绑定到<code>s2</code>后，Rust认为<code>s1</code>不再有效了，也就无需在<code>s1</code>离开作用域后<code>drop</code>任何东西，这就是把<code>s1</code>的所有权转移给<code>s2</code>了，此时<code>s1</code>就马上失效了。</p><p>关于<strong>浅拷贝(shallow copy)<strong>和</strong>深拷贝(deep copy)</strong>，对于上面例子中的Rust处理机制，这个操作被称为<strong>移动(move)</strong>，而不是浅拷贝，过程可以解读为<code>s1</code>被<strong>移动</strong>到了<code>s2</code>中了。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token operator">=</span> <span class="token string">"hello, world"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;,&#123;&#125;"</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>执之前的<code>String</code>例子中<code>s1</code>持有通过<code>String::from(&quot;hello&quot;)</code>创建的值的所有权，而这个例子中，<code>x</code>只是引用了存储在二进制中的字符串<code>&quot;hello, world&quot;</code>，并没有持有所有权。因此<code>let y = x</code>中，仅仅是对该引用进行了简单的拷贝，此时<code>y</code>和<code>x</code>都引用了同一个字符串。</p><h3 id=克隆深拷贝><a class=anchor href=#克隆深拷贝>#</a> 克隆(深拷贝)</h3><p>Rust永远不会自动创建数据的深拷贝，任何自动复制都不是深拷贝。</p><p>可以使用<code>clone()</code>方法来深度复制堆上的数据，但使用<code>clone</code>会极大的降低程序性能，需要小心使用。当复制智能指针时时，会复制指针和堆上的数据。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"s1 = &#123;&#125;, s2 = &#123;&#125;"</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id=拷贝浅拷贝><a class=anchor href=#拷贝浅拷贝>#</a> 拷贝(浅拷贝)</h3><p>浅拷贝只发生在栈上，性能很高，在日常编程中基本都是使用浅拷贝。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"x = &#123;&#125;, y = &#123;&#125;"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>Rust基本类型在编译时是已知大小的，会被存储在栈上，所以拷贝值是快速的。</p><p>Rust中有一个<code>Copy</code>特征，可以用于存储在栈中的数据类型，如果一个类型拥有<code>Copy</code>特征，一个旧的变量值被绑定到其他变量后仍然可用。任何Rust基本类型的组合都可以<code>Copy</code> ，不需要分配内存或某种形式资源的类型也是可以<code>Copy</code>的。注意可变引用<code>&amp;mut T</code>是不可以Copy的。</p><h3 id=函数传参与值返回><a class=anchor href=#函数传参与值返回>#</a> 函数传参与值返回</h3><p>将值传递给函数，一样会发生<code>移动</code>或者<code>复制</code>。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// s 进入作用域</span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token function">takes_ownership</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// s 的值移动到函数里 ...</span></pre></td></tr><tr><td data-num=5></td><td><pre>                                    <span class="token comment">// ... 所以到这里不再有效</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>                      <span class="token comment">// x 进入作用域</span></pre></td></tr><tr><td data-num=8></td><td><pre></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token function">makes_copy</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// x 应该移动函数里，</span></pre></td></tr><tr><td data-num=10></td><td><pre>                                    <span class="token comment">// 但 i32 是 Copy 的，所以在后面可继续使用 x</span></pre></td></tr><tr><td data-num=11></td><td><pre></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span></pre></td></tr><tr><td data-num=13></td><td><pre>  <span class="token comment">// 所以不会有特殊操作</span></pre></td></tr><tr><td data-num=14></td><td><pre></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">takes_ownership</span><span class="token punctuation">(</span>some_string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// some_string 进入作用域</span></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> some_string<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放</span></pre></td></tr><tr><td data-num=18></td><td><pre></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">makes_copy</span><span class="token punctuation">(</span>some_integer<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// some_integer 进入作用域</span></pre></td></tr><tr><td data-num=20></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> some_integer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// 这里，some_integer 移出作用域。不会有特殊操作</span></pre></td></tr></table></figure><p>函数返回值也有所有权。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// gives_ownership 将返回值</span></pre></td></tr><tr><td data-num=3></td><td><pre>                                        <span class="token comment">// 移给 s1</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// s2 进入作用域</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">let</span> s3 <span class="token operator">=</span> <span class="token function">takes_and_gives_back</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// s2 被移动到</span></pre></td></tr><tr><td data-num=8></td><td><pre>                                        <span class="token comment">// takes_and_gives_back 中,</span></pre></td></tr><tr><td data-num=9></td><td><pre>                                        <span class="token comment">// 它也将返回值移给 s3</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span></pre></td></tr><tr><td data-num=11></td><td><pre>  <span class="token comment">// 所以什么也不会发生。s1 移出作用域并被丢弃</span></pre></td></tr><tr><td data-num=12></td><td><pre></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">&#123;</span>             <span class="token comment">// gives_ownership 将返回值移动给</span></pre></td></tr><tr><td data-num=14></td><td><pre>                                             <span class="token comment">// 调用它的函数</span></pre></td></tr><tr><td data-num=15></td><td><pre></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token keyword">let</span> some_string <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// some_string 进入作用域.</span></pre></td></tr><tr><td data-num=17></td><td><pre></pre></td></tr><tr><td data-num=18></td><td><pre>    some_string                              <span class="token comment">// 返回 some_string 并移出给调用的函数</span></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=20></td><td><pre></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token comment">// takes_and_gives_back 将传入字符串并返回该值</span></pre></td></tr><tr><td data-num=22></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">takes_and_gives_back</span><span class="token punctuation">(</span>a_string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">&#123;</span> <span class="token comment">// a_string 进入作用域</span></pre></td></tr><tr><td data-num=23></td><td><pre></pre></td></tr><tr><td data-num=24></td><td><pre>    a_string  <span class="token comment">// 返回 a_string 并移出给调用的函数</span></pre></td></tr><tr><td data-num=25></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id=相关方法><a class=anchor href=#相关方法>#</a> 相关方法</h3><p><code>as_ref()</code>方法</p><p>是一个用于类型转换的方法，通常用于将一个类型转换为其引用类型。这个方法通常用于在处理不同类型的数据时，允许你在不拷贝数据的情况下引用数据，从而提高性能并减少内存消耗。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 字符串 (String 到 str) 的转换</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">let</span> string <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">let</span> string_ref<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">as_ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment">// 向量 (Vec) 到切片 (&amp;[T]) 的转换</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">let</span> vector <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token keyword">let</span> slice<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token keyword">i32</span><span class="token punctuation">]</span> <span class="token operator">=</span> vector<span class="token punctuation">.</span><span class="token function">as_ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token comment">// Option类型中将Option&lt;T>转换为Option&lt;&amp;T>，允许引用Option中的值而不需要解包它</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token comment">// 不会移动所有权</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token keyword">let</span> maybe_value<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token keyword">let</span> maybe_ref<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">i32</span><span class="token operator">></span> <span class="token operator">=</span> maybe_value<span class="token punctuation">.</span><span class="token function">as_ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><code>as_mut()</code>方法</p><p>是一个用于类型转换的方法，通常用于将一个类型转换为其可变引用类型。这个方法通常用于在处理不同类型的数据时，允许在不拷贝数据的情况下获得对数据的可变引用，以便修改数据。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 字符串 (String 到 &amp;mut str) 的转换</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">let</span> <span class="token keyword">mut</span> string <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">let</span> string_mut_ref<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">str</span> <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">as_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment">// 向量 (Vec) 到可变切片 (&amp;mut [T]) 的转换</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">let</span> <span class="token keyword">mut</span> vector <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token keyword">let</span> slice<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token punctuation">[</span><span class="token keyword">i32</span><span class="token punctuation">]</span> <span class="token operator">=</span> vector<span class="token punctuation">.</span><span class="token function">as_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token comment">// 将Option&lt;T>转换为Option&lt;&amp;mut T>，允许获得对Option中值的可变引用而不需要解包它</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token comment">// 不会移动所有权</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token keyword">let</span> <span class="token keyword">mut</span> maybe_value<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>value_ref<span class="token punctuation">)</span> <span class="token operator">=</span> maybe_value<span class="token punctuation">.</span><span class="token function">as_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token operator">*</span>value_ref <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 修改值</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id=集合类型><a class=anchor href=#集合类型>#</a> 集合类型</h2><p>String类型也是集合类型。</p><h3 id=动态数组vector><a class=anchor href=#动态数组vector>#</a> 动态数组(Vector)</h3><p>动态数组类型用<code>Vec&lt;T&gt;</code>表示，允许存储多个值，这些值在内存中是一个紧挨着另一个排列的。动态数组只能存储相同类型的元素，如果想存储不同类型的元素，可以使用枚举类型或者特征对象。</p><h4 id=vector的创建><a class=anchor href=#vector的创建>#</a> Vector的创建</h4><p>使用<code>Vec::new</code>创建动态数组。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">/** </span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token comment"> * v被显式地声明了类型Vec&lt;i32>，</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token comment"> * 这是因为Rust编译器无法从Vec::new()中得到任何关于类型的暗示信息，</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment"> * 因此也无法推导出v的具体类型。</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment">**/</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">let</span> v<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token comment">// 自动类型推导</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token keyword">let</span> <span class="token keyword">mut</span> v1 <span class="token operator">=</span> <span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>v1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><font size=3><ins><strong>vec![]</strong></ins></font></p><p>使用<code>vec!</code>宏来创建数组，能在创建同时给予初始化值。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token comment"> * 此处的v也无需标注类型，</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment"> * 编译器只需检查它内部的元素即可自动推导出v的类型是Vec&lt;i32></span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><h4 id=vector相关操作><a class=anchor href=#vector相关操作>#</a> Vector相关操作</h4><p><font size=3><ins><strong>添加元素</strong></ins></font></p><p>使用<code>push</code>方法向数组尾部添加元素。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">let</span> <span class="token keyword">mut</span> v <span class="token operator">=</span> <span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre>v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token comment">// 与其它类型一样，必须将v声明为mut后，才能进行修改。</span></pre></td></tr></table></figure><p><font size=3><ins><strong>获取元素</strong></ins></font></p><p>读取指定位置的元素有两种方式</p><ul><li>通过下标索引访问</li><li>使用<code>get()</code>方法</li></ul><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">let</span> third<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">i32</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"第三个元素是 &#123;&#125;"</span><span class="token punctuation">,</span> third<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">match</span> v<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token class-name">Some</span><span class="token punctuation">(</span>third<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"第三个元素是 &#123;third&#125;"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token class-name">None</span> <span class="token operator">=></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"去你的第三个元素，根本没有！"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>使用下标索引访问的方式时，当发生数组越界访问时会导致程序报错并退出。但是<code>get()</code>方法不同，有值的时候返回<code>Some(T)</code>，无值的时候返回<code>None</code>。</p><p><font size=3><ins><strong>遍历元素</strong></ins></font></p><p>倘若使用下标的方式去遍历的话，每次下标访问都会触发数组边界检查。而使用迭代的方法去遍历的话，更安全也更高效。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token operator">&amp;</span>v <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;i&#125;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment">// 遍历过程中修改值</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token keyword">let</span> <span class="token keyword">mut</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> v <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token operator">*</span>i <span class="token operator">+=</span> <span class="token number">10</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><font size=3><ins><strong>元素排序</strong></ins></font></p><p>在Rust中，实现了两种排序算法</p><ul><li>稳定的排序 - <code>sort</code>和<code>sort_by</code></li><li>非稳定排序 - <code>sort_unstable</code>和<code>sort_unstable_by</code></li></ul><p><code>非稳定</code>并不是指排序算法本身不稳定，而是指在排序过程中对相等元素的处理方式。在<code>稳定</code>排序算法中，相等的元素不会对其进行重新排序，而在<code>不稳定</code>的算法里则不保证这点。</p><p><code>非稳定</code>排序的算法的速度会优于<code>稳定</code>排序算法。<code>稳定</code>排序还会额外分配原数组一半的空间。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 整数数组的排序</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">let</span> <span class="token keyword">mut</span> vec <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num=4></td><td><pre>    vec<span class="token punctuation">.</span><span class="token function">sort_unstable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>vec<span class="token punctuation">,</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=7></td><td><pre></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token comment">// 浮点数数组的排序</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">let</span> <span class="token keyword">mut</span> vec <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">5.6</span><span class="token punctuation">,</span> <span class="token number">10.3</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">15f32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num=11></td><td><pre>    vec<span class="token punctuation">.</span><span class="token function">sort_unstable_by</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>a<span class="token punctuation">,</span> b<span class="token closure-punctuation punctuation">|</span></span> a<span class="token punctuation">.</span><span class="token function">partial_cmp</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>vec<span class="token punctuation">,</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">5.6</span><span class="token punctuation">,</span> <span class="token number">10.3</span><span class="token punctuation">,</span> <span class="token number">15f32</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token comment"> * 在浮点数当中，存在一个NaN的值，这个值无法与其他的浮点数进行对比，</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token comment"> * 因此，浮点数类型并没有实现全数值可比较Ord的特性，</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token comment"> * 而是实现了部分可比较的特性PartialOrd。</span></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token comment"> * 如果确定在浮点数数组当中，不包含NaN值，</span></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token comment"> * 那么可以使用partial_cmp来作为大小判断的依据。</span></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token comment">**/</span></pre></td></tr><tr><td data-num=21></td><td><pre></pre></td></tr><tr><td data-num=22></td><td><pre><span class="token comment">// 对结构体数组进行排序</span></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token attribute attr-name">#[derive(Debug)]</span></pre></td></tr><tr><td data-num=24></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">Person</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=25></td><td><pre>    name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=26></td><td><pre>    age<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=27></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=28></td><td><pre></pre></td></tr><tr><td data-num=29></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=30></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=31></td><td><pre>        <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span> name<span class="token punctuation">,</span> age <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=32></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=33></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=34></td><td><pre></pre></td></tr><tr><td data-num=35></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=36></td><td><pre>    <span class="token keyword">let</span> <span class="token keyword">mut</span> people <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span></pre></td></tr><tr><td data-num=37></td><td><pre>        <span class="token class-name">Person</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Zoe"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=38></td><td><pre>        <span class="token class-name">Person</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Al"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=39></td><td><pre>        <span class="token class-name">Person</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=40></td><td><pre>    <span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=41></td><td><pre>    <span class="token comment">// 定义一个按照年龄倒序排序的对比函数</span></pre></td></tr><tr><td data-num=42></td><td><pre>    people<span class="token punctuation">.</span><span class="token function">sort_unstable_by</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>a<span class="token punctuation">,</span> b<span class="token closure-punctuation punctuation">|</span></span> b<span class="token punctuation">.</span>age<span class="token punctuation">.</span><span class="token function">cmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=43></td><td><pre></pre></td></tr><tr><td data-num=44></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;:?&#125;"</span><span class="token punctuation">,</span> people<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=45></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>排序需要实现 <code>Ord</code> 特性，排序需要实现<code>Ord</code>、<code>Eq</code>、<code>PartialEq</code>、<code>PartialOrd</code>这些属性，可以<code>#[derive()]</code>这些属性。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token attribute attr-name">#[derive(Debug, Ord, Eq, PartialEq, PartialOrd)]</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">Person</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=4></td><td><pre>    age<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=9></td><td><pre>        <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span> name<span class="token punctuation">,</span> age <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=12></td><td><pre></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token keyword">let</span> <span class="token keyword">mut</span> people <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span></pre></td></tr><tr><td data-num=15></td><td><pre>        <span class="token class-name">Person</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Zoe"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=16></td><td><pre>        <span class="token class-name">Person</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Al"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=17></td><td><pre>        <span class="token class-name">Person</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Al"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=18></td><td><pre>        <span class="token class-name">Person</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=19></td><td><pre>        <span class="token class-name">Person</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=20></td><td><pre>    <span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=21></td><td><pre></pre></td></tr><tr><td data-num=22></td><td><pre>    people<span class="token punctuation">.</span><span class="token function">sort_unstable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=23></td><td><pre></pre></td></tr><tr><td data-num=24></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;:?&#125;"</span><span class="token punctuation">,</span> people<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=25></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>需要derive<code>Ord</code>相关特性，需要确保结构体中所有的属性均实现了<code>Ord</code>相关特性，否则会发生编译错误。<code>derive</code>的默认实现会依据属性的顺序依次进行比较，例如上述例子中，当<code>Person</code>的<code>name</code>值相同时，则会使用<code>age</code>进行比较。</p><h3 id=无序键值对存储hashmap><a class=anchor href=#无序键值对存储hashmap>#</a> 无序键值对存储(HashMap)</h3><p><code>HashMap</code>中存储的是 - 映射的<code>KV</code>键值对，并提供了平均复杂度为<code>O(1)</code>的查询方法。</p><p>Rust中哈希类型(哈希映射)为<code>HashMap&lt;K,V&gt;</code>。</p><h4 id=hashmap的创建><a class=anchor href=#hashmap的创建>#</a> HashMap的创建</h4><p>使用<code>HashMap</code>需要手动通过<code>use std::collections::HashMap;</code>从标准库中引入到当前的作用域中。</p><p><font size=3><ins><strong>使用new方法创建</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token class-name">HashMap</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token comment">// 创建一个HashMap，用于存储宝石种类和对应的数量</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">let</span> <span class="token keyword">mut</span> my_gems <span class="token operator">=</span> <span class="token class-name">HashMap</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment">// 将宝石类型和对应的数量写入表中</span></pre></td></tr><tr><td data-num=7></td><td><pre>my_gems<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"红宝石"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>my_gems<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"蓝宝石"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>my_gems<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"河边捡的误以为是宝石的破石头"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token comment">// my_gems的类型 - HashMap&lt;&amp;str,i32></span></pre></td></tr></table></figure><p><font size=3><ins><strong>使用迭代器和collect方法创建</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 使用迭代器的方法，通过collect进行收集</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token class-name">HashMap</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">let</span> teams_list <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span></pre></td></tr><tr><td data-num=6></td><td><pre>        <span class="token punctuation">(</span><span class="token string">"中国队"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=7></td><td><pre>        <span class="token punctuation">(</span><span class="token string">"美国队"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=8></td><td><pre>        <span class="token punctuation">(</span><span class="token string">"日本队"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token keyword">let</span> teams_map<span class="token punctuation">:</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>_<span class="token punctuation">,</span>_<span class="token operator">></span> <span class="token operator">=</span> teams_list<span class="token punctuation">.</span><span class="token function">into_iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    </pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;:?&#125;"</span><span class="token punctuation">,</span>teams_map<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>collect</code>方法在内部支持生成多种类型的目标集合，需要通过类型标注<code>HashMap&lt;_,_&gt;</code>来告诉编译器，以此收集的为<code>HashMap</code>集合类型，具体的<code>KV</code>类型由编译器推导。</p><h4 id=hashmap相关操作><a class=anchor href=#hashmap相关操作>#</a> HashMap相关操作</h4><p><font size=3><ins><strong>检查元素是否存在</strong></ins></font></p><p>使用<code>contains_key()</code>方法，返回一个布尔值。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token class-name">HashMap</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">let</span> <span class="token keyword">mut</span> my_map <span class="token operator">=</span> <span class="token class-name">HashMap</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre>    my_map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    my_map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"banana"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    my_map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"cherry"</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token comment">// 检查是否包含键 "banana"</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token keyword">if</span> my_map<span class="token punctuation">.</span><span class="token function">contains_key</span><span class="token punctuation">(</span><span class="token string">"banana"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=12></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The key 'banana' exists in the map."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=14></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The key 'banana' does not exist in the map."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><font size=3><ins><strong>添加或覆盖元素</strong></ins></font></p><p>使用<code>insert()</code>方法或<code>entry(key).or_insert(val)</code>方法。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token class-name">HashMap</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">let</span> <span class="token keyword">mut</span> scores <span class="token operator">=</span> <span class="token class-name">HashMap</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre>    scores<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"Blue"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token comment">// 覆盖已有的值</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token keyword">let</span> old <span class="token operator">=</span> scores<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"Blue"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token comment">// 查询Yellow对应的值，若不存在则插入新值</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token keyword">let</span> v <span class="token operator">=</span> scores<span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span><span class="token string">"Yellow"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">or_insert</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token operator">*</span>v<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><font size=3><ins><strong>获取元素</strong></ins></font></p><p>通过<code>get()</code>方法获取元素，返回一个<code>Option&lt;&amp;i32&gt;</code>类型，当查询不到时会返回一个<code>None</code>，查询到时返回<code>Some(&amp;i32)</code>。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token class-name">HashMap</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">let</span> <span class="token keyword">mut</span> scores <span class="token operator">=</span> <span class="token class-name">HashMap</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre>scores<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Blue"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>scores<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Yellow"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token keyword">let</span> team_name <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Blue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token keyword">let</span> score<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">i32</span><span class="token operator">></span> <span class="token operator">=</span> scores<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>team_name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><code>&amp;i32</code>是对<code>HashMap</code>中值的借用，如果不使用借用，可能会发生所有权的转移。</p><p><font size=3><ins><strong>更新元素</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token class-name">HashMap</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">let</span> text <span class="token operator">=</span> <span class="token string">"hello world wonderful world"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">let</span> <span class="token keyword">mut</span> map <span class="token operator">=</span> <span class="token class-name">HashMap</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment">// 根据空格来切分字符串(英文单词都是通过空格切分)</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token keyword">for</span> word <span class="token keyword">in</span> text<span class="token punctuation">.</span><span class="token function">split_whitespace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">let</span> count <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">or_insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token operator">*</span>count <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=11></td><td><pre></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;:?&#125;"</span><span class="token punctuation">,</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><code>or_insert</code>返回了<code>&amp;mut v</code>引用，因此可以通过该可变引用直接修改<code>map</code>中对应的值。</p><p>使用<code>count</code>引用时，需要先进行解引用<code>*count</code>，否则会出现类型不匹配。</p><p><font size=3><ins><strong>删除元素</strong></ins></font></p><p>使用<code>remove()</code>方法来删除特定键值对。</p><p>使用<code>clear()</code>方法清空HashMap。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre>my_map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre>my_map<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><font size=3><ins><strong>遍历元素</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token operator">&amp;</span>my_map <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Key: &#123;&#125;, Value: &#123;&#125;"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id=无序集合hashset><a class=anchor href=#无序集合hashset>#</a> 无序集合(HashSet)</h3><h4 id=hashset的创建><a class=anchor href=#hashset的创建>#</a> HashSet的创建</h4><p>使用<code>HashSet</code>需要手动通过<code>use std::collections::HashSet;</code>从标准库中引入到当前的作用域中。</p><p><font size=3><ins><strong>使用new方法创建</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token class-name">HashSet</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">let</span> <span class="token keyword">mut</span> books <span class="token operator">=</span> <span class="token class-name">HashSet</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre>books<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"A Dance With Dragons"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>books<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"To Kill a Mockingbird"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>books<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"The Odyssey"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>books<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"The Great Gatsby"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token comment">// books的类型 - HashSet&lt;String></span></pre></td></tr></table></figure><p><font size=3><ins><strong>使用迭代器和collect方法创建</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token class-name">HashSet</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">let</span> elements <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 包含重复元素的向量</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">let</span> unique_elements<span class="token punctuation">:</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>_<span class="token operator">></span> <span class="token operator">=</span> elements<span class="token punctuation">.</span><span class="token function">into_iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;:?&#125;"</span><span class="token punctuation">,</span>teams_map<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id=hashset相关操作><a class=anchor href=#hashset相关操作>#</a> HashSet相关操作</h4><p><font size=3><ins><strong>检查元素是否存在</strong></ins></font></p><p>返回布尔值。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">if</span> my_set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"banana"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Set contains 'banana'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><font size=3><ins><strong>添加元素</strong></ins></font></p><p>重复的元素将被忽略。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre>my_set<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre>my_set<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"banana"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><font size=3><ins><strong>删除元素</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre>my_set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 清除单个元素</span></pre></td></tr><tr><td data-num=2></td><td><pre>my_set<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 清空HashSet</span></pre></td></tr></table></figure><p><font size=3><ins><strong>遍历元素</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">for</span> item <span class="token keyword">in</span> <span class="token operator">&amp;</span>my_set <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id=有序键值对存储btreemap><a class=anchor href=#有序键值对存储btreemap>#</a> 有序键值对存储(BTreeMap)</h3><h4 id=btreemap的创建><a class=anchor href=#btreemap的创建>#</a> BTreeMap的创建</h4><p>使用<code>BTreeMap</code>需要手动通过<code>use std::collections::BTreeMap;</code>从标准库中引入到当前的作用域中。</p><p><font size=3><ins><strong>使用new方法创建</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token class-name">BTreeMap</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">let</span> <span class="token keyword">mut</span> btree_map <span class="token operator">=</span> <span class="token class-name">BTreeMap</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><font size=3><ins><strong>使用迭代器和collect方法创建</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token class-name">BTreeMap</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token comment">// 创建一个包含键-值元组的迭代器</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"One"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"Three"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"Two"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"Four"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">let</span> btree_map<span class="token punctuation">:</span> <span class="token class-name">BTreeMap</span><span class="token operator">&lt;</span>_<span class="token punctuation">,</span> _<span class="token operator">></span> <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">into_iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;:?&#125;"</span><span class="token punctuation">,</span>teams_map<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id=btreemap相关操作><a class=anchor href=#btreemap相关操作>#</a> BTreeMap相关操作</h4><p><font size=3><ins><strong>检查元素是否存在</strong></ins></font></p><p>返回一个布尔值。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token class-name">BTreeMap</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">let</span> <span class="token keyword">mut</span> btree_map <span class="token operator">=</span> <span class="token class-name">BTreeMap</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre>    btree_map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"One"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    btree_map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"Two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    btree_map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"Three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">let</span> key_to_check <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token comment">// 使用contains_key方法检查键是否存在</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token keyword">if</span> btree_map<span class="token punctuation">.</span><span class="token function">contains_key</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>key_to_check<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=14></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Key &#123;&#125; exists in the BTreeMap."</span><span class="token punctuation">,</span> key_to_check<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=16></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Key &#123;&#125; does not exist in the BTreeMap."</span><span class="token punctuation">,</span> key_to_check<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><font size=3><ins><strong>添加元素</strong></ins></font></p><p>元素需实现<code>Ord</code>特征。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre>btree_map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre>btree_map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"banana"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre>btree_map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"cherry"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><font size=3><ins><strong>获取元素</strong></ins></font></p><p>通过<code>get()</code>方法获取元素，返回一个Option枚举类型。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token operator">=</span> btree_map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"banana"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Number of bananas: &#123;&#125;"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Bananas not found."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><font size=3><ins><strong>删除元素</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre>btree_map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"cherry"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 删除单个元素</span></pre></td></tr><tr><td data-num=2></td><td><pre>btree_map<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 清空BTreeMap</span></pre></td></tr></table></figure><p><font size=3><ins><strong>遍历元素</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token operator">&amp;</span>btree_map <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Key: &#123;&#125;, Value: &#123;&#125;"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id=有序集合btreeset><a class=anchor href=#有序集合btreeset>#</a> 有序集合(BTreeSet)</h3><h4 id=btreeset的创建><a class=anchor href=#btreeset的创建>#</a> BTreeSet的创建</h4><p>使用<code>BTreeSet</code>需要手动通过<code>use std::collections::BTreeSet;</code>从标准库中引入到当前的作用域中。</p><p><font size=3><ins><strong>使用new方法创建</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token class-name">BTreeSet</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">let</span> <span class="token keyword">mut</span> btree_set <span class="token operator">=</span> <span class="token class-name">BTreeSet</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><font size=3><ins><strong>使用迭代器和collect方法创建</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token class-name">BTreeSet</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">let</span> values <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 一个包含重复元素的示例</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token comment">// 使用迭代器和collect方法创建BTreeSet</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">let</span> btree_set<span class="token punctuation">:</span> <span class="token class-name">BTreeSet</span><span class="token operator">&lt;</span>_<span class="token operator">></span> <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">into_iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;:?&#125;"</span><span class="token punctuation">,</span>teams_map<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id=btreeset相关操作><a class=anchor href=#btreeset相关操作>#</a> BTreeSet相关操作</h4><p><font size=3><ins><strong>检查元素是否存在</strong></ins></font></p><p>返回布尔值。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">if</span> btree_set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The set contains the value 5."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The set does not contain the value 5."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><font size=3><ins><strong>添加元素</strong></ins></font></p><p>元素需实现<code>Ord</code>特征。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre>btree_set<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre>btree_set<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre>btree_set<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><font size=3><ins><strong>删除元素</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre>btree_set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 删除单个元素</span></pre></td></tr><tr><td data-num=2></td><td><pre>btree_set<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 清空BTreeSet</span></pre></td></tr></table></figure><p><font size=3><ins><strong>遍历元素</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">for</span> value <span class="token keyword">in</span> <span class="token operator">&amp;</span>btree_set <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Value: &#123;&#125;"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id=内存操作与管理><a class=anchor href=#内存操作与管理>#</a> 内存操作与管理</h2><h3 id=rust与堆栈><a class=anchor href=#rust与堆栈>#</a> Rust与堆栈</h3><p><strong>栈</strong>上的内存是从高位地址向低地址增长的，且栈内存是连续分配的。一般而言栈内存的大小在操作系统中是被限制的，所以 C语言中就无法创建任意长度的数组。在Rust中，<code>main</code>线程的栈大小是<code>8MB</code>，普通线程大小是<code>2MB</code>，在函数调用时会创建一个临时栈空间，调用结束后Rust会让这个栈空间里的对象自动进入<code>Drop</code>流程，最后栈顶指针自动移动到上一个调用栈顶，此过程无需手动干预，因此栈内存的申请和释放是非常高效的。</p><p><strong>堆</strong>上的内存则是从低位地址向高地址增长的，堆内存通常只受物理内存限制，通常是不连续的，因此在性能上，栈往往比堆更高。Rust堆上的对象都拥有一个所有者并受限于所有权规则，当赋值时，发生的是所有权的转移(只需浅拷贝栈上的引用或智能指针即可)。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">"Hello, "</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    a</pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token comment"> * 在foo函数中，a是String类型，它其实是一个智能指针结构体，</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token comment"> * 该智能指针存储在函数栈中，指向堆上的字符串数据。</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token comment"> * 当被从foo函数转移给main中的b变量时，</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token comment"> * 栈上的智能指针被复制一份赋予给b，而底层数据无需发生改变，</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token comment"> * 这样就完成了所有权从foo函数内部到b的转移。</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><p><strong>堆栈的性能</strong></p><ul><li>小型数据 → 在栈上的分配性能和读取性能都要比堆上高</li><li>中型数据 → 栈上分配性能高，但是读取性能和堆上并无区别，因为无法利用寄存器或CPU高速缓存，最终还是要经过一次内存寻址</li><li>大型数据 → 只建议在堆上分配和使用</li></ul><h3 id=定长类型与不定长类型><a class=anchor href=#定长类型与不定长类型>#</a> 定长类型与不定长类型</h3><p>从编译器何时能获知类型大小的角度出发，可以分成两类</p><ul><li>定长类型(sized) - 类型的大小在编译时是已知的</li><li>不定长类型(unsized) - 类型的大小只有程序运行时才能动态获知，这种类型又被称之为DST</li></ul><h4 id=动态大小类型dst><a class=anchor href=#动态大小类型dst>#</a> 动态大小类型DST</h4><p>Rust的基本类型，以及集合<code>Vec</code>、<code>String</code>和<code>HashMap</code>等都是固定大小的类型。对于动态大小类型，编译器无法在编译期得知该类型值的大小，只有到了程序运行时，才能动态获知。对于动态类型，使用<code>DST</code>(dynamically sized types)或者<code>unsized</code>类型来称呼。</p><p>对于集合类型，虽然底层数据可动态变化，感觉像是动态大小的类型。但是实际上，底层数据保存在堆上，在栈中还存有一个引用类型，该引用包含了集合的内存地址、元素数目、分配空间信息，通过这些信息，编译器可获取集合的实际大小，最重要的是栈上的引用类型是固定大小的，因此集合类型是固定大小的类型。</p><p>正因为编译器无法在编译期获知类型大小，倘若试图在代码中直接使用DST类型将无法通过编译。</p><p>只能间接使用DST类型。</p><p><font size=3><ins><strong>DST类型有哪些</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 试图创建动态大小的数组</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">my_function</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">123</span><span class="token punctuation">;</span> n<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment"> * 以上代码就会报错(错误输出的内容并不是因为 DST，但根本原因是类似的)，</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token comment"> * 因为n在编译期无法得知，而数组类型的一个组成部分就是长度，</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token comment"> * 长度变为动态的，自然类型就变成了unsized</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><p><code>切片</code> - 切片也是一个典型的 DST 类型</p><p><code>str</code> - 它既不是<code>String</code>动态字符串，也不是<code>&amp;str</code>字符串切片，而是一个<code>str</code>。它是一个动态类型，同时还是<code>String</code>和<code>&amp;str</code>的底层数据类型。由于<code>str</code>是动态类型，因此它的大小直到运行期才知道。</p><p>Rust中常见的<code>DST</code>类型有， <code>str</code>、<code>[T]</code>、<code>dyn Trait</code>，它们都无法单独被使用，必须要通过引用或者<code>Box</code>来间接使用 。</p><h4 id=sized特征><a class=anchor href=#sized特征>#</a> Sized特征</h4><p>例如泛型函数</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">generic</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span><span class="token punctuation">(</span>t<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token comment">// --snip--</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>编译器会自动加上<code>Sized</code>特征约束以保证<code>T</code>是固定大小的类型。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">generic</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Sized</span><span class="token operator">></span><span class="token punctuation">(</span>t<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token comment">// --snip--</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>Rust自动添加的特征约束<code>T: Sized</code>，表示泛型函数只能用于一切实现了<code>Sized</code>特征的类型上，而所有在编译时就能知道其大小的类型，都会自动实现<code>Sized</code>特征。</p><p>每一个特征都是一个可以通过名称来引用的动态大小类型。如果想把特征作为具体的类型来传递给函数，必须将其转换成一个特征对象。</p><p>想在泛型函数中使用动态数据类型可以使用<code>?Sized</code>特征。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">generic</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token operator">?</span><span class="token class-name">Sized</span><span class="token operator">></span><span class="token punctuation">(</span>t<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token comment">// --snip--</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>?Sized</code>特征用于表明类型<code>T</code>既有可能是固定大小的类型，也可能是动态大小的类型。函数参数类型从<code>T</code>变成了<code>&amp;T</code>，因为<code>T</code>可能是动态大小的，需要用一个固定大小的指针(引用)来包裹它。</p><h3 id=box智能指针><a class=anchor href=#box智能指针>#</a> Box智能指针</h3><p><code>Box&lt;T&gt;</code>是Rust中最常见的智能指针，允许将一个值分配到堆上并在栈上保留一个指针来指向堆上的数据。</p><p><code>Box</code>是简单的封装，除了将值存储在堆上外，并没有其它性能上的损耗。相比其它智能指针，功能较为单一，可在以下场景中使用</p><ul><li>特意的将数据分配在堆上</li><li>数据较大时，又不想在转移所有权时进行数据拷贝</li><li>类型的大小在编译期无法确定，但是又需要固定大小的类型时</li><li>特征对象，用于说明对象实现了一个特征，而不是某个特定的类型</li></ul><h4 id=box智能指针的使用><a class=anchor href=#box智能指针的使用>#</a> Box智能指针的使用</h4><p>使用<code>Box&lt;T&gt;</code>将数据存储在堆上。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 创建一个智能指针指向了存储在堆上的3，并且a持有了该指针</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"a = &#123;&#125;"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a = 3</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token comment">// 下面一行代码将报错</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token comment">// let b = a + 1; // cannot add `&#123;integer&#125;` to `Box&lt;&#123;integer&#125;>`</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token operator">*</span>a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>println!</code>可以正常打印出<code>a</code>的值，是因为它隐式地调用了<code>Deref</code>对智能指针<code>a</code>进行了解引用。</p><p><code>let b = a + 1</code>报错是因为在表达式中无法自动隐式地执行<code>Deref</code>解引用操作，需要使用<code>*</code>操作符来显式的进行解引用。</p><p>变量<code>a</code>持有的智能指针将在作用域结束(<code>main</code>函数结束)时被释放掉，这是因为<code>Box&lt;T&gt;</code>实现了<code>Drop</code>特征。</p><p>当栈上数据转移所有权时，实际上是把数据拷贝了一份，最终新旧变量各自拥有不同的数据，其所有权并未转移。而堆上的底层数据并不会被拷贝，转移所有权只是复制一份栈中的指针，再将新的指针赋予新的变量，然后让拥有旧指针的变量失效，最终完成了所有权的转移。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token comment">// 在栈上创建一个长度为1000的数组</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token comment">// 将arr所有权转移arr1，由于 `arr` 分配在栈上，因此这里实际上是直接重新深拷贝了一份数据</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">let</span> arr1 <span class="token operator">=</span> arr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token comment">// arr 和 arr1 都拥有各自的栈上数组，因此不会报错</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;:?&#125;"</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;:?&#125;"</span><span class="token punctuation">,</span> arr1<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token comment">// 在堆上创建一个长度为1000的数组，然后使用一个智能指针指向它</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token comment">// 将堆上数组的所有权转移给 arr1，由于数据在堆上，因此仅仅拷贝了智能指针的结构体，底层数据并没有被拷贝</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token comment">// 所有权顺利转移给 arr1，arr 不再拥有所有权</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token keyword">let</span> arr1 <span class="token operator">=</span> arr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;:?&#125;"</span><span class="token punctuation">,</span> arr1<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=17></td><td><pre>    <span class="token comment">// 由于 arr 不再拥有底层数组的所有权，因此下面代码将报错</span></pre></td></tr><tr><td data-num=18></td><td><pre>    <span class="token comment">// println!("&#123;:?&#125;", arr.len());</span></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id=动态大小类型转换为固定大小类型><a class=anchor href=#动态大小类型转换为固定大小类型>#</a> 动态大小类型转换为固定大小类型</h4><p>其中一种无法在编译时知道大小的类型是<strong>递归类型</strong>，在类型定义中使用到了自身，或者说该类型的值的一部分可以是相同类型的其它值，这种值的嵌套理论上可以无限进行下去，所以Rust不知道递归类型需要多少空间</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">enum</span> <span class="token type-definition class-name">List</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token class-name">Nil</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以使用<code>Box&lt;T&gt;</code>，只需要将<code>List</code>存储到堆上，然后使用一个智能指针指向它，即可完成从DST到Sized类型(固定大小类型)的转变。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">enum</span> <span class="token type-definition class-name">List</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token class-name">List</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token class-name">Nil</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id=box内存布局><a class=anchor href=#box内存布局>#</a> Box内存布局</h4><p><code>Vec&lt;i32&gt;</code>的内存布局</p><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>(stack)    (heap)</pre></td></tr><tr><td data-num=2></td><td><pre>┌──────┐   ┌───┐</pre></td></tr><tr><td data-num=3></td><td><pre>│ vec1 │──→│ 1 │</pre></td></tr><tr><td data-num=4></td><td><pre>└──────┘   ├───┤</pre></td></tr><tr><td data-num=5></td><td><pre>           │ 2 │</pre></td></tr><tr><td data-num=6></td><td><pre>           ├───┤</pre></td></tr><tr><td data-num=7></td><td><pre>           │ 3 │</pre></td></tr><tr><td data-num=8></td><td><pre>           ├───┤</pre></td></tr><tr><td data-num=9></td><td><pre>           │ 4 │</pre></td></tr><tr><td data-num=10></td><td><pre>           └───┘</pre></td></tr></table></figure><p>该智能指针存储在栈中，然后指向堆上的数组数据。</p><p><code>Vec&lt;Box&lt;i32&gt;&gt;</code>的内存布局</p><figure class="highlight tex"><figcaption data-lang=TeX></figcaption><table><tr><td data-num=1></td><td><pre>(heap)</pre></td></tr><tr><td data-num=2></td><td><pre>(stack)    (heap)   ┌───┐</pre></td></tr><tr><td data-num=3></td><td><pre>┌──────┐   ┌───┐ ┌─→│ 1 │</pre></td></tr><tr><td data-num=4></td><td><pre>│ vec2 │──→│B1 │─┘  └───┘</pre></td></tr><tr><td data-num=5></td><td><pre>└──────┘   ├───┤    ┌───┐</pre></td></tr><tr><td data-num=6></td><td><pre>           │B2 │───→│ 2 │</pre></td></tr><tr><td data-num=7></td><td><pre>           ├───┤    └───┘</pre></td></tr><tr><td data-num=8></td><td><pre>           │B3 │─┐  ┌───┐</pre></td></tr><tr><td data-num=9></td><td><pre>           ├───┤ └─→│ 3 │</pre></td></tr><tr><td data-num=10></td><td><pre>           │B4 │─┐  └───┘</pre></td></tr><tr><td data-num=11></td><td><pre>           └───┘ │  ┌───┐</pre></td></tr><tr><td data-num=12></td><td><pre>                 └─→│ 4 │</pre></td></tr><tr><td data-num=13></td><td><pre>                    └───┘</pre></td></tr></table></figure><p>B1代表被<code>Box</code>分配到堆上的值1。智能指针<code>vec2</code>依然是存储在栈上，然后指针指向一个堆上的数组，该数组中每个元素都是一个<code>Box</code>智能指针，最终<code>Box</code>智能指针又指向了存储在堆上的实际值。</p><p>当从数组中取出某个元素时，取到的是对应的智能指针<code>Box</code>，需要对该智能指针进行解引用才能取出最终的值。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">let</span> <span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token operator">*</span><span class="token operator">*</span>first <span class="token operator">+</span> <span class="token operator">*</span><span class="token operator">*</span>second<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token comment"> * 使用&amp;借用数组中的元素，否则会报所有权错误。</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token comment"> * 表达式不能隐式的解引用，</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token comment"> * 因此必须使用**做两次解引用，</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token comment"> * 第一次将&amp;Box&lt;i32>类型转成Box&lt;i32>，</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token comment"> * 第二次将Box&lt;i32>转成i32</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><p><code>Box</code>智能指针背后是调用<code>jemalloc</code>来做内存管理，所以堆上的空间无需手动管理。与此类似，带GC的语言中的对象也是借助于<code>Box</code>概念来实现的，<strong>一切皆对象 等于 一切皆Box</strong>， 只不过无需自己去<code>Box</code>罢了。</p><h3 id=deref解引用><a class=anchor href=#deref解引用>#</a> Deref解引用</h3><p>智能指针的名称来源，主要就在于它实现了<code>Deref</code>和<code>Drop</code>特征，这两个特征可以节省使用上的负担。</p><p><code>Deref</code>可以让智能指针像引用那样工作，这样就可以写出同时支持智能指针和引用的代码。</p><h4 id=常规解引用><a class=anchor href=#常规解引用>#</a> 常规解引用</h4><p>常规引用是一个指针类型，包含了目标数据存储的内存地址。对常规引用使用<code>*</code>操作符，就可以通过解引用的方式获取到内存地址对应的数据值。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id=智能指针解引用><a class=anchor href=#智能指针解引用>#</a> 智能指针解引用</h4><p>假如智能指针是一个结构体类型，如果直接对它进行<code>*myStruct</code>，显然编译器不知道该如何办。但可以为智能指针结构体实现<code>Deref</code>特征来解引用，实现<code>Deref</code>后的智能指针结构体，就可以像普通引用一样，通过<code>*</code>进行解引用。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 例如Box&lt;T>智能指针</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token operator">*</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id=背后的原理><a class=anchor href=#背后的原理>#</a> <code>*</code>背后的原理</h4><p>当对智能指针<code>Box</code>进行解引用时，实际上Rust调用了以下方法 - <code>*(y.deref())</code></p><p>首先调用<code>deref</code>方法返回值的常规引用，然后通过<code>*</code>对常规引用进行解引用，最终获取到目标值。</p><p>这个比较啰嗦方式是由于Rust所有权系统的存在而导致的。如果<code>Deref</code>方法直接返回一个值，而不是引用，那么该值的所有权将被转移给调用者，但实际上不希望调用者仅仅只是<code>*T</code> 一下，就拿走了智能指针中包含的值。需要注意的是，<code>*</code>不会无限递归替换，从<code>*y</code>到<code>*(y.deref())</code>只会发生一次，而不会继续进行替换然后产生形如<code>*((y.deref()).deref())</code>的异物。</p><h4 id=自制智能指针><a class=anchor href=#自制智能指针>#</a> 自制智能指针</h4><p>实现一个智能指针，功能上类似<code>Box&lt;T&gt;</code>。由于<code>Box&lt;T&gt;</code>本身很简单，并没有包含类如长度、最大长度等信息，因此用一个元组结构体即可。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">MyBox</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token class-name">MyBox</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">MyBox</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>        <span class="token class-name">MyBox</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>跟<code>Box&lt;T&gt;</code>一样，自定义的智能指针也持有一个<code>T</code>类型的值，然后使用关联函数<code>MyBox::new</code>来创建智能指针。</p><p>为<code>MyBox</code>实现<code>Deref</code>特征，以支持<code>*</code>解引用操作符。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>ops<span class="token punctuation">::</span></span><span class="token class-name">Deref</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token class-name">Deref</span> <span class="token keyword">for</span> <span class="token class-name">MyBox</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">type</span> <span class="token type-definition class-name">Target</span> <span class="token operator">=</span> <span class="token class-name">T</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">deref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token class-name">Target</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>        <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>当解引用<code>MyBox</code>智能指针时，返回元组结构体中的元素<code>&amp;self.0</code>，有几点要注意</p><ul><li>在<code>Deref</code>特征中声明了关联类型<code>Target</code>，关联类型主要是为了提升代码可读性</li><li><code>Deref</code>返回的是一个常规引用，可以被<code>*</code>进行解引用</li></ul><p>标准库实现的智能指针要考虑很多边边角角情况，肯定比当前自定义的智能指针要复杂。</p><h4 id=函数和方法中的隐式deref转换><a class=anchor href=#函数和方法中的隐式deref转换>#</a> 函数和方法中的隐式Deref转换</h4><p>对于函数和方法的传参，Rust提供了一个极其有用的隐式转换 - <code>Deref</code> 转换。若一个类型实现了<code>Deref</code>特征，那它的引用在传给函数或方法时，会根据参数签名来决定是否进行隐式的<code>Deref</code>转换</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token function">display</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">display</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>String</code>实现了<code>Deref</code>特征，可以在需要时自动被转换为<code>&amp;str</code>类型。</p><p><code>&amp;s</code>是一个<code>&amp;String</code>类型，当它被传给<code>display</code>函数时，自动通过<code>Deref</code>转换成了<code>&amp;str</code>。</p><p>必须使用<code>&amp;s</code>的方式来触发<code>Deref</code>(仅引用类型的实参才会触发自动解引用)。</p><p><font size=3><ins><strong>连续的隐式Deref转换</strong></ins></font></p><p><code>Deref</code>可以支持连续的隐式转换，直到找到适合的形式为止。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">MyBox</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token function">display</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">display</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里使用了之前自定义的智能指针<code>MyBox</code>，并将其通过连续的隐式转换变成<code>&amp;str</code>类型，首先<code>MyBox</code>被<code>Deref</code> 成<code>String</code>类型，结果并不能满足<code>display</code>函数参数的要求，编译器发现<code>String</code>还可以继续<code>Deref</code>成<code>&amp;str</code>，最终成功的匹配了函数参数。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 假如Rust没有提供这种隐式转换，调用display函数</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token class-name">MyBox</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Rust"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token function">display</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>当参与其中的类型定义了<code>Deref</code>特征时，Rust会分析该类型并且连续使用<code>Deref</code>直到最终获得一个引用来匹配函数或者方法的参数类型，这种行为完全不会造成任何的性能损耗，因为完全是在编译期完成。但是<code>Deref</code>并不是没有缺点，缺点就是，如果不知道某个类型是否实现了<code>Deref</code>特征，那么在看到某段代码时，并不能在第一时间反应过来该代码发生了隐式的<code>Deref</code>转换。</p><p>在方法、赋值中自动应用<code>Deref</code>的例子</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">MyBox</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">let</span> s1<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">let</span> s2<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>对于<code>s1</code>，通过两次<code>Deref</code>将<code>&amp;str</code>类型的值赋给了它(赋值操作需要手动解引用)。对于<code>s2</code>，在其上直接调用方法<code>to_string</code>，实际上<code>MyBox</code>根本没有没有实现该方法，能调用<code>to_string</code>，完全是因为编译器对<code>MyBox</code>应用了<code>Deref</code>的结果(方法调用会自动解引用)。</p><h4 id=deref规则总结><a class=anchor href=#deref规则总结>#</a> Deref规则总结</h4><p>一个类型为<code>T</code>的对象<code>foo</code>，如果<code>T: Deref&lt;Target=U&gt;</code>，那么相关<code>foo</code>的引用<code>&amp;foo</code>在应用的时候会自动转换为<code>&amp;U</code>。</p><p>Rust编译器实际上只能对<code>&amp;v</code>形式的引用进行解引用操作，如果是一个智能指针或者<code>&amp;&amp;&amp;&amp;v</code>类型，Rust会在解引用时自动把智能指针和<code>&amp;&amp;&amp;&amp;v</code>做引用归一化操作，转换成<code>&amp;v</code>形式，最终再对<code>&amp;v</code>进行以下解引用操作</p><ul><li><p>把智能指针(比如在库中定义的，Box、Rc、Arc、Cow等)从结构体脱壳为内部的引用类型，也就是转成结构体内部的<code>&amp;v</code></p></li><li><p>把多重<code>&amp;</code>，例如<code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;v</code>，归一成 <code>&amp;v</code></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 例如`&amp;&amp;&amp;&amp;&amp;&amp;&amp;v`</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token operator">?</span><span class="token class-name">Sized</span><span class="token operator">></span> <span class="token class-name">Deref</span> <span class="token keyword">for</span> <span class="token operator">&amp;</span><span class="token class-name">T</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">type</span> <span class="token type-definition class-name">Target</span> <span class="token operator">=</span> <span class="token class-name">T</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">deref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token class-name">T</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>        <span class="token operator">*</span><span class="token keyword">self</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token comment"> * 在这段源码中，&amp;T被自动解引用为T，也就是&amp;T: Deref&lt;Target=T>。 </span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token comment"> * 按照这个代码，&amp;&amp;&amp;&amp;T会被自动解引用为&amp;&amp;&amp;T，</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token comment"> * 然后再自动解引用为&amp;&amp;T，以此类推，直到最终变成&amp;T。</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure></li></ul><h4 id=三种deref转换><a class=anchor href=#三种deref转换>#</a> 三种Deref转换</h4><p>之前的都是不可变的<code>Deref</code>转换，实际上Rust还支持将一个可变的引用转换成另一个可变的引用以及将一个可变引用转换成不可变的引用，规则如下</p><ul><li>当<code>T: Deref&lt;Target=U&gt;</code>，可以将<code>&amp;T</code>转换成<code>&amp;U</code>，也就是我们之前看到的例子</li><li>当<code>T: DerefMut&lt;Target=U&gt;</code>，可以将<code>&amp;mut T</code>转换成<code>&amp;mut U</code></li><li>当<code>T: Deref&lt;Target=U&gt;</code>，可以将<code>&amp;mut T</code>转换成<code>&amp;U</code></li></ul><p>DerefMut的例子</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">MyBox</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    v<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token class-name">MyBox</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">MyBox</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>        <span class="token class-name">MyBox</span> <span class="token punctuation">&#123;</span> v<span class="token punctuation">:</span> x <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=10></td><td><pre></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>ops<span class="token punctuation">::</span></span><span class="token class-name">Deref</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token class-name">Deref</span> <span class="token keyword">for</span> <span class="token class-name">MyBox</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token keyword">type</span> <span class="token type-definition class-name">Target</span> <span class="token operator">=</span> <span class="token class-name">T</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">deref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token class-name">Target</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=17></td><td><pre>        <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>v</pre></td></tr><tr><td data-num=18></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=20></td><td><pre></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>ops<span class="token punctuation">::</span></span><span class="token class-name">DerefMut</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=22></td><td><pre></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token class-name">DerefMut</span> <span class="token keyword">for</span> <span class="token class-name">MyBox</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=24></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">deref_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token class-name">Target</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=25></td><td><pre>        <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">.</span>v</pre></td></tr><tr><td data-num=26></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=27></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=28></td><td><pre></pre></td></tr><tr><td data-num=29></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=30></td><td><pre>    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">MyBox</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello, "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=31></td><td><pre>    <span class="token function">display</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=32></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=33></td><td><pre></pre></td></tr><tr><td data-num=34></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">display</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=35></td><td><pre>    s<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=36></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=37></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>要实现<code>DerefMut</code>必须要先实现<code>Deref</code>特征 - <code>pub trait DerefMut: Deref</code></p><p><code>T: DerefMut&lt;Target=U&gt;</code>解读，将<code>&amp;mut T</code>类型通过<code>DerefMut</code>特征的方法转换为<code>&amp;mut U</code>类型，对应上例中，就是将<code>&amp;mut MyBox&lt;String&gt;</code>转换为<code>&amp;mut String</code>。</p><p>Rust可以把可变引用隐式的转换成不可变引用，但反之则不行。</p><h3 id=drop释放资源><a class=anchor href=#drop释放资源>#</a> Drop释放资源</h3><p>在Rust中可以指定在一个变量超出作用域时，执行一段特定的代码，最终编译器将自动插入这段收尾代码。这样就无需在每一个使用该变量的地方，都写一段代码来进行收尾工作和资源释放。</p><p>指定这样一段收尾工作靠的就是<code>Drop</code>特征。</p><p><code>drop</code>函数在<code>std::prelude</code>里，不需要手动引入。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">HasDrop1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">HasDrop2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Drop</span> <span class="token keyword">for</span> <span class="token class-name">HasDrop1</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Dropping HasDrop1!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Drop</span> <span class="token keyword">for</span> <span class="token class-name">HasDrop2</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Dropping HasDrop2!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">HasTwoDrops</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    one<span class="token punctuation">:</span> <span class="token class-name">HasDrop1</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=15></td><td><pre>    two<span class="token punctuation">:</span> <span class="token class-name">HasDrop2</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Drop</span> <span class="token keyword">for</span> <span class="token class-name">HasTwoDrops</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=18></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=19></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Dropping HasTwoDrops!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=20></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=22></td><td><pre></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">Foo</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=24></td><td><pre></pre></td></tr><tr><td data-num=25></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Drop</span> <span class="token keyword">for</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=26></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=27></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Dropping Foo!"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=28></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=29></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=30></td><td><pre></pre></td></tr><tr><td data-num=31></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=32></td><td><pre>    <span class="token keyword">let</span> _x <span class="token operator">=</span> <span class="token class-name">HasTwoDrops</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=33></td><td><pre>        two<span class="token punctuation">:</span> <span class="token class-name">HasDrop2</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=34></td><td><pre>        one<span class="token punctuation">:</span> <span class="token class-name">HasDrop1</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=35></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=36></td><td><pre>    <span class="token keyword">let</span> _foo <span class="token operator">=</span> <span class="token class-name">Foo</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=37></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Running!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=38></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>Drop</code>特征中的<code>drop</code>方法借用了目标的可变引用，而不是拿走了所有权。</p><p>结构体中每个字段都有自己的<code>Drop</code>。</p><h4 id=drop的顺序><a class=anchor href=#drop的顺序>#</a> Drop的顺序</h4><p>变量级别 - 按照逆序的方式，<code>_x</code>在<code>_foo</code>之前创建，因此<code>_x</code>在<code>_foo</code>之后被<code>drop</code></p><p>结构体内部 - 按照顺序的方式，结构体<code>_x</code>中的字段按照定义中的顺序依次<code>drop</code></p><p>实际上，就算不为<code>_x</code>结构体实现<code>Drop</code>特征，它内部的两个字段依然会调用<code>drop</code>。原因在于，Rust自动为几乎所有类型都实现了<code>Drop</code>特征，就算不手动为结构体实现<code>Drop</code>，它依然会调用默认实现的<code>drop</code>函数，同时再调用每个字段的<code>drop</code>方法。</p><h4 id=手动回收><a class=anchor href=#手动回收>#</a> 手动回收</h4><p>当使用智能指针来管理锁的时候，可能希望提前释放这个锁，然后让其它代码能及时获得锁，此时就需要提前去手动<code>drop</code>。 此处再提到一个悬念，<code>Drop::drop</code>只是借用了目标值的可变引用，所以就算提前调用了<code>drop</code>，后面的代码依然可以使用目标值，但是这就会访问一个并不存在的值，非常不安全，好在底层Rust会阻止。</p><p>例如</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token attribute attr-name">#[derive(Debug)]</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">Foo</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Drop</span> <span class="token keyword">for</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Dropping Foo!"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=9></td><td><pre></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token class-name">Foo</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    foo<span class="token punctuation">.</span><span class="token function">drop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Running!:&#123;:?&#125;"</span><span class="token punctuation">,</span> foo<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token comment"> * 会报错</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token comment"> *  error[E0040]: explicit use of destructor method</span></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token comment"> *  --> src/main.rs:37:9</span></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token comment"> *  |</span></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token comment"> * 37 |     foo.drop();</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token comment"> *  |     ----^^^^--</span></pre></td></tr><tr><td data-num=22></td><td><pre><span class="token comment"> *  |     |   |</span></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token comment"> *  |     |   explicit destructor calls not allowed</span></pre></td></tr><tr><td data-num=24></td><td><pre><span class="token comment"> *  |     help: consider using `drop` function: `drop(foo)`</span></pre></td></tr><tr><td data-num=25></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><p>如上所示，编译器直接阻止了调用<code>Drop</code>特征的<code>drop</code>方法，原因是对于Rust而言，不允许显式地调用析构函数(这是一个用来清理实例的通用编程概念)。</p><p><code>drop</code>函数会拿走了目标值的所有权，而且这种实现保证了后续的使用必定会导致编译错误，因此非常安全。</p><h4 id=drop使用场景><a class=anchor href=#drop使用场景>#</a> Drop使用场景</h4><p>对于Drop而言，主要有两个功能</p><ul><li>回收内存资源</li><li>执行一些收尾工作</li></ul><p>在绝大多数情况下都无需手动<code>drop</code>去回收内存资源，因为Rust会自动完成这些工作，甚至会对复杂类型的每个字段都单独的调用<code>drop</code>进行回收。但确实有极少数情况需要手动回收资源，例如文件描述符、网络socket等，当这些值超出作用域不再使用时，就需要进行关闭以释放相关的资源，在这些情况下，就需要使用者自己来解决<code>Drop</code>的问题。</p><h4 id=互斥的copy和drop><a class=anchor href=#互斥的copy和drop>#</a> 互斥的Copy和Drop</h4><p>无法为一个类型同时实现<code>Copy</code>和<code>Drop</code>特征。因为实现了<code>Copy</code>的特征会被编译器隐式的复制，因此非常难以预测析构函数执行的时间和频率。因此这些实现了<code>Copy</code>的类型无法拥有析构函数。</p><p>例如</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token attribute attr-name">#[derive(Copy)]</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">Foo</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Drop</span> <span class="token keyword">for</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Dropping Foo!"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token comment"> * error[E0184]: the trait `Copy` may not be implemented for this type; the type has a   destructor</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token comment"> * --> src/main.rs:24:10</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token comment"> *  |</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token comment"> * 24 | #[derive(Copy)]</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token comment"> *  |          ^^^^ Copy not allowed on types with destructors</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><h3 id=一对多的所有权机制><a class=anchor href=#一对多的所有权机制>#</a> 一对多的所有权机制</h3><h4 id=rct-引用计数reference-counting><a class=anchor href=#rct-引用计数reference-counting>#</a> <code>Rc&lt;T&gt;</code>-引用计数(Reference Counting)</h4><p>通过记录一个数据被引用的次数来确定该数据是否正在被使用。当引用次数归零时，就代表该数据不再被使用，接着就会被清理释放。</p><p>当希望在堆上分配一个对象供程序的多个部分使用，且无法确定哪个部分是最后一个时，就可使用Rc成为数据值的所有者。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>rc<span class="token punctuation">::</span></span><span class="token class-name">Rc</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">strong_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">strong_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">strong_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>Rc::new</code>创建了一个新的<code>Rc&lt;String&gt;</code>智能指针并赋给变量<code>a</code>，该指针指向底层的字符串数据。智能指针<code>Rc&lt;T&gt;</code>在创建时会将引用计数加1，此时获取引用计数的关联函数<code>Rc::strong_count</code>返回的值将是<code>1</code>。</p><p><code>Rc::clone</code>克隆了一份智能指针<code>Rc&lt;String&gt;</code>，并将该智能指针的引用计数增加到<code>2</code>。由于<code>a</code>和<code>b</code>是同一个智能指针的两个副本，因此通过它们两个获取引用计数的结果都是<code>2</code>。这里的<code>clone</code>仅是复制了智能指针，并增加了引用计数，并没有克隆底层数据，因此<code>a</code>和<code>b</code>是共享了底层的字符串<code>s</code>。</p><p><font size=3><ins><strong>引用计数的变化</strong></ins></font></p><p>关联函数<code>Rc::strong_count</code>可以获取当前引用计数的值。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>rc<span class="token punctuation">::</span></span><span class="token class-name">Rc</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>        <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test ref counting"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"count after creating a = &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">strong_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>        <span class="token keyword">let</span> b <span class="token operator">=</span>  <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"count after creating b = &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">strong_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>            <span class="token keyword">let</span> c <span class="token operator">=</span>  <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>            <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"count after creating c = &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">strong_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=11></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"count after c goes out of scope = &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">strong_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>Rc&lt;T&gt;</code>实现了<code>Drop</code>特征，变量<code>c</code>在语句块内部声明，当离开语句块时它会因为超出作用域而被释放，所以引用计数会减少1。</p><p><code>a</code>、<code>b</code>、<code>c</code>三个智能指针引用计数都是同样的，并且共享底层的数据，因此打印计数时用哪个都行。</p><p><code>a</code>、<code>b</code>超出作用域后，引用计数会变成0，最终智能指针和它指向的底层字符串都会被清理释放。</p><p><font size=3><ins><strong>不可变引用</strong></ins></font></p><p><code>Rc&lt;T&gt;</code>是以不可变引用的方式指向底层数据的，因此无法通过它来修改数据，这符合Rust的借用规则 - 要么存在多个不可变借用，要么只能存在一个可变借用。</p><p>但是实际开发中我们往往需要对数据进行修改，这时单独使用<code>Rc&lt;T&gt;</code>无法满足我们的需求，需要配合其它数据类型来一起使用，例如内部可变性的<code>RefCell&lt;T&gt;</code>类型以及互斥锁<code>Mutex&lt;T&gt;</code>。</p><p><font size=3><ins><strong>综合例子</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>rc<span class="token punctuation">::</span></span><span class="token class-name">Rc</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">Owner</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token comment">// ...其它字段</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=7></td><td><pre></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">Gadget</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    id<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=10></td><td><pre>    owner<span class="token punctuation">:</span> <span class="token class-name">Rc</span><span class="token operator">&lt;</span><span class="token class-name">Owner</span><span class="token operator">></span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token comment">// ...其它字段</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=13></td><td><pre></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token comment">// 创建一个基于引用计数的 `Owner`.</span></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token keyword">let</span> gadget_owner<span class="token punctuation">:</span> <span class="token class-name">Rc</span><span class="token operator">&lt;</span><span class="token class-name">Owner</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">Owner</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=17></td><td><pre>        name<span class="token punctuation">:</span> <span class="token string">"Gadget Man"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=18></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=19></td><td><pre></pre></td></tr><tr><td data-num=20></td><td><pre>    <span class="token comment">// 创建两个不同的工具，它们属于同一个主人</span></pre></td></tr><tr><td data-num=21></td><td><pre>    <span class="token keyword">let</span> gadget1 <span class="token operator">=</span> <span class="token class-name">Gadget</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=22></td><td><pre>        id<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=23></td><td><pre>        owner<span class="token punctuation">:</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gadget_owner<span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=24></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=25></td><td><pre>    <span class="token keyword">let</span> gadget2 <span class="token operator">=</span> <span class="token class-name">Gadget</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=26></td><td><pre>        id<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=27></td><td><pre>        owner<span class="token punctuation">:</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gadget_owner<span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=28></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=29></td><td><pre></pre></td></tr><tr><td data-num=30></td><td><pre>    <span class="token comment">// 释放掉第一个 `Rc&lt;Owner>`</span></pre></td></tr><tr><td data-num=31></td><td><pre>    <span class="token function">drop</span><span class="token punctuation">(</span>gadget_owner<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=32></td><td><pre></pre></td></tr><tr><td data-num=33></td><td><pre>    <span class="token comment">// 尽管在上面我们释放了 gadget_owner，但是依然可以在这里使用 owner 的信息</span></pre></td></tr><tr><td data-num=34></td><td><pre>    <span class="token comment">// 原因是在 drop 之前，存在三个指向 Gadget Man 的智能指针引用，上面仅仅</span></pre></td></tr><tr><td data-num=35></td><td><pre>    <span class="token comment">// drop 掉其中一个智能指针引用，而不是 drop 掉 owner 数据，外面还有两个</span></pre></td></tr><tr><td data-num=36></td><td><pre>    <span class="token comment">// 引用指向底层的 owner 数据，引用计数尚未清零</span></pre></td></tr><tr><td data-num=37></td><td><pre>    <span class="token comment">// 因此 owner 数据依然可以被使用</span></pre></td></tr><tr><td data-num=38></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Gadget &#123;&#125; owned by &#123;&#125;"</span><span class="token punctuation">,</span> gadget1<span class="token punctuation">.</span>id<span class="token punctuation">,</span> gadget1<span class="token punctuation">.</span>owner<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=39></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Gadget &#123;&#125; owned by &#123;&#125;"</span><span class="token punctuation">,</span> gadget2<span class="token punctuation">.</span>id<span class="token punctuation">,</span> gadget2<span class="token punctuation">.</span>owner<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=40></td><td><pre></pre></td></tr><tr><td data-num=41></td><td><pre>    <span class="token comment">// 在函数最后，`gadget1` 和 `gadget2` 也被释放，最终引用计数归零，随后底层</span></pre></td></tr><tr><td data-num=42></td><td><pre>    <span class="token comment">// 数据也被清理释放</span></pre></td></tr><tr><td data-num=43></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>Rc/Arc</code>是不可变引用，无法修改它指向的值，只能进行读取，如果要修改，需要配合内部可变性<code>RefCell</code>或互斥锁<code>Mutex</code>。</p><p>一旦最后一个拥有者消失，则资源会自动被回收，这个生命周期是在编译期就确定下来的。</p><p><code>Rc</code>只能用于同一线程内部，想要用于线程之间的对象共享，需要使用<code>Arc</code>。</p><p><code>Rc&lt;T&gt;</code>是一个智能指针，实现了<code>Deref</code>特征，因此无需先解开<code>Rc</code>指针，再使用里面的<code>T</code>，而是可以直接使用<code>T</code>，例如上例中的<code>gadget1.owner.name</code>。</p><h4 id=arcatomic-rc><a class=anchor href=#arcatomic-rc>#</a> Arc(Atomic Rc)</h4><p>是原子化的<code>Rc&lt;T&gt;</code>智能指针，原子化是一种并发原语。</p><p>原子化或者其它锁虽然可以带来线程安全，但是都会伴随着不小的性能损耗。因此Rust把选择权交出，毕竟需要线程安全的代码其实占比并不高，大部分时候开发的程序都在一个线程内。</p><p><code>Arc</code>和<code>Rc</code>并没有定义在同一个模块，前者通过<code>use std::sync::Arc</code>来引入，后者通过<code>use std::rc::Rc</code>。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>sync<span class="token punctuation">::</span></span><span class="token class-name">Arc</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span></span>thread<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">Arc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"多线程漫游者"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span><span class="token number">10</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>        <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">Arc</span><span class="token punctuation">::</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>        <span class="token keyword">let</span> handle <span class="token operator">=</span> <span class="token namespace">thread<span class="token punctuation">::</span></span><span class="token function">spawn</span><span class="token punctuation">(</span><span class="token keyword">move</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>           <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=11></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>Arc</code>和<code>Rc</code>两者都是只读的，如果想要实现内部数据可修改，必须配合内部可变性<code>RefCell</code>或者互斥锁<code>Mutex</code>来一起使用。</p><h4 id=cell和refcell><a class=anchor href=#cell和refcell>#</a> Cell和RefCell</h4><p>Rust提供了<code>Cell</code>和<code>RefCell</code>用于内部可变性，可以在拥有不可变引用的同时修改目标数据。</p><p>内部可变性的实现是因为Rust使用了<code>unsafe</code>来做到这一点，但是对于使用者来说，这些都是透明的，因为这些不安全代码都被封装到了安全的API中。</p><p><font size=3><ins><strong>Cell</strong></ins></font></p><p><code>Cell</code>和<code>RefCell</code>在功能上没有区别，区别在于<code>Cell&lt;T&gt;</code>适用于<code>T</code>实现<code>Copy</code>的情况，实际开发中，<code>Cell</code>使用的并不多。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>cell<span class="token punctuation">::</span></span><span class="token class-name">Cell</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>  <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token class-name">Cell</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"asdf"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre>  <span class="token keyword">let</span> one <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>  c<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"qwer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>  <span class="token keyword">let</span> two <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;,&#123;&#125;"</span><span class="token punctuation">,</span> one<span class="token punctuation">,</span> two<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>&quot;asdf&quot;</code>是<code>&amp;str</code>类型，它实现了<code>Copy</code>特征。</p><p><code>c.get</code>用来取值，<code>c.set</code>用来设置新值。</p><p>取到值保存在<code>one</code>变量后，还能同时进行修改，这个违背了 Rust 的借用规则，但是由于<code>Cell</code>的存在，可以做到了这一点，但是如果尝试在<code>Cell</code>中存放<code>String</code>，由于<code>String</code>没有实现<code>Copy</code>特征，编译器会立刻报错。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token class-name">Cell</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"asdf"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment"> * 报错</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment"> * | pub struct String &#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment"> * | ----------------- doesn't satisfy `String: Copy`</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token comment"> * |</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token comment"> * = note: the following trait bounds were not satisfied:</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token comment"> *       `String: Copy`</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><p><font size=3><ins><strong>RefCell</strong></ins></font></p><p>要解决的往往是可变、不可变引用共存导致的问题，此时就需要借助于<code>RefCell</code>来达成目的。</p><p>与<code>Cell</code>用于可<code>Copy</code>的值不同，<code>RefCell</code>用于引用。使用<code>RefCell</code>时，违背借用规则会导致运行期的<code>panic</code>。</p><table><thead><tr><th>Rust规则</th><th>智能指针带来的额外规则</th></tr></thead><tbody><tr><td>一个数据只有一个所有者</td><td><code>Rc/Arc</code>让一个数据可以拥有多个所有者</td></tr><tr><td>要么多个不可变借用，要么一个可变借用</td><td><code>RefCell</code>实现编译期可变、不可变引用共存</td></tr><tr><td>违背规则导致编译错误</td><td>违背规则导致运行时<code>panic</code></td></tr></tbody></table><p><code>Rc/Arc</code>和<code>RefCell</code>合在一起，解决了Rust中严苛的所有权和借用规则带来的某些场景下难使用的问题。</p><p><code>RefCell</code>实际上并没有解决可变引用和引用可以共存的问题，只是将报错从编译期推迟到运行时，从编译器错误变成了<code>panic</code>异常。</p><p>总之，当确信编译器误报但不知道该如何解决时，或者有一个引用类型，需要被四处使用和修改然后导致借用关系难以管理时，都可以优先考虑使用<code>RefCell</code>。</p><p><font size=3><ins><strong>Cell与RefCell比较</strong></ins></font></p><p><code>Cell</code>只适用于<code>Copy</code>类型，用于提供值，而<code>RefCell</code>用于提供引用。</p><p><code>Cell</code>不会<code>panic</code>，而<code>RefCell</code>会。</p><p><code>Cell</code>没有额外的性能损耗。与<code>Cell</code>的<code>zero cost</code>不同，<code>RefCell</code>其实是有一点运行期开销的，原因是它包含了一个字大小的借用状态指示器，该指示器在每次运行时借用时都会被修改，进而产生一点开销。</p><p>总之，当非要使用内部可变性时，首选<code>Cell</code>，只有当类型没有实现<code>Copy</code>时，才去选择<code>RefCell</code>。</p><p><font size=3><ins><strong>内部可变性</strong></ins></font></p><p>何为内部可变性？简单来说，对一个不可变的值进行可变借用，但这个并不符合 Rust 的基本借用规则，例如</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>上面的代码会报错，因为不能对一个不可变的值进行可变借用，这会破坏 Rust 的安全性保证。相反，可以对一个可变值进行不可变借用。原因是，当值不可变时，可能会有多个不可变的引用指向它，此时若将其中一个修改为可变的，会造成可变引用与不可变引用共存的情况；而当值可变时，最多只会有一个可变引用指向它，将其修改为不可变，那么最终依然是只有一个不可变的引用指向它。</p><p>然而在某些场景中，一个值可以在其方法内部被修改，同时对于其它代码不可变，是很有用的</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 定义在外部库中的特征</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">Messenger</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">send</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> msg<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment">// --------------------------</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token comment">// 我们的代码中的数据结构和实现</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">MsgQueue</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    msg_cache<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">></span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=11></td><td><pre></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Messenger</span> <span class="token keyword">for</span> <span class="token class-name">MsgQueue</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">send</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> msg<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=14></td><td><pre>        <span class="token keyword">self</span><span class="token punctuation">.</span>msg_cache<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=15></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>外部库中定义了一个消息发送器特征<code>Messenger</code>，它只有一个发送消息的功能<code>send</code>，因为发送消息不需要修改自身，因此原作者在定义时，使用了<code>&amp;self</code>的不可变借用。</p><p>当要在自己的代码中使用该特征实现一个异步消息队列，出于性能的考虑，消息先写到本地缓存(内存)中，然后批量发送出去，因此在<code>send</code>方法中，需要将消息先行插入到本地缓存<code>msg_cache</code>中。但是该<code>send</code>方法的签名是<code>&amp;self</code>，因此上述代码会报错。解决方法是通过包裹一层<code>RefCell</code>，成功的让<code>&amp;self</code>中的<code>msg_cache</code>成为一个可变值，然后实现对其的修改。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>cell<span class="token punctuation">::</span></span><span class="token class-name">RefCell</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">Messenger</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">send</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> msg<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">MsgQueue</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    msg_cache<span class="token punctuation">:</span> <span class="token class-name">RefCell</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">>></span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=9></td><td><pre></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Messenger</span> <span class="token keyword">for</span> <span class="token class-name">MsgQueue</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">send</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> msg<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=12></td><td><pre>        <span class="token keyword">self</span><span class="token punctuation">.</span>msg_cache<span class="token punctuation">.</span><span class="token function">borrow_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=15></td><td><pre></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=17></td><td><pre>    <span class="token keyword">let</span> mq <span class="token operator">=</span> <span class="token class-name">MsgQueue</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=18></td><td><pre>        msg_cache<span class="token punctuation">:</span> <span class="token class-name">RefCell</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=19></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=20></td><td><pre>    mq<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id=rc与refcell的组合使用><a class=anchor href=#rc与refcell的组合使用>#</a> Rc与RefCell的组合使用</h4><p>在Rust中，一个常见的组合就是<code>Rc</code>和<code>RefCell</code>在一起使用，前者可以实现一个数据拥有多个所有者，后者可以实现数据的可变性。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>cell<span class="token punctuation">::</span></span><span class="token class-name">RefCell</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>rc<span class="token punctuation">::</span></span><span class="token class-name">Rc</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">RefCell</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"我很善变，还拥有多个主人"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">let</span> s2 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token comment">// let mut s2 = s.borrow_mut();</span></pre></td></tr><tr><td data-num=9></td><td><pre>    s2<span class="token punctuation">.</span><span class="token function">borrow_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">", oh yeah!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;:?&#125;\n&#123;:?&#125;\n&#123;:?&#125;"</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=13></td><td><pre></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token comment"> * 结果为</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token comment"> * RefCell &#123; value: "我很善变，还拥有多个主人, oh yeah!" &#125;</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token comment"> * RefCell &#123; value: "我很善变，还拥有多个主人, oh yeah!" &#125;</span></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token comment"> * RefCell &#123; value: "我很善变，还拥有多个主人, oh yeah!" &#125;</span></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><p>上面代码中使用<code>RefCell&lt;String&gt;</code>包裹一个字符串，同时通过<code>Rc</code>创建了它的三个所有者(<code>s</code>、<code>s1</code>和<code>s2</code>)，并且通过其中一个所有者<code>s2</code>对字符串内容进行了修改。由于<code>Rc</code>的所有者们共享同一个底层的数据，因此当一个所有者修改了数据时，会导致全部所有者持有的数据都发生了变化。</p><p><font size=3><ins><strong>通过<code>Cell::from_mut</code>解决借用冲突</strong></ins></font></p><p><code>Cell::from_mut</code> → 该方法将<code>&amp;mut T</code>转为<code>&amp;Cell&lt;T&gt;</code></p><p><code>Cell::as_slice_of_cells</code> → 该方法将<code>&amp;Cell&lt;[T]&gt;</code>转为<code>&amp;[Cell&lt;T&gt;]</code></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">is_even</span><span class="token punctuation">(</span>i<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">retain_even</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">let</span> <span class="token keyword">mut</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token operator">&amp;</span>num<span class="token closure-punctuation punctuation">|</span></span> <span class="token function">is_even</span><span class="token punctuation">(</span><span class="token operator">*</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span>num<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>        i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    nums<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>以上代码会报错，报错是因为同时借用了不可变与可变引用，可以通过索引的方式来避免这个问题。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">retain_even</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">let</span> <span class="token keyword">mut</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span>nums<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>        <span class="token keyword">if</span> <span class="token function">is_even</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre>            i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    nums<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>也可以使用<code>Cell</code>的这两个方法。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>cell<span class="token punctuation">::</span></span><span class="token class-name">Cell</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">retain_even</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token keyword">let</span> slice<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token class-name">Cell</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Cell</span><span class="token punctuation">::</span><span class="token function">from_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> nums<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=5></td><td><pre>        <span class="token punctuation">.</span><span class="token function">as_slice_of_cells</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">let</span> <span class="token keyword">mut</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">for</span> num <span class="token keyword">in</span> slice<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>num<span class="token closure-punctuation punctuation">|</span></span> <span class="token function">is_even</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=9></td><td><pre>        slice<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>        i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=12></td><td><pre></pre></td></tr><tr><td data-num=13></td><td><pre>    nums<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>此时代码将不会报错，因为<code>Cell</code>上的<code>set</code>方法获取的是不可变引用<code>pub fn set(&amp;self, val: T)</code>。当然，以上代码的本质还是对<code>Cell</code>的运用，只不过这两个方法可以很方便地把<code>&amp;mut [T]</code>类型转换成<code>&amp;[Cell&lt;T&gt;]</code>类型。</p><h2 id=深入特征><a class=anchor href=#深入特征>#</a> 深入特征</h2><h3 id=特征对象><a class=anchor href=#特征对象>#</a> 特征对象</h3><p>函数返回值为<code>impl Trait</code>的这种方式有一个很大的限制，就是只能有一个具体的类型。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">returns_summarizable</span><span class="token punctuation">(</span>switch<span class="token punctuation">:</span> <span class="token keyword">bool</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">impl</span> <span class="token class-name">Summary</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">if</span> switch <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>        <span class="token class-name">Post</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=4></td><td><pre>            title<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num=5></td><td><pre>                <span class="token string">"Penguins win the Stanley Cup Championship!"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=6></td><td><pre>            <span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=7></td><td><pre>            author<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Iceburgh"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=8></td><td><pre>            content<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num=9></td><td><pre>                <span class="token string">"The Pittsburgh Penguins once again are the best \</span></pre></td></tr><tr><td data-num=10></td><td><pre>                 hockey team in the NHL."<span class="token punctuation">,</span></pre></td></tr><tr><td data-num=11></td><td><pre>            <span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=12></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=14></td><td><pre>        <span class="token class-name">Weibo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=15></td><td><pre>            username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"horse_ebooks"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=16></td><td><pre>            content<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num=17></td><td><pre>                <span class="token string">"of course, as you probably already know, people"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=18></td><td><pre>            <span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=19></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=20></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>例如上面的代码，其中<code>Post</code>和<code>Weibo</code>都实现了<code>Summary</code>特征，因此上面的函数试图通过返回<code>impl Summary</code>来返回这两个类型，但是编译器报错了，原因是<code>impl Trait</code>的返回值类型并不支持多种不同的类型返回。</p><p>Rust没有继承。</p><h4 id=特征对象定义><a class=anchor href=#特征对象定义>#</a> 特征对象定义</h4><p>为了解决上面例子之类的问题，Rust引入了<strong>特征对象</strong>这个概念。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 为UI组件定义一个特征</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">Draw</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">draw</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token comment"> * 只要组件实现了Draw特征，</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token comment"> * 就可以调用draw方法来进行渲染。</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token comment"> * 假设有一个Button和SelectBox组件实现了Draw特征</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token comment">**/</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Button</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token keyword">pub</span> width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token keyword">pub</span> height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token keyword">pub</span> label<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=16></td><td><pre></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Draw</span> <span class="token keyword">for</span> <span class="token class-name">Button</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=18></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">draw</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=19></td><td><pre>        <span class="token comment">// 绘制按钮的代码</span></pre></td></tr><tr><td data-num=20></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=22></td><td><pre></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">SelectBox</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=24></td><td><pre>    width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=25></td><td><pre>    height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=26></td><td><pre>    options<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">></span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=27></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=28></td><td><pre></pre></td></tr><tr><td data-num=29></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Draw</span> <span class="token keyword">for</span> <span class="token class-name">SelectBox</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=30></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">draw</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=31></td><td><pre>        <span class="token comment">// 绘制SelectBox的代码</span></pre></td></tr><tr><td data-num=32></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=33></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=34></td><td><pre></pre></td></tr><tr><td data-num=35></td><td><pre><span class="token comment">// 还需要一个动态数组来存储这些UI对象</span></pre></td></tr><tr><td data-num=36></td><td><pre><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Screen</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=37></td><td><pre>    <span class="token keyword">pub</span> components<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=38></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=39></td><td><pre><span class="token comment">// ?表示目前学过的内容中找不到可以填入的类型</span></pre></td></tr></table></figure><p><strong>特征对象</strong>指向实现了<code>Draw</code>特征的类型的实例，也就是指向了<code>Button</code>或者<code>SelectBox</code>的实例，这种映射关系是存储在一张表中，可以在运行时通过特征对象找到具体调用的类型方法。</p><p>可以通过<code>&amp;</code>引用或者<code>Box&lt;T&gt;</code>智能指针的方式来创建特征对象。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">trait</span> <span class="token type-definition class-name">Draw</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">draw</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Draw</span> <span class="token keyword">for</span> <span class="token keyword">u8</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">draw</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>        <span class="token macro property">format!</span><span class="token punctuation">(</span><span class="token string">"u8: &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token keyword">self</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=10></td><td><pre></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Draw</span> <span class="token keyword">for</span> <span class="token keyword">f64</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">draw</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=13></td><td><pre>        <span class="token macro property">format!</span><span class="token punctuation">(</span><span class="token string">"f64: &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token keyword">self</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=16></td><td><pre></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token comment">// 若 T 实现了 Draw 特征， 则调用该函数时传入的 Box&lt;T> 可以被隐式转换成函数参数签名中的 Box&lt;dyn Draw></span></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">draw1</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token keyword">dyn</span> <span class="token class-name">Draw</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=19></td><td><pre>    <span class="token comment">/** </span></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token comment">     * 由于实现了Deref特征，Box智能指针会自动解引用为它所包裹的值，</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token comment">     * 然后调用该值对应的类型上定义的 `draw` 方法。</span></pre></td></tr><tr><td data-num=22></td><td><pre><span class="token comment">    **/</span></pre></td></tr><tr><td data-num=23></td><td><pre>    x<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=24></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=25></td><td><pre></pre></td></tr><tr><td data-num=26></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">draw2</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">dyn</span> <span class="token class-name">Draw</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=27></td><td><pre>    x<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=28></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=29></td><td><pre></pre></td></tr><tr><td data-num=30></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=31></td><td><pre>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1.1f64</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=32></td><td><pre>    <span class="token comment">// do_something(&amp;x);</span></pre></td></tr><tr><td data-num=33></td><td><pre>    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">8u8</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=34></td><td><pre></pre></td></tr><tr><td data-num=35></td><td><pre>    <span class="token comment">/**</span></pre></td></tr><tr><td data-num=36></td><td><pre><span class="token comment">     * x和y的类型T都实现了 `Draw` 特征，</span></pre></td></tr><tr><td data-num=37></td><td><pre><span class="token comment">     * 因为Box&lt;T> 可以在函数调用时隐式地被转换为特征对象 Box&lt;dyn Draw>。</span></pre></td></tr><tr><td data-num=38></td><td><pre><span class="token comment">    **/</span></pre></td></tr><tr><td data-num=39></td><td><pre>    <span class="token comment">// 基于 x 的值创建一个 Box&lt;f64> 类型的智能指针，指针指向的数据被放置在了堆上</span></pre></td></tr><tr><td data-num=40></td><td><pre>    <span class="token function">draw1</span><span class="token punctuation">(</span><span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=41></td><td><pre>    <span class="token comment">// 基于 y 的值创建一个 Box&lt;u8> 类型的智能指针</span></pre></td></tr><tr><td data-num=42></td><td><pre>    <span class="token function">draw1</span><span class="token punctuation">(</span><span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=43></td><td><pre>    <span class="token function">draw2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=44></td><td><pre>    <span class="token function">draw2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=45></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>draw1</code>函数的参数是<code>Box&lt;dyn Draw&gt;</code>形式的特征对象，该特征对象是通过<code>Box::new(x)</code>的方式创建的。</p><p><code>draw2</code>函数的参数是<code>&amp;dyn Draw</code>形式的特征对象，该特征对象是通过<code>&amp;x</code>的方式创建的。</p><p><code>dyn</code>关键字只用在特征对象的类型声明上，在创建时无需使用<code>dyn</code>。</p><p>可以使用特征对象来代表泛型或具体的类型，继续来完善之前的 UI 组件代码</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 实现Screen</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Screen</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">pub</span> components<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token keyword">dyn</span> <span class="token class-name">Draw</span><span class="token operator">>></span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment">/** </span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment"> * 其中存储了一个动态数组，里面元素的类型是Draw特征对象(Box&lt;dyn Draw>)</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token comment"> * 任何实现了Draw特征的类型，都可以存放其中。</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token comment">**/</span></pre></td></tr><tr><td data-num=9></td><td><pre></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token comment">// 为Screen定义run方法，用于将列表中的UI组件渲染在屏幕上</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Screen</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">run</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=13></td><td><pre>        <span class="token keyword">for</span> component <span class="token keyword">in</span> <span class="token keyword">self</span><span class="token punctuation">.</span>components<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=14></td><td><pre>            component<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=18></td><td><pre></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token comment">/********************************/</span></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token comment">//通过泛型实现</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Screen</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Draw</span><span class="token operator">></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=22></td><td><pre>    <span class="token keyword">pub</span> components<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=24></td><td><pre></pre></td></tr><tr><td data-num=25></td><td><pre><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token class-name">Screen</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num=26></td><td><pre>    <span class="token keyword">where</span> <span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Draw</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=27></td><td><pre>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">run</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=28></td><td><pre>        <span class="token keyword">for</span> component <span class="token keyword">in</span> <span class="token keyword">self</span><span class="token punctuation">.</span>components<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=29></td><td><pre>            component<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=30></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=31></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=32></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=33></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=34></td><td><pre><span class="token comment"> * 上面的Screen的列表中，存储了类型为T的元素，</span></pre></td></tr><tr><td data-num=35></td><td><pre><span class="token comment"> * 然后在Screen中使用特征约束让T实现了Draw特征，进而可以调用draw方法。</span></pre></td></tr><tr><td data-num=36></td><td><pre><span class="token comment"> * 但是这种写法限制了Screen实例的Vec&lt;T>中的每个元素必须是Button类型</span></pre></td></tr><tr><td data-num=37></td><td><pre><span class="token comment"> * 或者全是SelectBox类型。如果只需要同质(相同类型)集合，</span></pre></td></tr><tr><td data-num=38></td><td><pre><span class="token comment"> * 更倾向于采用泛型+特征约束这种写法，因其实现更清晰，</span></pre></td></tr><tr><td data-num=39></td><td><pre><span class="token comment"> * 且性能更好(特征对象，需要在运行时从 vtable 动态查找需要调用的方法)。</span></pre></td></tr><tr><td data-num=40></td><td><pre><span class="token comment">**/</span></pre></td></tr><tr><td data-num=41></td><td><pre><span class="token comment">/********************************/</span></pre></td></tr><tr><td data-num=42></td><td><pre></pre></td></tr><tr><td data-num=43></td><td><pre><span class="token comment">// 运行渲染下UI组件列表</span></pre></td></tr><tr><td data-num=44></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=45></td><td><pre>    <span class="token keyword">let</span> screen <span class="token operator">=</span> <span class="token class-name">Screen</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=46></td><td><pre>        components<span class="token punctuation">:</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span></pre></td></tr><tr><td data-num=47></td><td><pre>            <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">SelectBox</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=48></td><td><pre>                width<span class="token punctuation">:</span> <span class="token number">75</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=49></td><td><pre>                height<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=50></td><td><pre>                options<span class="token punctuation">:</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span></pre></td></tr><tr><td data-num=51></td><td><pre>                    <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Yes"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=52></td><td><pre>                    <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Maybe"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=53></td><td><pre>                    <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"No"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=54></td><td><pre>                <span class="token punctuation">]</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=55></td><td><pre>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=56></td><td><pre>            <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">Button</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=57></td><td><pre>                width<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=58></td><td><pre>                height<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=59></td><td><pre>                label<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"OK"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=60></td><td><pre>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=61></td><td><pre>        <span class="token punctuation">]</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=62></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=63></td><td><pre></pre></td></tr><tr><td data-num=64></td><td><pre>    screen<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=65></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=66></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=67></td><td><pre><span class="token comment"> * 上面使用Box::new(T)的方式来创建了两个Box&lt;dyn Draw>特征对象，</span></pre></td></tr><tr><td data-num=68></td><td><pre><span class="token comment"> * 如果还需要增加UI组件，那么让该组件实现Draw特征，</span></pre></td></tr><tr><td data-num=69></td><td><pre><span class="token comment"> * 则可以很轻松的将其渲染在屏幕上，甚至用户可以引入该库作为三方库，</span></pre></td></tr><tr><td data-num=70></td><td><pre><span class="token comment"> * 然后在本地库中为自定义类型实现Draw特征，然后进行渲染。</span></pre></td></tr><tr><td data-num=71></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><p>在动态类型语言中，有一个很重要的概念 - <strong>鸭子类型</strong>(duck typing)。简单来说，就是只关心值长啥样，而不关心它实际是什么。当一个东西走起来像鸭子，叫起来像鸭子，那么它就是一只鸭子。</p><p>在上例中，<code>Screen</code>在<code>run</code>的时候，并不需要知道各个组件的具体类型是什么，也不检查组件到底是<code>Button</code>还是<code>SelectBox</code>的实例，只要它实现了<code>Draw</code>特征就能通过<code>Box::new</code>包装成<code>Box&lt;dyn Draw&gt;</code>特征对象，然后被渲染在屏幕上。</p><p>使用特征对象和Rust类型来进行类似鸭子类型操作的优势是，无需在运行时检查一个值是否实现了特定方法或者担心在调用时因为值没有实现方法而产生错误。如果值没有实现特征对象所需的特征， 那么Rust根本就不会编译这些代码。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">let</span> screen <span class="token operator">=</span> <span class="token class-name">Screen</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>        components<span class="token punctuation">:</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span></pre></td></tr><tr><td data-num=4></td><td><pre>            <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Hi"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=5></td><td><pre>        <span class="token punctuation">]</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre></pre></td></tr><tr><td data-num=8></td><td><pre>    screen<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token comment"> * 因为String类型没有实现Draw特征，</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token comment"> * 编译器直接就会报错，不会让上述代码运行。</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token comment"> * 如果想要String类型被渲染在屏幕上，那么只需要为其实现Draw特征即可。</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><p>注意<code>dyn</code>不能单独作为特征对象的定义。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">draw2</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">dyn</span> <span class="token class-name">Draw</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    x<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment"> * 编译器会报错，原因是特征对象可以是任意实现了某个特征的类型，</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment"> * 编译器在编译期不知道该类型的大小，不同的类型大小是不同的。</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><p>而<code>&amp;dyn</code>和<code>Box&lt;dyn&gt;</code>在编译期都是已知大小，所以可以用作特征对象的定义。</p><h4 id=特征对象的动态分发><a class=anchor href=#特征对象的动态分发>#</a> 特征对象的动态分发</h4><p>泛型是在编译期完成处理的，编译器会为每一个泛型参数对应的具体类型生成一份代码，这种方式是<strong>静态分发(static dispatch)</strong>，因为是在编译期完成的，对于运行期的性能完全没有任何影响。与之相对应的是<strong>动态分发(dynamic dispatch)</strong>，在这种情况下，直到运行时，才能确定需要调用什么方法。之前代码中的关键字 <code>dyn</code> 正是在强调这一<code>动态</code>的特点。</p><p>当使用特征对象时，Rust必须使用动态分发。因为编译器无法知晓所有可能用于特征对象代码的类型，因此就不知道应该调用哪个类型的哪个方法实现。动态分发也会阻止编译器有选择的内联方法代码，这会相应的禁用一些优化。</p><p>静态分发<code>Box&lt;T&gt;</code>和动态分发<code>Box&lt;dyn Trait&gt;</code>的区别</p><p><img data-src=https://jd.reversesacle.com/gh/ReverseSacle/Gallery@latest/programming/rust/basic/1.webp alt=""></p><p><strong>特征对象大小不固定</strong>，因为，对于特征<code>Draw</code>，类型<code>Button</code>可以实现特征<code>Draw</code>，类型<code>SelectBox</code>也可以实现特征<code>Draw</code>，因此特征没有固定大小。</p><p><strong>几乎总是使用特征对象的引用方式</strong>，如 <code>&amp;dyn Draw</code>、<code>Box&lt;dyn Draw&gt;</code>。</p><ul><li>特征对象没有固定大小，但它的引用类型的大小是固定的，由两个指针组成(<code>ptr</code>和<code>vptr</code>)，只占用两个指针大小</li><li>指针<code>ptr</code>指向实现了特征<code>Draw</code>的具体类型的实例，也就是当作特征<code>Draw</code>来用的类型的实例，比如类型<code>Button</code>的实例、类型<code>SelectBox</code>的实例</li><li>指针<code>vptr</code>指向一个虚表<code>vtable</code>。<code>vtable</code>中保存了类型<code>Button</code>或类型<code>SelectBox</code>的实例，对于可以调用的实现于特征<code>Draw</code>的方法。当调用方法时，直接从<code>vtable</code>中找到方法并调用。之所以要使用一个<code>vtable</code>来保存各实例的方法，是因为实现了特征<code>Draw</code>的类型有多种，这些类型拥有的方法各不相同，当将这些类型的实例都当作特征<code>Draw</code>来使用时(此时，它们全都看作是特征<code>Draw</code>类型的实例)，有必要区分这些实例各自有哪些方法可调用</li></ul><p>当类型<code>Button</code>实现了特征<code>Draw</code>时，类型<code>Button</code>的实例对象<code>btn</code>可以当作特征<code>Draw</code>的特征对象类型来使用<code>btn</code>中保存了作为特征对象的数据指针(指向类型<code>Button</code>的实例数据)和行为指针(指向<code>vtable</code>)。</p><p>一定要注意，此时的<code>btn</code>是<code>Draw</code>的特征对象的实例，而不再是具体类型<code>Button</code>的实例，而且<code>btn</code>的<code>vtable</code>只包含了实现自特征<code>Draw</code>的那些方法(比如 <code>draw</code>)，因此<code>btn</code>只能调用实现于特征<code>Draw</code>的<code>draw</code>方法，而不能调用类型<code>Button</code>本身实现的方法和类型<code>Button</code>实现于其他特征的方法。也就是说，<code>btn</code>是哪个特征对象的实例，它的<code>vtable</code>中就包含了该特征的方法。</p><h4 id=特征对象的限制><a class=anchor href=#特征对象的限制>#</a> 特征对象的限制</h4><p>不是所有特征都能拥有特征对象，只有对象安全的特征才行。当一个特征的所有方法都有如下属性时，它的对象才是安全的</p><ul><li>方法的返回类型不能是<code>Self</code></li><li>方法没有任何泛型参数</li></ul><p>对象安全对于特征对象是必须的，因为一旦有了特征对象，就不再需要知道实现该特征的具体类型是什么了。如果特征方法返回了具体的<code>Self</code>类型，但是特征对象忘记了其真正的类型，那这个<code>Self</code>就非常尴尬，因为没人知道它是谁了。但是对于泛型类型参数来说，当使用特征时其会放入具体的类型参数，此具体类型变成了实现该特征的类型的一部分。而当使用特征对象时其具体类型被抹去了，故而无从得知放入泛型参数类型到底是什么。</p><p>标准库中的<code>Clone</code>特征就不符合对象安全的要求，因为它的其中一个方法，返回了<code>Self</code>类型，因此它是对象不安全的。<code>String</code>类型实现了<code>Clone</code>特征，<code>String</code>实例上调用<code>clone</code>方法时会得到一个<code>String</code>实例。类似的，当调用<code>Vec&lt;T&gt;</code>实例的<code>clone</code>方法会得到一个<code>Vec&lt;T&gt;</code>实例。<code>clone</code>的签名需要知道什么类型会代替<code>Self</code>，因为这是它的返回值。</p><p>如果违反了对象安全的规则，编译器会提示。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Screen</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">pub</span> components<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token keyword">dyn</span> <span class="token class-name">Clone</span><span class="token operator">>></span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment"> * 错误如下</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token comment"> * error[E0038]: the trait `std::clone::Clone` cannot be made into an object</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token comment"> * --> src/lib.rs:2:5</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token comment"> * |</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token comment"> * 2 |     pub components: Vec&lt;Box&lt;dyn Clone>>,</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token comment"> * |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone`</span></pre></td></tr><tr><td data-num=12></td><td><pre><span class="token comment"> * cannot be made into an object</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token comment"> * |</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token comment"> * = note: the trait cannot require that `Self : Sized`</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><p>这意味着不能以这种方式使用此特征作为特征对象。</p><h3 id=调用同名的方法><a class=anchor href=#调用同名的方法>#</a> 调用同名的方法</h3><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">trait</span> <span class="token type-definition class-name">Pilot</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">fly</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">trait</span> <span class="token type-definition class-name">Wizard</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">fly</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=8></td><td><pre></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">Human</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Pilot</span> <span class="token keyword">for</span> <span class="token class-name">Human</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">fly</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=13></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"This is your captain speaking."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=16></td><td><pre></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Wizard</span> <span class="token keyword">for</span> <span class="token class-name">Human</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=18></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">fly</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=19></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Up!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=20></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=22></td><td><pre></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Human</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=24></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">fly</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=25></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"*waving arms furiously*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=26></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=27></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><font size=3><ins><strong>优先调用类型上的方法</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 当调用Human实例的fly时，编译器默认调用该类型中定义的方法</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token class-name">Human</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    person<span class="token punctuation">.</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment">// 这段代码会打印 *waving arms furiously*</span></pre></td></tr></table></figure><p><font size=3><ins><strong>调用特征上的方法</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 显式调用的语法</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    <span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token class-name">Human</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre>    <span class="token class-name">Pilot</span><span class="token punctuation">::</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用Pilot特征上的方法</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token class-name">Wizard</span><span class="token punctuation">::</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用Wizard特征上的方法</span></pre></td></tr><tr><td data-num=6></td><td><pre>    person<span class="token punctuation">.</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用Human类型自身的方法</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token comment">/** </span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token comment"> * 因为fly方法的参数是self，</span></pre></td></tr><tr><td data-num=10></td><td><pre><span class="token comment"> * 当显式调用时，编译器就可以根据调用的类型(self的类型)决定具体调用哪个方法。</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><h3 id=完全限定语法><a class=anchor href=#完全限定语法>#</a> 完全限定语法</h3><p><font size=3><ins><strong>没有self参数的关联函数</strong></ins></font></p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">trait</span> <span class="token type-definition class-name">Animal</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">baby_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">Dog</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Dog</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">baby_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=9></td><td><pre>        <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Spot"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=12></td><td><pre></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Animal</span> <span class="token keyword">for</span> <span class="token class-name">Dog</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">baby_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=15></td><td><pre>        <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"puppy"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=16></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=18></td><td><pre></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=20></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"A baby dog is called a &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token class-name">Dog</span><span class="token punctuation">::</span><span class="token function">baby_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>当出现此情况并想调用同名的方法时，需要使用<strong>完全限定语法</strong>，完全限定语法是调用函数最为明确的方式。</p><p>完全限定语法定义 - <code>&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code>。第一个参数是只有方法才拥有的接收器<code>receiver</code> (三种<code>self</code>)，关联函数中没有<code>receiver</code>。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=2></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"A baby dog is called a &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token class-name">Dog</span> <span class="token keyword">as</span> <span class="token class-name">Animal</span><span class="token operator">></span><span class="token punctuation">::</span><span class="token function">baby_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token comment"> * 在尖括号中，通过as关键字向Rust编译器提供了类型注解，</span></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token comment"> * 即Animal就是Dog，而不是其他动物，</span></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token comment"> * 因此最终会调用impl Animal for Dog中的方法。</span></pre></td></tr><tr><td data-num=8></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><p>完全限定语法可以用于任何函数或方法调用。由于Rust编译器能根据上下文自动推导出调用的路径，因此大多数时候，都无需使用完全限定语法。只有当存在多个同名函数或方法且Rust无法区分出期望调用的目标函数时，该用法才会被真正用到。</p><h3 id=特征定义中的特征约束><a class=anchor href=#特征定义中的特征约束>#</a> 特征定义中的特征约束</h3><p>有时会需要让某个特征A能使用另一个特征B的功能(另一种形式的特征约束)，这种情况下，不仅仅要为类型实现特征A，还要为类型实现特征B才行，这就是<code>supertrait</code>。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token comment">// 一个特征OutlinePrint中有一个方法，能够对当前的实现类型进行格式化输出</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>fmt<span class="token punctuation">::</span></span><span class="token class-name">Display</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=3></td><td><pre></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token keyword">trait</span> <span class="token type-definition class-name">OutlinePrint</span><span class="token punctuation">:</span> <span class="token class-name">Display</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=5></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">outline_print</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>        <span class="token keyword">let</span> output <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=7></td><td><pre>        <span class="token keyword">let</span> len <span class="token operator">=</span> output<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"*&#123;&#125;*"</span><span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"* &#123;&#125; *"</span><span class="token punctuation">,</span> output<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"*&#123;&#125;*"</span><span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>OutlinePrint: Display</code>和特征约束非常类似，都用来说明一个特征需要实现另一个特征。</p><h3 id=在外部类型上实现外部特征newtype><a class=anchor href=#在外部类型上实现外部特征newtype>#</a> 在外部类型上实现外部特征(newtype)</h3><p>孤儿规则，简单来说就是特征或类型必需至少有一个是本地的，才能在此类型上定义特征。</p><p>使用<code>newtype 模式</code>可绕过孤儿规则。就是为一个元组结构体创建新类型，该元组结构体封装有一个字段，该字段就是希望实现特征的具体类型，该封装类型是本地的，因此我们可以为此类型实现外部的特征。</p><p><code>newtype</code>不仅仅能实现以上的功能，而且它在运行时没有任何性能损耗，因为在编译期该类型会被自动忽略。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span></span>fmt<span class="token punctuation">;</span></pre></td></tr><tr><td data-num=2></td><td><pre></pre></td></tr><tr><td data-num=3></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">Wrapper</span><span class="token punctuation">(</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=4></td><td><pre></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token keyword">impl</span> <span class="token namespace">fmt<span class="token punctuation">::</span></span><span class="token class-name">Display</span> <span class="token keyword">for</span> <span class="token class-name">Wrapper</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=6></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">fmt</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> f<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token namespace">fmt<span class="token punctuation">::</span></span><span class="token class-name">Formatter</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token namespace">fmt<span class="token punctuation">::</span></span><span class="token class-name">Result</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>        <span class="token macro property">write!</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token string">"[&#123;&#125;]"</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=10></td><td><pre></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token keyword">let</span> w <span class="token operator">=</span> <span class="token class-name">Wrapper</span><span class="token punctuation">(</span><span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"w = &#123;&#125;"</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>struct Wrapper(Vec&lt;String&gt;)</code>就是一个元组结构体，定义了一个新类型<code>Wrapper</code>。</p><p>以上例子可见<code>newtype</code>的缺点是非常啰嗦，可通过实现<code>Deref</code>特征解决。实现该特征后会自动做一层类似类型转换的操作，将<code>Wrapper</code>变成<code>Vec&lt;String&gt;</code>，可以像直接使用数组那样去使用<code>Wrapper</code>，而无需为每一个操作都添加上<code>self.0</code>。</p><p>如果不想<code>Wrapper</code>暴露底层数组的所有方法，还可以为<code>Wrapper</code>去重载这些方法，实现隐藏的目的。</p><h2 id=编译器属性标记的使用><a class=anchor href=#编译器属性标记的使用>#</a> 编译器属性标记的使用</h2><p>编译器属性标记是用来控制编译器行为和设置特定属性的元信息(metadata)指令，以<code>#![...]</code>的方式放置在Rust源代码的顶部，通常位于函数之前或模块定义之前。这些属性标记可以影响编译器的行为，以满足特定需求或设置代码的特性。</p><h3 id=派生宏结构体等类型可用><a class=anchor href=#派生宏结构体等类型可用>#</a> 派生宏(结构体等类型可用)</h3><h4 id=格式化调试派生><a class=anchor href=#格式化调试派生>#</a> 格式化调试派生</h4><p><code>#[derive(Debug)]</code> - 用于自动生成对结构体或枚举类型实现<code>Debug</code>特征的代码</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token attribute attr-name">#[derive(Debug)]</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">Rectangle</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=4></td><td><pre>    height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">let</span> rect1 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=9></td><td><pre>        width<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=10></td><td><pre>        height<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"rect1 is &#123;:?&#125;"</span><span class="token punctuation">,</span> rect1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"rect1 is &#123;:#?&#125;"</span><span class="token punctuation">,</span> rect1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token comment"> * &#123;:?&#125;输出为rect1 is Rectangle &#123; width: 30, height: 50 &#125;</span></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token comment"> * &#123;:#?&#125;输出为</span></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token comment"> * rect1 is Rectangle &#123;</span></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token comment"> *    width: 30,</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token comment"> *    height: 50,</span></pre></td></tr><tr><td data-num=22></td><td><pre><span class="token comment"> * &#125;</span></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><p>除了<code>&#123;:?&#125;</code>与<code>&#123;:#?&#125;</code>外，可通过<code>dbg!</code>宏来简单的输出debug信息，它会拿走表达式的所有权，然后打印出相应的文件名、行号等debug信息以及表达式的求值结果，甚至最终还会把表达式值的<strong>所有权返回</strong>。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token attribute attr-name">#[derive(Debug)]</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">Rectangle</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=4></td><td><pre>    height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">let</span> scale <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token keyword">let</span> rect1 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=10></td><td><pre>        width<span class="token punctuation">:</span> <span class="token macro property">dbg!</span><span class="token punctuation">(</span><span class="token number">30</span> <span class="token operator">*</span> scale<span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=11></td><td><pre>        height<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token macro property">dbg!</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rect1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=16></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num=17></td><td><pre><span class="token comment"> * 输出结果为</span></pre></td></tr><tr><td data-num=18></td><td><pre><span class="token comment"> * [src/main.rs:10] 30 * scale = 60</span></pre></td></tr><tr><td data-num=19></td><td><pre><span class="token comment"> * [src/main.rs:14] &amp;rect1 = Rectangle &#123;</span></pre></td></tr><tr><td data-num=20></td><td><pre><span class="token comment"> *   width: 60,</span></pre></td></tr><tr><td data-num=21></td><td><pre><span class="token comment"> *   height: 50,</span></pre></td></tr><tr><td data-num=22></td><td><pre><span class="token comment"> * &#125;</span></pre></td></tr><tr><td data-num=23></td><td><pre><span class="token comment">**/</span></pre></td></tr></table></figure><h4 id=克隆派生><a class=anchor href=#克隆派生>#</a> 克隆派生</h4><p><code>#[derive(Clone)]</code> - 用于自动生成对结构体或枚举类型实现<code>Clone</code>特征的代码。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token attribute attr-name">#[derive(Clone)]</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">Point</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=4></td><td><pre>    y<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">let</span> original <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> x<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">20</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token keyword">let</span> cloned <span class="token operator">=</span> original<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    </pre></td></tr><tr><td data-num=11></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Original: x=&#123;&#125;, y=&#123;&#125;"</span><span class="token punctuation">,</span> original<span class="token punctuation">.</span>x<span class="token punctuation">,</span> original<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Cloned: x=&#123;&#125;, y=&#123;&#125;"</span><span class="token punctuation">,</span> cloned<span class="token punctuation">.</span>x<span class="token punctuation">,</span> cloned<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id=相等比较派生><a class=anchor href=#相等比较派生>#</a> 相等比较派生</h4><p><code>#[derive(PartialEq)]</code> - 用于自动生成用于比较结构体或枚举的实例是否相等的<code>PartialEq</code>特征的实现。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token attribute attr-name">#[derive(PartialEq)]</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">Point</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=4></td><td><pre>    y<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">let</span> point1 <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre>    <span class="token keyword">let</span> point2 <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token keyword">let</span> point3 <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> x<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=11></td><td><pre>    </pre></td></tr><tr><td data-num=12></td><td><pre>    <span class="token comment">// 使用自动生成的 PartialEq 实现</span></pre></td></tr><tr><td data-num=13></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"point1 == point2: &#123;&#125;"</span><span class="token punctuation">,</span> point1 <span class="token operator">==</span> point2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"point1 == point3: &#123;&#125;"</span><span class="token punctuation">,</span> point1 <span class="token operator">==</span> point3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span></pre></td></tr><tr><td data-num=15></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id=排序派生><a class=anchor href=#排序派生>#</a> 排序派生</h4><p><code>#[derive(Ord, Eq, PartialEq, PartialOrd)]</code> - 排序需要的特征</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token attribute attr-name">#[derive(Debug, Ord, Eq, PartialEq, PartialOrd)]</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">struct</span> <span class="token type-definition class-name">Person</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=4></td><td><pre>    age<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=5></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=6></td><td><pre></pre></td></tr><tr><td data-num=7></td><td><pre><span class="token keyword">impl</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=9></td><td><pre>        <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span> name<span class="token punctuation">,</span> age <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=10></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=11></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=12></td><td><pre></pre></td></tr><tr><td data-num=13></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=14></td><td><pre>    <span class="token keyword">let</span> <span class="token keyword">mut</span> people <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span></pre></td></tr><tr><td data-num=15></td><td><pre>        <span class="token class-name">Person</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Zoe"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=16></td><td><pre>        <span class="token class-name">Person</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Al"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=17></td><td><pre>        <span class="token class-name">Person</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"Al"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=18></td><td><pre>        <span class="token class-name">Person</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=19></td><td><pre>        <span class="token class-name">Person</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num=20></td><td><pre>    <span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=21></td><td><pre></pre></td></tr><tr><td data-num=22></td><td><pre>    people<span class="token punctuation">.</span><span class="token function">sort_unstable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=23></td><td><pre></pre></td></tr><tr><td data-num=24></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;:?&#125;"</span><span class="token punctuation">,</span> people<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=25></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id=内联函数inline-functions><a class=anchor href=#内联函数inline-functions>#</a> 内联函数(inline functions)</h3><p>使用<code>#[inline]</code>属性来提示编译器将函数内联展开，以便在调用点直接插入函数的代码，而不是通过正常的函数调用方式执行。</p><figure class="highlight rust"><figcaption data-lang=Rust></figcaption><table><tr><td data-num=1></td><td><pre><span class="token attribute attr-name">#[inline]</span></pre></td></tr><tr><td data-num=2></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">my_inline_function</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">i32</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=3></td><td><pre>    x <span class="token operator">+</span> <span class="token number">1</span></pre></td></tr><tr><td data-num=4></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num=5></td><td><pre></pre></td></tr><tr><td data-num=6></td><td><pre><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num=7></td><td><pre>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">my_inline_function</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=8></td><td><pre>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Result: &#123;&#125;"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num=9></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id=控制警告信息><a class=anchor href=#控制警告信息>#</a> 控制警告信息</h3><h4 id=局部范围><a class=anchor href=#局部范围>#</a> 局部范围</h4><p><code>#[warn(unused_variables)]</code> - 告诉编译器在发现未使用的变量时生成警告信息，但不会导致编译失败</p><p><code>#[allow(unused_variables)]</code> - 告诉编译器在发现未使用的变量时不生成警告信息</p><h4 id=全局范围><a class=anchor href=#全局范围>#</a> 全局范围</h4><p><code>#![allow(unused)]</code> - 完全禁用编译器的未使用变量警告</p><p><code>#![allow(dead_code)]</code> - (用于开发阶段)允许未使用的代码(包括函数、结构体、枚举等)存在而不触发编译器的警告</p><p><code>#![allow(non_snake_case)]</code> - 禁用命名风格不符警告</p><p><code>#![allow(non_camel_case_types)]</code> - 禁用类型名风格不符警告</p><div class=tags><a href=/tags/programming-language/ rel=tag><i class="ic i-tag"></i> 编程语言</a></div></div><footer><div class=meta><span class=item><span class=icon><i class="ic i-calendar-check"></i></span> <span class=text>更新于</span> <time title="修改时间：2025-01-09 17:58:14" itemprop=dateModified datetime=2025-01-09T17:58:14+08:00>2025-01-09</time></span><span class=item data-path=/computer-science/programming/rust/rust-basic/rustpart2/ title=阅读次数><span class=icon><i class="ic i-eye"></i></span> <span class=text>阅读次数</span><span class=waline-pageview-count></span> <span class=text>次</span></span></div><div id=copyright><ul><li class=author><strong>本文作者：</strong> ReverseSacle <i class="ic i-at"><em>@</em></i>逆转天平</li><li class=link><strong>本文链接：</strong> <a href=https://www.reversesacle.com/computer-science/programming/rust/rust-basic/rustpart2/ title=Rust语言-基础-第二部分>https://www.reversesacle.com/computer-science/programming/rust/rust-basic/rustpart2/</a></li><li class=license><strong>版权声明：</strong> 本站所有文章除特别声明外，均采用 <span class=exturl data-url=aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class=post-nav><div class="item left"><a href=/computer-science/programming/rust/rust-basic/rustpart1/ itemprop=url rel=prev data-background-image=https:&#x2F;&#x2F;resa-imgs.oss-accelerate.aliyuncs.com&#x2F;img&#x2F;acg20.webp title=Rust语言-基础-第一部分><span class=type>上一篇</span><span class=category><i class="ic i-flag"></i> Rust基础</span><h3>Rust语言-基础-第一部分</h3></a></div><div class="item right"><a href=/computer-science/programming/rust/rust-basic/rustpart3/ itemprop=url rel=next data-background-image=https:&#x2F;&#x2F;resa-imgs.oss-accelerate.aliyuncs.com&#x2F;img&#x2F;acg14.webp title=Rust语言-基础-第三部分><span class=type>下一篇</span><span class=category><i class="ic i-flag"></i> Rust基础</span><h3>Rust语言-基础-第三部分</h3></a></div></div><div class=wrap id=comments><div id=waline-comment></div></div></div><div id=sidebar><div class=inner><div class=panels><div class=inner><div class="contents panel pjax" data-title=文章目录><ol class=toc><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%89%80%E6%9C%89%E6%9D%83%E8%BD%AC%E7%A7%BB><span class=toc-number>1.</span> <span class=toc-text>所有权转移</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%9F%BA%E6%9C%AC><span class=toc-number>1.1.</span> <span class=toc-text>基本</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%85%8B%E9%9A%86%E6%B7%B1%E6%8B%B7%E8%B4%9D><span class=toc-number>1.2.</span> <span class=toc-text>克隆(深拷贝)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D><span class=toc-number>1.3.</span> <span class=toc-text>拷贝(浅拷贝)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E4%B8%8E%E5%80%BC%E8%BF%94%E5%9B%9E><span class=toc-number>1.4.</span> <span class=toc-text>函数传参与值返回</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95><span class=toc-number>1.5.</span> <span class=toc-text>相关方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B><span class=toc-number>2.</span> <span class=toc-text>集合类型</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84vector><span class=toc-number>2.1.</span> <span class=toc-text>动态数组(Vector)</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#vector%E7%9A%84%E5%88%9B%E5%BB%BA><span class=toc-number>2.1.1.</span> <span class=toc-text>Vector的创建</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#vector%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C><span class=toc-number>2.1.2.</span> <span class=toc-text>Vector相关操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%97%A0%E5%BA%8F%E9%94%AE%E5%80%BC%E5%AF%B9%E5%AD%98%E5%82%A8hashmap><span class=toc-number>2.2.</span> <span class=toc-text>无序键值对存储(HashMap)</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#hashmap%E7%9A%84%E5%88%9B%E5%BB%BA><span class=toc-number>2.2.1.</span> <span class=toc-text>HashMap的创建</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#hashmap%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C><span class=toc-number>2.2.2.</span> <span class=toc-text>HashMap相关操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%97%A0%E5%BA%8F%E9%9B%86%E5%90%88hashset><span class=toc-number>2.3.</span> <span class=toc-text>无序集合(HashSet)</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#hashset%E7%9A%84%E5%88%9B%E5%BB%BA><span class=toc-number>2.3.1.</span> <span class=toc-text>HashSet的创建</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#hashset%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C><span class=toc-number>2.3.2.</span> <span class=toc-text>HashSet相关操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%9C%89%E5%BA%8F%E9%94%AE%E5%80%BC%E5%AF%B9%E5%AD%98%E5%82%A8btreemap><span class=toc-number>2.4.</span> <span class=toc-text>有序键值对存储(BTreeMap)</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#btreemap%E7%9A%84%E5%88%9B%E5%BB%BA><span class=toc-number>2.4.1.</span> <span class=toc-text>BTreeMap的创建</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#btreemap%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C><span class=toc-number>2.4.2.</span> <span class=toc-text>BTreeMap相关操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88btreeset><span class=toc-number>2.5.</span> <span class=toc-text>有序集合(BTreeSet)</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#btreeset%E7%9A%84%E5%88%9B%E5%BB%BA><span class=toc-number>2.5.1.</span> <span class=toc-text>BTreeSet的创建</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#btreeset%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C><span class=toc-number>2.5.2.</span> <span class=toc-text>BTreeSet相关操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%AE%A1%E7%90%86><span class=toc-number>3.</span> <span class=toc-text>内存操作与管理</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#rust%E4%B8%8E%E5%A0%86%E6%A0%88><span class=toc-number>3.1.</span> <span class=toc-text>Rust与堆栈</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%AE%9A%E9%95%BF%E7%B1%BB%E5%9E%8B%E4%B8%8E%E4%B8%8D%E5%AE%9A%E9%95%BF%E7%B1%BB%E5%9E%8B><span class=toc-number>3.2.</span> <span class=toc-text>定长类型与不定长类型</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8Bdst><span class=toc-number>3.2.1.</span> <span class=toc-text>动态大小类型DST</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#sized%E7%89%B9%E5%BE%81><span class=toc-number>3.2.2.</span> <span class=toc-text>Sized特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#box%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88><span class=toc-number>3.3.</span> <span class=toc-text>Box智能指针</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#box%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8><span class=toc-number>3.3.1.</span> <span class=toc-text>Box智能指针的使用</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B><span class=toc-number>3.3.2.</span> <span class=toc-text>动态大小类型转换为固定大小类型</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#box%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80><span class=toc-number>3.3.3.</span> <span class=toc-text>Box内存布局</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#deref%E8%A7%A3%E5%BC%95%E7%94%A8><span class=toc-number>3.4.</span> <span class=toc-text>Deref解引用</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%B8%B8%E8%A7%84%E8%A7%A3%E5%BC%95%E7%94%A8><span class=toc-number>3.4.1.</span> <span class=toc-text>常规解引用</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%A7%A3%E5%BC%95%E7%94%A8><span class=toc-number>3.4.2.</span> <span class=toc-text>智能指针解引用</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E8%83%8C%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86><span class=toc-number>3.4.3.</span> <span class=toc-text>*背后的原理</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E8%87%AA%E5%88%B6%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88><span class=toc-number>3.4.4.</span> <span class=toc-text>自制智能指针</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BC%8Fderef%E8%BD%AC%E6%8D%A2><span class=toc-number>3.4.5.</span> <span class=toc-text>函数和方法中的隐式Deref转换</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#deref%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93><span class=toc-number>3.4.6.</span> <span class=toc-text>Deref规则总结</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E4%B8%89%E7%A7%8Dderef%E8%BD%AC%E6%8D%A2><span class=toc-number>3.4.7.</span> <span class=toc-text>三种Deref转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#drop%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90><span class=toc-number>3.5.</span> <span class=toc-text>Drop释放资源</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#drop%E7%9A%84%E9%A1%BA%E5%BA%8F><span class=toc-number>3.5.1.</span> <span class=toc-text>Drop的顺序</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E6%89%8B%E5%8A%A8%E5%9B%9E%E6%94%B6><span class=toc-number>3.5.2.</span> <span class=toc-text>手动回收</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#drop%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF><span class=toc-number>3.5.3.</span> <span class=toc-text>Drop使用场景</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E4%BA%92%E6%96%A5%E7%9A%84copy%E5%92%8Cdrop><span class=toc-number>3.5.4.</span> <span class=toc-text>互斥的Copy和Drop</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%B8%80%E5%AF%B9%E5%A4%9A%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E6%9C%BA%E5%88%B6><span class=toc-number>3.6.</span> <span class=toc-text>一对多的所有权机制</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#rct-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0reference-counting><span class=toc-number>3.6.1.</span> <span class=toc-text>Rc&lt;T&gt;-引用计数(Reference Counting)</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#arcatomic-rc><span class=toc-number>3.6.2.</span> <span class=toc-text>Arc(Atomic Rc)</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#cell%E5%92%8Crefcell><span class=toc-number>3.6.3.</span> <span class=toc-text>Cell和RefCell</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#rc%E4%B8%8Erefcell%E7%9A%84%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8><span class=toc-number>3.6.4.</span> <span class=toc-text>Rc与RefCell的组合使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%B7%B1%E5%85%A5%E7%89%B9%E5%BE%81><span class=toc-number>4.</span> <span class=toc-text>深入特征</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1><span class=toc-number>4.1.</span> <span class=toc-text>特征对象</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89><span class=toc-number>4.1.1.</span> <span class=toc-text>特征对象定义</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E5%8F%91><span class=toc-number>4.1.2.</span> <span class=toc-text>特征对象的动态分发</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%99%90%E5%88%B6><span class=toc-number>4.1.3.</span> <span class=toc-text>特征对象的限制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%B0%83%E7%94%A8%E5%90%8C%E5%90%8D%E7%9A%84%E6%96%B9%E6%B3%95><span class=toc-number>4.2.</span> <span class=toc-text>调用同名的方法</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95><span class=toc-number>4.3.</span> <span class=toc-text>完全限定语法</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%89%B9%E5%BE%81%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%89%B9%E5%BE%81%E7%BA%A6%E6%9D%9F><span class=toc-number>4.4.</span> <span class=toc-text>特征定义中的特征约束</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%9C%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E5%9E%8B%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8%E7%89%B9%E5%BE%81newtype><span class=toc-number>4.5.</span> <span class=toc-text>在外部类型上实现外部特征(newtype)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%BC%96%E8%AF%91%E5%99%A8%E5%B1%9E%E6%80%A7%E6%A0%87%E8%AE%B0%E7%9A%84%E4%BD%BF%E7%94%A8><span class=toc-number>5.</span> <span class=toc-text>编译器属性标记的使用</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%B4%BE%E7%94%9F%E5%AE%8F%E7%BB%93%E6%9E%84%E4%BD%93%E7%AD%89%E7%B1%BB%E5%9E%8B%E5%8F%AF%E7%94%A8><span class=toc-number>5.1.</span> <span class=toc-text>派生宏(结构体等类型可用)</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%B0%83%E8%AF%95%E6%B4%BE%E7%94%9F><span class=toc-number>5.1.1.</span> <span class=toc-text>格式化调试派生</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%85%8B%E9%9A%86%E6%B4%BE%E7%94%9F><span class=toc-number>5.1.2.</span> <span class=toc-text>克隆派生</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E7%9B%B8%E7%AD%89%E6%AF%94%E8%BE%83%E6%B4%BE%E7%94%9F><span class=toc-number>5.1.3.</span> <span class=toc-text>相等比较派生</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E6%8E%92%E5%BA%8F%E6%B4%BE%E7%94%9F><span class=toc-number>5.1.4.</span> <span class=toc-text>排序派生</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline-functions><span class=toc-number>5.2.</span> <span class=toc-text>内联函数(inline functions)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%8E%A7%E5%88%B6%E8%AD%A6%E5%91%8A%E4%BF%A1%E6%81%AF><span class=toc-number>5.3.</span> <span class=toc-text>控制警告信息</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%B1%80%E9%83%A8%E8%8C%83%E5%9B%B4><span class=toc-number>5.3.1.</span> <span class=toc-text>局部范围</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%85%A8%E5%B1%80%E8%8C%83%E5%9B%B4><span class=toc-number>5.3.2.</span> <span class=toc-text>全局范围</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title=系列文章><ul><li><a href=/computer-science/programming/rust/rust-basic/rustpart1/ rel=bookmark title=Rust语言-基础-第一部分>Rust语言-基础-第一部分</a></li><li class=active><a href=/computer-science/programming/rust/rust-basic/rustpart2/ rel=bookmark title=Rust语言-基础-第二部分>Rust语言-基础-第二部分</a></li><li><a href=/computer-science/programming/rust/rust-basic/rustpart3/ rel=bookmark title=Rust语言-基础-第三部分>Rust语言-基础-第三部分</a></li></ul></div><div class="overview panel" data-title=站点概览><div class=author itemprop=author itemscope itemtype=http://schema.org/Person><img class=image itemprop=image alt=ReverseSacle data-src=/images/avatar.webp><p class=name itemprop=name>ReverseSacle</p><div class=description itemprop=description>知识书库 & 学习点滴</div></div><nav class=state><div class="item posts"><a href=/archives/ ><span class=count>186</span> <span class=name>文章</span></a></div><div class="item categories"><a href=/categories/ ><span class=count>52</span> <span class=name>分类</span></a></div><div class="item tags"><a href=/tags/ ><span class=count>18</span> <span class=name>标签</span></a></div></nav><div class=social><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JldmVyc2VTYWNsZQ==" title=https:&#x2F;&#x2F;github.com&#x2F;ReverseSacle><i class="ic i-github"></i></span><span class="exturl item email" data-url="bWFpbHRvOnByaXZhdGVAcmV2ZXJzZXNhY2xlLmNvbQ==" title=mailto:private@reversesacle.com><i class="ic i-envelope"></i></span></div><ul class=menu><li class=item><a href=/ rel=section><i class="ic i-home"></i> 首页</a></li><li class="item dropdown"><a href=javascript:void(0);><i class="ic i-feather"></i> 文章</a><ul class=submenu><li class=item><a href=/archives/ rel=section><i class="ic i-list-alt"></i> 归档</a></li><li class=item><a href=/categories/ rel=section><i class="ic i-th"></i> 分类</a></li><li class=item><a href=/tags/ rel=section><i class="ic i-tags"></i> 标签</a></li></ul></li><li class=item><a href=/about/ rel=section><i class="ic i-user"></i> 关于</a></li><li class=item><a href=/friend-links/ rel=section><i class="ic i-heart"></i> 友链</a></li></ul></div></div></div><ul id=quick><li class="prev pjax"><a href=/computer-science/programming/rust/rust-basic/rustpart1/ rel=prev title=上一篇><i class="ic i-chevron-left"></i></a></li><li class=up><i class="ic i-arrow-up"></i></li><li class=down><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href=/computer-science/programming/rust/rust-basic/rustpart3/ rel=next title=下一篇><i class="ic i-chevron-right"></i></a></li><li class=percent></li></ul></div></div><div class=dimmer></div></div></main><footer id=footer><div class=inner><div class=widgets><div class="rpost pjax"><h2>随机文章</h2><ul><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/network-programming/ title="分类于 网络编程">网络编程</a></div><span><a href=/computer-science/programming/network-programming/thread-synchronization/ title=Linux线程同步>Linux线程同步</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/app-development/ title="分类于 应用开发">应用开发</a></div><span><a href=/computer-science/programming/app-development/web-exe-application/ title=web桌面应用开发(Electron与C语言)>web桌面应用开发(Electron与C语言)</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/c-data-structure/ title="分类于 C语言数据结构">C语言数据结构</a></div><span><a href=/computer-science/programming/c-language/c-data-structure/graph/ title=非线性结构之图>非线性结构之图</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/python/ title="分类于 Python">Python</a></div><span><a href=/computer-science/programming/python/pyinstaller/ title=Pyinstaller打包工具>Pyinstaller打包工具</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/algorithm/ title="分类于 算法">算法</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/algorithm/sort/ title="分类于 序列重组">序列重组</a></div><span><a href=/computer-science/programming/algorithm/sort/counting-sort/ title=计数排序>计数排序</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/ title="分类于 C语言">C语言</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/c-language/c-project/ title="分类于 C语言项目">C语言项目</a></div><span><a href=/computer-science/programming/c-language/c-project/comment-system-part1/ title=网站留言评论系统的设计与手动实现-初稿-第一部分>网站留言评论系统的设计与手动实现-初稿-第一部分</a></span></li><li class=item><div class=breadcrumb><a href=/categories/general-science-and-technology/ title="分类于 通用科学技术">通用科学技术</a><i class="ic i-angle-right"></i> <a href=/categories/general-science-and-technology/pc/ title="分类于 通用技术之PC端">通用技术之PC端</a><i class="ic i-angle-right"></i> <a href=/categories/general-science-and-technology/pc/laptop/ title="分类于 笔记本">笔记本</a></div><span><a href=/general-science-and-technology/pc/laptop/occupied-cpu-by-lenovo-isf/ title=占用CPU的Lenovo-ISFramework>占用CPU的Lenovo-ISFramework</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/web/ title="分类于 web">web</a></div><span><a href=/computer-science/programming/web/hcpart2/ title=HTML与CSS基础知识-第二部分>HTML与CSS基础知识-第二部分</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/database/ title="分类于 数据库">数据库</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/database/mysql/ title="分类于 MySQL">MySQL</a></div><span><a href=/computer-science/programming/database/mysql/mspart1/ title=MySQL数据库基础-第一部分>MySQL数据库基础-第一部分</a></span></li><li class=item><div class=breadcrumb><a href=/categories/computer-science/ title="分类于 计算机科学">计算机科学</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/ title="分类于 编程">编程</a><i class="ic i-angle-right"></i> <a href=/categories/computer-science/programming/network-programming/ title="分类于 网络编程">网络编程</a></div><span><a href=/computer-science/programming/network-programming/signal/ title=Linux的信号(signal)>Linux的信号(signal)</a></span></li></ul></div><div><h2>最新评论</h2><ul id=waline-recent></ul></div></div><div class=status><div class=copyright>&copy; 2021 – <span itemprop=copyrightYear>2025</span><span class=with-love><i class="ic i-sakura rotate"></i></span> <span class=author itemprop=copyrightHolder>ReverseSacle @ ReverseSacle-Blog</span></div><div class=count><i class="ic i-clock" aria-hidden=true></i> <span id=time align=center>载入时间中...<script defer>var now=new Date;function createtime(){var n=new Date("2021-11-16 22:30:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("time").innerHTML="已经过 "+dnum+" 天 "+hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></span><span class=post-meta-item-icon>|&nbsp<i class="ic i-chart-area"></i></span> <span title=站点总字数>2.1m 字</span> <span class=post-meta-item-icon>|&nbsp<i class="ic i-coffee"></i></span> <span title=站点阅读时长>40:40</span></div></div></div></footer></div><script data-config>var LOCAL={path:"computer-science/programming/rust/rust-basic/rustpart2/",favicon:{show:"ReverseSacle-Blog",hide:"ReverseSacle-Blog"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},waline:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src=https://polyfill.alicdn.com/v3/polyfill.min.js></script><script src=https://jd.reversesacle.com/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1.16.0/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js></script><script src=/js/app.js></script></body></html>